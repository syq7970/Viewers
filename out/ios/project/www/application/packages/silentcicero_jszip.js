//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
// Source maps are supported by all recent versions of Chrome, Safari,  //
// and Firefox, and by Internet Explorer 11.                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var global = Package.meteor.global;
var meteorEnv = Package.meteor.meteorEnv;

/* Package-scope variables */
var JSZip;

(function(){

//////////////////////////////////////////////////////////////////////////////////////////
//                                                                                      //
// packages/silentcicero_jszip/packages/silentcicero_jszip.js                           //
//                                                                                      //
//////////////////////////////////////////////////////////////////////////////////////////
                                                                                        //
(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/silentcicero:jszip/lib/jszip.js                                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*!                                                                                                                    // 1
                                                                                                                       // 2
JSZip - A Javascript class for generating and reading zip files                                                        // 3
<http://stuartk.com/jszip>                                                                                             // 4
                                                                                                                       // 5
(c) 2009-2014 Stuart Knightley <stuart [at] stuartk.com>                                                               // 6
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.           // 7
                                                                                                                       // 8
JSZip uses the library pako released under the MIT license :                                                           // 9
https://github.com/nodeca/pako/blob/master/LICENSE                                                                     // 10
*/                                                                                                                     // 11
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.JSZip=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 13
// private property                                                                                                    // 14
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";                                     // 15
                                                                                                                       // 16
                                                                                                                       // 17
// public method for encoding                                                                                          // 18
exports.encode = function(input, utf8) {                                                                               // 19
    var output = "";                                                                                                   // 20
    var chr1, chr2, chr3, enc1, enc2, enc3, enc4;                                                                      // 21
    var i = 0;                                                                                                         // 22
                                                                                                                       // 23
    while (i < input.length) {                                                                                         // 24
                                                                                                                       // 25
        chr1 = input.charCodeAt(i++);                                                                                  // 26
        chr2 = input.charCodeAt(i++);                                                                                  // 27
        chr3 = input.charCodeAt(i++);                                                                                  // 28
                                                                                                                       // 29
        enc1 = chr1 >> 2;                                                                                              // 30
        enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);                                                                        // 31
        enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);                                                                       // 32
        enc4 = chr3 & 63;                                                                                              // 33
                                                                                                                       // 34
        if (isNaN(chr2)) {                                                                                             // 35
            enc3 = enc4 = 64;                                                                                          // 36
        }                                                                                                              // 37
        else if (isNaN(chr3)) {                                                                                        // 38
            enc4 = 64;                                                                                                 // 39
        }                                                                                                              // 40
                                                                                                                       // 41
        output = output + _keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4);   // 42
                                                                                                                       // 43
    }                                                                                                                  // 44
                                                                                                                       // 45
    return output;                                                                                                     // 46
};                                                                                                                     // 47
                                                                                                                       // 48
// public method for decoding                                                                                          // 49
exports.decode = function(input, utf8) {                                                                               // 50
    var output = "";                                                                                                   // 51
    var chr1, chr2, chr3;                                                                                              // 52
    var enc1, enc2, enc3, enc4;                                                                                        // 53
    var i = 0;                                                                                                         // 54
                                                                                                                       // 55
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");                                                                  // 56
                                                                                                                       // 57
    while (i < input.length) {                                                                                         // 58
                                                                                                                       // 59
        enc1 = _keyStr.indexOf(input.charAt(i++));                                                                     // 60
        enc2 = _keyStr.indexOf(input.charAt(i++));                                                                     // 61
        enc3 = _keyStr.indexOf(input.charAt(i++));                                                                     // 62
        enc4 = _keyStr.indexOf(input.charAt(i++));                                                                     // 63
                                                                                                                       // 64
        chr1 = (enc1 << 2) | (enc2 >> 4);                                                                              // 65
        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);                                                                       // 66
        chr3 = ((enc3 & 3) << 6) | enc4;                                                                               // 67
                                                                                                                       // 68
        output = output + String.fromCharCode(chr1);                                                                   // 69
                                                                                                                       // 70
        if (enc3 != 64) {                                                                                              // 71
            output = output + String.fromCharCode(chr2);                                                               // 72
        }                                                                                                              // 73
        if (enc4 != 64) {                                                                                              // 74
            output = output + String.fromCharCode(chr3);                                                               // 75
        }                                                                                                              // 76
                                                                                                                       // 77
    }                                                                                                                  // 78
                                                                                                                       // 79
    return output;                                                                                                     // 80
                                                                                                                       // 81
};                                                                                                                     // 82
                                                                                                                       // 83
},{}],2:[function(_dereq_,module,exports){                                                                             // 84
'use strict';                                                                                                          // 85
function CompressedObject() {                                                                                          // 86
    this.compressedSize = 0;                                                                                           // 87
    this.uncompressedSize = 0;                                                                                         // 88
    this.crc32 = 0;                                                                                                    // 89
    this.compressionMethod = null;                                                                                     // 90
    this.compressedContent = null;                                                                                     // 91
}                                                                                                                      // 92
                                                                                                                       // 93
CompressedObject.prototype = {                                                                                         // 94
    /**                                                                                                                // 95
     * Return the decompressed content in an unspecified format.                                                       // 96
     * The format will depend on the decompressor.                                                                     // 97
     * @return {Object} the decompressed content.                                                                      // 98
     */                                                                                                                // 99
    getContent: function() {                                                                                           // 100
        return null; // see implementation                                                                             // 101
    },                                                                                                                 // 102
    /**                                                                                                                // 103
     * Return the compressed content in an unspecified format.                                                         // 104
     * The format will depend on the compressed conten source.                                                         // 105
     * @return {Object} the compressed content.                                                                        // 106
     */                                                                                                                // 107
    getCompressedContent: function() {                                                                                 // 108
        return null; // see implementation                                                                             // 109
    }                                                                                                                  // 110
};                                                                                                                     // 111
module.exports = CompressedObject;                                                                                     // 112
                                                                                                                       // 113
},{}],3:[function(_dereq_,module,exports){                                                                             // 114
'use strict';                                                                                                          // 115
exports.STORE = {                                                                                                      // 116
    magic: "\x00\x00",                                                                                                 // 117
    compress: function(content, compressionOptions) {                                                                  // 118
        return content; // no compression                                                                              // 119
    },                                                                                                                 // 120
    uncompress: function(content) {                                                                                    // 121
        return content; // no compression                                                                              // 122
    },                                                                                                                 // 123
    compressInputType: null,                                                                                           // 124
    uncompressInputType: null                                                                                          // 125
};                                                                                                                     // 126
exports.DEFLATE = _dereq_('./flate');                                                                                  // 127
                                                                                                                       // 128
},{"./flate":8}],4:[function(_dereq_,module,exports){                                                                  // 129
'use strict';                                                                                                          // 130
                                                                                                                       // 131
var utils = _dereq_('./utils');                                                                                        // 132
                                                                                                                       // 133
var table = [                                                                                                          // 134
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,                                                                    // 135
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,                                                                    // 136
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,                                                                    // 137
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,                                                                    // 138
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,                                                                    // 139
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,                                                                    // 140
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,                                                                    // 141
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,                                                                    // 142
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,                                                                    // 143
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,                                                                    // 144
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,                                                                    // 145
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,                                                                    // 146
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,                                                                    // 147
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,                                                                    // 148
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,                                                                    // 149
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,                                                                    // 150
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,                                                                    // 151
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,                                                                    // 152
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,                                                                    // 153
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,                                                                    // 154
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,                                                                    // 155
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,                                                                    // 156
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,                                                                    // 157
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,                                                                    // 158
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,                                                                    // 159
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,                                                                    // 160
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,                                                                    // 161
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,                                                                    // 162
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,                                                                    // 163
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,                                                                    // 164
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,                                                                    // 165
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,                                                                    // 166
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,                                                                    // 167
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,                                                                    // 168
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,                                                                    // 169
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,                                                                    // 170
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,                                                                    // 171
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,                                                                    // 172
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,                                                                    // 173
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,                                                                    // 174
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,                                                                    // 175
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,                                                                    // 176
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,                                                                    // 177
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,                                                                    // 178
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,                                                                    // 179
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,                                                                    // 180
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,                                                                    // 181
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,                                                                    // 182
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,                                                                    // 183
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,                                                                    // 184
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,                                                                    // 185
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,                                                                    // 186
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,                                                                    // 187
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,                                                                    // 188
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,                                                                    // 189
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,                                                                    // 190
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,                                                                    // 191
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,                                                                    // 192
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,                                                                    // 193
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,                                                                    // 194
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,                                                                    // 195
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,                                                                    // 196
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,                                                                    // 197
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D                                                                     // 198
];                                                                                                                     // 199
                                                                                                                       // 200
/**                                                                                                                    // 201
 *                                                                                                                     // 202
 *  Javascript crc32                                                                                                   // 203
 *  http://www.webtoolkit.info/                                                                                        // 204
 *                                                                                                                     // 205
 */                                                                                                                    // 206
module.exports = function crc32(input, crc) {                                                                          // 207
    if (typeof input === "undefined" || !input.length) {                                                               // 208
        return 0;                                                                                                      // 209
    }                                                                                                                  // 210
                                                                                                                       // 211
    var isArray = utils.getTypeOf(input) !== "string";                                                                 // 212
                                                                                                                       // 213
    if (typeof(crc) == "undefined") {                                                                                  // 214
        crc = 0;                                                                                                       // 215
    }                                                                                                                  // 216
    var x = 0;                                                                                                         // 217
    var y = 0;                                                                                                         // 218
    var b = 0;                                                                                                         // 219
                                                                                                                       // 220
    crc = crc ^ (-1);                                                                                                  // 221
    for (var i = 0, iTop = input.length; i < iTop; i++) {                                                              // 222
        b = isArray ? input[i] : input.charCodeAt(i);                                                                  // 223
        y = (crc ^ b) & 0xFF;                                                                                          // 224
        x = table[y];                                                                                                  // 225
        crc = (crc >>> 8) ^ x;                                                                                         // 226
    }                                                                                                                  // 227
                                                                                                                       // 228
    return crc ^ (-1);                                                                                                 // 229
};                                                                                                                     // 230
// vim: set shiftwidth=4 softtabstop=4:                                                                                // 231
                                                                                                                       // 232
},{"./utils":21}],5:[function(_dereq_,module,exports){                                                                 // 233
'use strict';                                                                                                          // 234
var utils = _dereq_('./utils');                                                                                        // 235
                                                                                                                       // 236
function DataReader(data) {                                                                                            // 237
    this.data = null; // type : see implementation                                                                     // 238
    this.length = 0;                                                                                                   // 239
    this.index = 0;                                                                                                    // 240
}                                                                                                                      // 241
DataReader.prototype = {                                                                                               // 242
    /**                                                                                                                // 243
     * Check that the offset will not go too far.                                                                      // 244
     * @param {string} offset the additional offset to check.                                                          // 245
     * @throws {Error} an Error if the offset is out of bounds.                                                        // 246
     */                                                                                                                // 247
    checkOffset: function(offset) {                                                                                    // 248
        this.checkIndex(this.index + offset);                                                                          // 249
    },                                                                                                                 // 250
    /**                                                                                                                // 251
     * Check that the specifed index will not be too far.                                                              // 252
     * @param {string} newIndex the index to check.                                                                    // 253
     * @throws {Error} an Error if the index is out of bounds.                                                         // 254
     */                                                                                                                // 255
    checkIndex: function(newIndex) {                                                                                   // 256
        if (this.length < newIndex || newIndex < 0) {                                                                  // 257
            throw new Error("End of data reached (data length = " + this.length + ", asked index = " + (newIndex) + "). Corrupted zip ?");
        }                                                                                                              // 259
    },                                                                                                                 // 260
    /**                                                                                                                // 261
     * Change the index.                                                                                               // 262
     * @param {number} newIndex The new index.                                                                         // 263
     * @throws {Error} if the new index is out of the data.                                                            // 264
     */                                                                                                                // 265
    setIndex: function(newIndex) {                                                                                     // 266
        this.checkIndex(newIndex);                                                                                     // 267
        this.index = newIndex;                                                                                         // 268
    },                                                                                                                 // 269
    /**                                                                                                                // 270
     * Skip the next n bytes.                                                                                          // 271
     * @param {number} n the number of bytes to skip.                                                                  // 272
     * @throws {Error} if the new index is out of the data.                                                            // 273
     */                                                                                                                // 274
    skip: function(n) {                                                                                                // 275
        this.setIndex(this.index + n);                                                                                 // 276
    },                                                                                                                 // 277
    /**                                                                                                                // 278
     * Get the byte at the specified index.                                                                            // 279
     * @param {number} i the index to use.                                                                             // 280
     * @return {number} a byte.                                                                                        // 281
     */                                                                                                                // 282
    byteAt: function(i) {                                                                                              // 283
        // see implementations                                                                                         // 284
    },                                                                                                                 // 285
    /**                                                                                                                // 286
     * Get the next number with a given byte size.                                                                     // 287
     * @param {number} size the number of bytes to read.                                                               // 288
     * @return {number} the corresponding number.                                                                      // 289
     */                                                                                                                // 290
    readInt: function(size) {                                                                                          // 291
        var result = 0,                                                                                                // 292
            i;                                                                                                         // 293
        this.checkOffset(size);                                                                                        // 294
        for (i = this.index + size - 1; i >= this.index; i--) {                                                        // 295
            result = (result << 8) + this.byteAt(i);                                                                   // 296
        }                                                                                                              // 297
        this.index += size;                                                                                            // 298
        return result;                                                                                                 // 299
    },                                                                                                                 // 300
    /**                                                                                                                // 301
     * Get the next string with a given byte size.                                                                     // 302
     * @param {number} size the number of bytes to read.                                                               // 303
     * @return {string} the corresponding string.                                                                      // 304
     */                                                                                                                // 305
    readString: function(size) {                                                                                       // 306
        return utils.transformTo("string", this.readData(size));                                                       // 307
    },                                                                                                                 // 308
    /**                                                                                                                // 309
     * Get raw data without conversion, <size> bytes.                                                                  // 310
     * @param {number} size the number of bytes to read.                                                               // 311
     * @return {Object} the raw data, implementation specific.                                                         // 312
     */                                                                                                                // 313
    readData: function(size) {                                                                                         // 314
        // see implementations                                                                                         // 315
    },                                                                                                                 // 316
    /**                                                                                                                // 317
     * Find the last occurence of a zip signature (4 bytes).                                                           // 318
     * @param {string} sig the signature to find.                                                                      // 319
     * @return {number} the index of the last occurence, -1 if not found.                                              // 320
     */                                                                                                                // 321
    lastIndexOfSignature: function(sig) {                                                                              // 322
        // see implementations                                                                                         // 323
    },                                                                                                                 // 324
    /**                                                                                                                // 325
     * Get the next date.                                                                                              // 326
     * @return {Date} the date.                                                                                        // 327
     */                                                                                                                // 328
    readDate: function() {                                                                                             // 329
        var dostime = this.readInt(4);                                                                                 // 330
        return new Date(                                                                                               // 331
        ((dostime >> 25) & 0x7f) + 1980, // year                                                                       // 332
        ((dostime >> 21) & 0x0f) - 1, // month                                                                         // 333
        (dostime >> 16) & 0x1f, // day                                                                                 // 334
        (dostime >> 11) & 0x1f, // hour                                                                                // 335
        (dostime >> 5) & 0x3f, // minute                                                                               // 336
        (dostime & 0x1f) << 1); // second                                                                              // 337
    }                                                                                                                  // 338
};                                                                                                                     // 339
module.exports = DataReader;                                                                                           // 340
                                                                                                                       // 341
},{"./utils":21}],6:[function(_dereq_,module,exports){                                                                 // 342
'use strict';                                                                                                          // 343
exports.base64 = false;                                                                                                // 344
exports.binary = false;                                                                                                // 345
exports.dir = false;                                                                                                   // 346
exports.createFolders = false;                                                                                         // 347
exports.date = null;                                                                                                   // 348
exports.compression = null;                                                                                            // 349
exports.compressionOptions = null;                                                                                     // 350
exports.comment = null;                                                                                                // 351
exports.unixPermissions = null;                                                                                        // 352
exports.dosPermissions = null;                                                                                         // 353
                                                                                                                       // 354
},{}],7:[function(_dereq_,module,exports){                                                                             // 355
'use strict';                                                                                                          // 356
var utils = _dereq_('./utils');                                                                                        // 357
                                                                                                                       // 358
/**                                                                                                                    // 359
 * @deprecated                                                                                                         // 360
 * This function will be removed in a future version without replacement.                                              // 361
 */                                                                                                                    // 362
exports.string2binary = function(str) {                                                                                // 363
    return utils.string2binary(str);                                                                                   // 364
};                                                                                                                     // 365
                                                                                                                       // 366
/**                                                                                                                    // 367
 * @deprecated                                                                                                         // 368
 * This function will be removed in a future version without replacement.                                              // 369
 */                                                                                                                    // 370
exports.string2Uint8Array = function(str) {                                                                            // 371
    return utils.transformTo("uint8array", str);                                                                       // 372
};                                                                                                                     // 373
                                                                                                                       // 374
/**                                                                                                                    // 375
 * @deprecated                                                                                                         // 376
 * This function will be removed in a future version without replacement.                                              // 377
 */                                                                                                                    // 378
exports.uint8Array2String = function(array) {                                                                          // 379
    return utils.transformTo("string", array);                                                                         // 380
};                                                                                                                     // 381
                                                                                                                       // 382
/**                                                                                                                    // 383
 * @deprecated                                                                                                         // 384
 * This function will be removed in a future version without replacement.                                              // 385
 */                                                                                                                    // 386
exports.string2Blob = function(str) {                                                                                  // 387
    var buffer = utils.transformTo("arraybuffer", str);                                                                // 388
    return utils.arrayBuffer2Blob(buffer);                                                                             // 389
};                                                                                                                     // 390
                                                                                                                       // 391
/**                                                                                                                    // 392
 * @deprecated                                                                                                         // 393
 * This function will be removed in a future version without replacement.                                              // 394
 */                                                                                                                    // 395
exports.arrayBuffer2Blob = function(buffer) {                                                                          // 396
    return utils.arrayBuffer2Blob(buffer);                                                                             // 397
};                                                                                                                     // 398
                                                                                                                       // 399
/**                                                                                                                    // 400
 * @deprecated                                                                                                         // 401
 * This function will be removed in a future version without replacement.                                              // 402
 */                                                                                                                    // 403
exports.transformTo = function(outputType, input) {                                                                    // 404
    return utils.transformTo(outputType, input);                                                                       // 405
};                                                                                                                     // 406
                                                                                                                       // 407
/**                                                                                                                    // 408
 * @deprecated                                                                                                         // 409
 * This function will be removed in a future version without replacement.                                              // 410
 */                                                                                                                    // 411
exports.getTypeOf = function(input) {                                                                                  // 412
    return utils.getTypeOf(input);                                                                                     // 413
};                                                                                                                     // 414
                                                                                                                       // 415
/**                                                                                                                    // 416
 * @deprecated                                                                                                         // 417
 * This function will be removed in a future version without replacement.                                              // 418
 */                                                                                                                    // 419
exports.checkSupport = function(type) {                                                                                // 420
    return utils.checkSupport(type);                                                                                   // 421
};                                                                                                                     // 422
                                                                                                                       // 423
/**                                                                                                                    // 424
 * @deprecated                                                                                                         // 425
 * This value will be removed in a future version without replacement.                                                 // 426
 */                                                                                                                    // 427
exports.MAX_VALUE_16BITS = utils.MAX_VALUE_16BITS;                                                                     // 428
                                                                                                                       // 429
/**                                                                                                                    // 430
 * @deprecated                                                                                                         // 431
 * This value will be removed in a future version without replacement.                                                 // 432
 */                                                                                                                    // 433
exports.MAX_VALUE_32BITS = utils.MAX_VALUE_32BITS;                                                                     // 434
                                                                                                                       // 435
                                                                                                                       // 436
/**                                                                                                                    // 437
 * @deprecated                                                                                                         // 438
 * This function will be removed in a future version without replacement.                                              // 439
 */                                                                                                                    // 440
exports.pretty = function(str) {                                                                                       // 441
    return utils.pretty(str);                                                                                          // 442
};                                                                                                                     // 443
                                                                                                                       // 444
/**                                                                                                                    // 445
 * @deprecated                                                                                                         // 446
 * This function will be removed in a future version without replacement.                                              // 447
 */                                                                                                                    // 448
exports.findCompression = function(compressionMethod) {                                                                // 449
    return utils.findCompression(compressionMethod);                                                                   // 450
};                                                                                                                     // 451
                                                                                                                       // 452
/**                                                                                                                    // 453
 * @deprecated                                                                                                         // 454
 * This function will be removed in a future version without replacement.                                              // 455
 */                                                                                                                    // 456
exports.isRegExp = function (object) {                                                                                 // 457
    return utils.isRegExp(object);                                                                                     // 458
};                                                                                                                     // 459
                                                                                                                       // 460
                                                                                                                       // 461
},{"./utils":21}],8:[function(_dereq_,module,exports){                                                                 // 462
'use strict';                                                                                                          // 463
var USE_TYPEDARRAY = (typeof Uint8Array !== 'undefined') && (typeof Uint16Array !== 'undefined') && (typeof Uint32Array !== 'undefined');
                                                                                                                       // 465
var pako = _dereq_("pako");                                                                                            // 466
exports.uncompressInputType = USE_TYPEDARRAY ? "uint8array" : "array";                                                 // 467
exports.compressInputType = USE_TYPEDARRAY ? "uint8array" : "array";                                                   // 468
                                                                                                                       // 469
exports.magic = "\x08\x00";                                                                                            // 470
exports.compress = function(input, compressionOptions) {                                                               // 471
    return pako.deflateRaw(input, {                                                                                    // 472
        level : compressionOptions.level || -1 // default compression                                                  // 473
    });                                                                                                                // 474
};                                                                                                                     // 475
exports.uncompress =  function(input) {                                                                                // 476
    return pako.inflateRaw(input);                                                                                     // 477
};                                                                                                                     // 478
                                                                                                                       // 479
},{"pako":24}],9:[function(_dereq_,module,exports){                                                                    // 480
'use strict';                                                                                                          // 481
                                                                                                                       // 482
var base64 = _dereq_('./base64');                                                                                      // 483
                                                                                                                       // 484
/**                                                                                                                    // 485
Usage:                                                                                                                 // 486
   zip = new JSZip();                                                                                                  // 487
   zip.file("hello.txt", "Hello, World!").file("tempfile", "nothing");                                                 // 488
   zip.folder("images").file("smile.gif", base64Data, {base64: true});                                                 // 489
   zip.file("Xmas.txt", "Ho ho ho !", {date : new Date("December 25, 2007 00:00:01")});                                // 490
   zip.remove("tempfile");                                                                                             // 491
                                                                                                                       // 492
   base64zip = zip.generate();                                                                                         // 493
                                                                                                                       // 494
**/                                                                                                                    // 495
                                                                                                                       // 496
/**                                                                                                                    // 497
 * Representation a of zip file in js                                                                                  // 498
 * @constructor                                                                                                        // 499
 * @param {String=|ArrayBuffer=|Uint8Array=} data the data to load, if any (optional).                                 // 500
 * @param {Object=} options the options for creating this objects (optional).                                          // 501
 */                                                                                                                    // 502
function JSZip(data, options) {                                                                                        // 503
    // if this constructor is used without `new`, it adds `new` before itself:                                         // 504
    if(!(this instanceof JSZip)) return new JSZip(data, options);                                                      // 505
                                                                                                                       // 506
    // object containing the files :                                                                                   // 507
    // {                                                                                                               // 508
    //   "folder/" : {...},                                                                                            // 509
    //   "folder/data.txt" : {...}                                                                                     // 510
    // }                                                                                                               // 511
    this.files = {};                                                                                                   // 512
                                                                                                                       // 513
    this.comment = null;                                                                                               // 514
                                                                                                                       // 515
    // Where we are in the hierarchy                                                                                   // 516
    this.root = "";                                                                                                    // 517
    if (data) {                                                                                                        // 518
        this.load(data, options);                                                                                      // 519
    }                                                                                                                  // 520
    this.clone = function() {                                                                                          // 521
        var newObj = new JSZip();                                                                                      // 522
        for (var i in this) {                                                                                          // 523
            if (typeof this[i] !== "function") {                                                                       // 524
                newObj[i] = this[i];                                                                                   // 525
            }                                                                                                          // 526
        }                                                                                                              // 527
        return newObj;                                                                                                 // 528
    };                                                                                                                 // 529
}                                                                                                                      // 530
JSZip.prototype = _dereq_('./object');                                                                                 // 531
JSZip.prototype.load = _dereq_('./load');                                                                              // 532
JSZip.support = _dereq_('./support');                                                                                  // 533
JSZip.defaults = _dereq_('./defaults');                                                                                // 534
                                                                                                                       // 535
/**                                                                                                                    // 536
 * @deprecated                                                                                                         // 537
 * This namespace will be removed in a future version without replacement.                                             // 538
 */                                                                                                                    // 539
JSZip.utils = _dereq_('./deprecatedPublicUtils');                                                                      // 540
                                                                                                                       // 541
JSZip.base64 = {                                                                                                       // 542
    /**                                                                                                                // 543
     * @deprecated                                                                                                     // 544
     * This method will be removed in a future version without replacement.                                            // 545
     */                                                                                                                // 546
    encode : function(input) {                                                                                         // 547
        return base64.encode(input);                                                                                   // 548
    },                                                                                                                 // 549
    /**                                                                                                                // 550
     * @deprecated                                                                                                     // 551
     * This method will be removed in a future version without replacement.                                            // 552
     */                                                                                                                // 553
    decode : function(input) {                                                                                         // 554
        return base64.decode(input);                                                                                   // 555
    }                                                                                                                  // 556
};                                                                                                                     // 557
JSZip.compressions = _dereq_('./compressions');                                                                        // 558
module.exports = JSZip;                                                                                                // 559
                                                                                                                       // 560
},{"./base64":1,"./compressions":3,"./defaults":6,"./deprecatedPublicUtils":7,"./load":10,"./object":13,"./support":17}],10:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 562
var base64 = _dereq_('./base64');                                                                                      // 563
var ZipEntries = _dereq_('./zipEntries');                                                                              // 564
module.exports = function(data, options) {                                                                             // 565
    var files, zipEntries, i, input;                                                                                   // 566
    options = options || {};                                                                                           // 567
    if (options.base64) {                                                                                              // 568
        data = base64.decode(data);                                                                                    // 569
    }                                                                                                                  // 570
                                                                                                                       // 571
    zipEntries = new ZipEntries(data, options);                                                                        // 572
    files = zipEntries.files;                                                                                          // 573
    for (i = 0; i < files.length; i++) {                                                                               // 574
        input = files[i];                                                                                              // 575
        this.file(input.fileName, input.decompressed, {                                                                // 576
            binary: true,                                                                                              // 577
            optimizedBinaryString: true,                                                                               // 578
            date: input.date,                                                                                          // 579
            dir: input.dir,                                                                                            // 580
            comment : input.fileComment.length ? input.fileComment : null,                                             // 581
            unixPermissions : input.unixPermissions,                                                                   // 582
            dosPermissions : input.dosPermissions,                                                                     // 583
            createFolders: options.createFolders                                                                       // 584
        });                                                                                                            // 585
    }                                                                                                                  // 586
    if (zipEntries.zipComment.length) {                                                                                // 587
        this.comment = zipEntries.zipComment;                                                                          // 588
    }                                                                                                                  // 589
                                                                                                                       // 590
    return this;                                                                                                       // 591
};                                                                                                                     // 592
                                                                                                                       // 593
},{"./base64":1,"./zipEntries":22}],11:[function(_dereq_,module,exports){                                              // 594
(function (Buffer){                                                                                                    // 595
'use strict';                                                                                                          // 596
module.exports = function(data, encoding){                                                                             // 597
    return new Buffer(data, encoding);                                                                                 // 598
};                                                                                                                     // 599
module.exports.test = function(b){                                                                                     // 600
    return Buffer.isBuffer(b);                                                                                         // 601
};                                                                                                                     // 602
                                                                                                                       // 603
}).call(this,(typeof Buffer !== "undefined" ? Buffer : undefined))                                                     // 604
},{}],12:[function(_dereq_,module,exports){                                                                            // 605
'use strict';                                                                                                          // 606
var Uint8ArrayReader = _dereq_('./uint8ArrayReader');                                                                  // 607
                                                                                                                       // 608
function NodeBufferReader(data) {                                                                                      // 609
    this.data = data;                                                                                                  // 610
    this.length = this.data.length;                                                                                    // 611
    this.index = 0;                                                                                                    // 612
}                                                                                                                      // 613
NodeBufferReader.prototype = new Uint8ArrayReader();                                                                   // 614
                                                                                                                       // 615
/**                                                                                                                    // 616
 * @see DataReader.readData                                                                                            // 617
 */                                                                                                                    // 618
NodeBufferReader.prototype.readData = function(size) {                                                                 // 619
    this.checkOffset(size);                                                                                            // 620
    var result = this.data.slice(this.index, this.index + size);                                                       // 621
    this.index += size;                                                                                                // 622
    return result;                                                                                                     // 623
};                                                                                                                     // 624
module.exports = NodeBufferReader;                                                                                     // 625
                                                                                                                       // 626
},{"./uint8ArrayReader":18}],13:[function(_dereq_,module,exports){                                                     // 627
'use strict';                                                                                                          // 628
var support = _dereq_('./support');                                                                                    // 629
var utils = _dereq_('./utils');                                                                                        // 630
var crc32 = _dereq_('./crc32');                                                                                        // 631
var signature = _dereq_('./signature');                                                                                // 632
var defaults = _dereq_('./defaults');                                                                                  // 633
var base64 = _dereq_('./base64');                                                                                      // 634
var compressions = _dereq_('./compressions');                                                                          // 635
var CompressedObject = _dereq_('./compressedObject');                                                                  // 636
var nodeBuffer = _dereq_('./nodeBuffer');                                                                              // 637
var utf8 = _dereq_('./utf8');                                                                                          // 638
var StringWriter = _dereq_('./stringWriter');                                                                          // 639
var Uint8ArrayWriter = _dereq_('./uint8ArrayWriter');                                                                  // 640
                                                                                                                       // 641
/**                                                                                                                    // 642
 * Returns the raw data of a ZipObject, decompress the content if necessary.                                           // 643
 * @param {ZipObject} file the file to use.                                                                            // 644
 * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.                                                            // 645
 */                                                                                                                    // 646
var getRawData = function(file) {                                                                                      // 647
    if (file._data instanceof CompressedObject) {                                                                      // 648
        file._data = file._data.getContent();                                                                          // 649
        file.options.binary = true;                                                                                    // 650
        file.options.base64 = false;                                                                                   // 651
                                                                                                                       // 652
        if (utils.getTypeOf(file._data) === "uint8array") {                                                            // 653
            var copy = file._data;                                                                                     // 654
            // when reading an arraybuffer, the CompressedObject mechanism will keep it and subarray() a Uint8Array.   // 655
            // if we request a file in the same format, we might get the same Uint8Array or its ArrayBuffer (the original zip file).
            file._data = new Uint8Array(copy.length);                                                                  // 657
            // with an empty Uint8Array, Opera fails with a "Offset larger than array size"                            // 658
            if (copy.length !== 0) {                                                                                   // 659
                file._data.set(copy, 0);                                                                               // 660
            }                                                                                                          // 661
        }                                                                                                              // 662
    }                                                                                                                  // 663
    return file._data;                                                                                                 // 664
};                                                                                                                     // 665
                                                                                                                       // 666
/**                                                                                                                    // 667
 * Returns the data of a ZipObject in a binary form. If the content is an unicode string, encode it.                   // 668
 * @param {ZipObject} file the file to use.                                                                            // 669
 * @return {String|ArrayBuffer|Uint8Array|Buffer} the data.                                                            // 670
 */                                                                                                                    // 671
var getBinaryData = function(file) {                                                                                   // 672
    var result = getRawData(file),                                                                                     // 673
        type = utils.getTypeOf(result);                                                                                // 674
    if (type === "string") {                                                                                           // 675
        if (!file.options.binary) {                                                                                    // 676
            // unicode text !                                                                                          // 677
            // unicode string => binary string is a painful process, check if we can avoid it.                         // 678
            if (support.nodebuffer) {                                                                                  // 679
                return nodeBuffer(result, "utf-8");                                                                    // 680
            }                                                                                                          // 681
        }                                                                                                              // 682
        return file.asBinary();                                                                                        // 683
    }                                                                                                                  // 684
    return result;                                                                                                     // 685
};                                                                                                                     // 686
                                                                                                                       // 687
/**                                                                                                                    // 688
 * Transform this._data into a string.                                                                                 // 689
 * @param {function} filter a function String -> String, applied if not null on the result.                            // 690
 * @return {String} the string representing this._data.                                                                // 691
 */                                                                                                                    // 692
var dataToString = function(asUTF8) {                                                                                  // 693
    var result = getRawData(this);                                                                                     // 694
    if (result === null || typeof result === "undefined") {                                                            // 695
        return "";                                                                                                     // 696
    }                                                                                                                  // 697
    // if the data is a base64 string, we decode it before checking the encoding !                                     // 698
    if (this.options.base64) {                                                                                         // 699
        result = base64.decode(result);                                                                                // 700
    }                                                                                                                  // 701
    if (asUTF8 && this.options.binary) {                                                                               // 702
        // JSZip.prototype.utf8decode supports arrays as input                                                         // 703
        // skip to array => string step, utf8decode will do it.                                                        // 704
        result = out.utf8decode(result);                                                                               // 705
    }                                                                                                                  // 706
    else {                                                                                                             // 707
        // no utf8 transformation, do the array => string step.                                                        // 708
        result = utils.transformTo("string", result);                                                                  // 709
    }                                                                                                                  // 710
                                                                                                                       // 711
    if (!asUTF8 && !this.options.binary) {                                                                             // 712
        result = utils.transformTo("string", out.utf8encode(result));                                                  // 713
    }                                                                                                                  // 714
    return result;                                                                                                     // 715
};                                                                                                                     // 716
/**                                                                                                                    // 717
 * A simple object representing a file in the zip file.                                                                // 718
 * @constructor                                                                                                        // 719
 * @param {string} name the name of the file                                                                           // 720
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data                                                         // 721
 * @param {Object} options the options of the file                                                                     // 722
 */                                                                                                                    // 723
var ZipObject = function(name, data, options) {                                                                        // 724
    this.name = name;                                                                                                  // 725
    this.dir = options.dir;                                                                                            // 726
    this.date = options.date;                                                                                          // 727
    this.comment = options.comment;                                                                                    // 728
    this.unixPermissions = options.unixPermissions;                                                                    // 729
    this.dosPermissions = options.dosPermissions;                                                                      // 730
                                                                                                                       // 731
    this._data = data;                                                                                                 // 732
    this.options = options;                                                                                            // 733
                                                                                                                       // 734
    /*                                                                                                                 // 735
     * This object contains initial values for dir and date.                                                           // 736
     * With them, we can check if the user changed the deprecated metadata in                                          // 737
     * `ZipObject#options` or not.                                                                                     // 738
     */                                                                                                                // 739
    this._initialMetadata = {                                                                                          // 740
      dir : options.dir,                                                                                               // 741
      date : options.date                                                                                              // 742
    };                                                                                                                 // 743
};                                                                                                                     // 744
                                                                                                                       // 745
ZipObject.prototype = {                                                                                                // 746
    /**                                                                                                                // 747
     * Return the content as UTF8 string.                                                                              // 748
     * @return {string} the UTF8 string.                                                                               // 749
     */                                                                                                                // 750
    asText: function() {                                                                                               // 751
        return dataToString.call(this, true);                                                                          // 752
    },                                                                                                                 // 753
    /**                                                                                                                // 754
     * Returns the binary content.                                                                                     // 755
     * @return {string} the content as binary.                                                                         // 756
     */                                                                                                                // 757
    asBinary: function() {                                                                                             // 758
        return dataToString.call(this, false);                                                                         // 759
    },                                                                                                                 // 760
    /**                                                                                                                // 761
     * Returns the content as a nodejs Buffer.                                                                         // 762
     * @return {Buffer} the content as a Buffer.                                                                       // 763
     */                                                                                                                // 764
    asNodeBuffer: function() {                                                                                         // 765
        var result = getBinaryData(this);                                                                              // 766
        return utils.transformTo("nodebuffer", result);                                                                // 767
    },                                                                                                                 // 768
    /**                                                                                                                // 769
     * Returns the content as an Uint8Array.                                                                           // 770
     * @return {Uint8Array} the content as an Uint8Array.                                                              // 771
     */                                                                                                                // 772
    asUint8Array: function() {                                                                                         // 773
        var result = getBinaryData(this);                                                                              // 774
        return utils.transformTo("uint8array", result);                                                                // 775
    },                                                                                                                 // 776
    /**                                                                                                                // 777
     * Returns the content as an ArrayBuffer.                                                                          // 778
     * @return {ArrayBuffer} the content as an ArrayBufer.                                                             // 779
     */                                                                                                                // 780
    asArrayBuffer: function() {                                                                                        // 781
        return this.asUint8Array().buffer;                                                                             // 782
    }                                                                                                                  // 783
};                                                                                                                     // 784
                                                                                                                       // 785
/**                                                                                                                    // 786
 * Transform an integer into a string in hexadecimal.                                                                  // 787
 * @private                                                                                                            // 788
 * @param {number} dec the number to convert.                                                                          // 789
 * @param {number} bytes the number of bytes to generate.                                                              // 790
 * @returns {string} the result.                                                                                       // 791
 */                                                                                                                    // 792
var decToHex = function(dec, bytes) {                                                                                  // 793
    var hex = "",                                                                                                      // 794
        i;                                                                                                             // 795
    for (i = 0; i < bytes; i++) {                                                                                      // 796
        hex += String.fromCharCode(dec & 0xff);                                                                        // 797
        dec = dec >>> 8;                                                                                               // 798
    }                                                                                                                  // 799
    return hex;                                                                                                        // 800
};                                                                                                                     // 801
                                                                                                                       // 802
/**                                                                                                                    // 803
 * Merge the objects passed as parameters into a new one.                                                              // 804
 * @private                                                                                                            // 805
 * @param {...Object} var_args All objects to merge.                                                                   // 806
 * @return {Object} a new object with the data of the others.                                                          // 807
 */                                                                                                                    // 808
var extend = function() {                                                                                              // 809
    var result = {}, i, attr;                                                                                          // 810
    for (i = 0; i < arguments.length; i++) { // arguments is not enumerable in some browsers                           // 811
        for (attr in arguments[i]) {                                                                                   // 812
            if (arguments[i].hasOwnProperty(attr) && typeof result[attr] === "undefined") {                            // 813
                result[attr] = arguments[i][attr];                                                                     // 814
            }                                                                                                          // 815
        }                                                                                                              // 816
    }                                                                                                                  // 817
    return result;                                                                                                     // 818
};                                                                                                                     // 819
                                                                                                                       // 820
/**                                                                                                                    // 821
 * Transforms the (incomplete) options from the user into the complete                                                 // 822
 * set of options to create a file.                                                                                    // 823
 * @private                                                                                                            // 824
 * @param {Object} o the options from the user.                                                                        // 825
 * @return {Object} the complete set of options.                                                                       // 826
 */                                                                                                                    // 827
var prepareFileAttrs = function(o) {                                                                                   // 828
    o = o || {};                                                                                                       // 829
    if (o.base64 === true && (o.binary === null || o.binary === undefined)) {                                          // 830
        o.binary = true;                                                                                               // 831
    }                                                                                                                  // 832
    o = extend(o, defaults);                                                                                           // 833
    o.date = o.date || new Date();                                                                                     // 834
    if (o.compression !== null) o.compression = o.compression.toUpperCase();                                           // 835
                                                                                                                       // 836
    return o;                                                                                                          // 837
};                                                                                                                     // 838
                                                                                                                       // 839
/**                                                                                                                    // 840
 * Add a file in the current folder.                                                                                   // 841
 * @private                                                                                                            // 842
 * @param {string} name the name of the file                                                                           // 843
 * @param {String|ArrayBuffer|Uint8Array|Buffer} data the data of the file                                             // 844
 * @param {Object} o the options of the file                                                                           // 845
 * @return {Object} the new file.                                                                                      // 846
 */                                                                                                                    // 847
var fileAdd = function(name, data, o) {                                                                                // 848
    // be sure sub folders exist                                                                                       // 849
    var dataType = utils.getTypeOf(data),                                                                              // 850
        parent;                                                                                                        // 851
                                                                                                                       // 852
    o = prepareFileAttrs(o);                                                                                           // 853
                                                                                                                       // 854
    if (typeof o.unixPermissions === "string") {                                                                       // 855
        o.unixPermissions = parseInt(o.unixPermissions, 8);                                                            // 856
    }                                                                                                                  // 857
                                                                                                                       // 858
    // UNX_IFDIR  0040000 see zipinfo.c                                                                                // 859
    if (o.unixPermissions && (o.unixPermissions & 0x4000)) {                                                           // 860
        o.dir = true;                                                                                                  // 861
    }                                                                                                                  // 862
    // Bit 4    Directory                                                                                              // 863
    if (o.dosPermissions && (o.dosPermissions & 0x0010)) {                                                             // 864
        o.dir = true;                                                                                                  // 865
    }                                                                                                                  // 866
                                                                                                                       // 867
    if (o.dir) {                                                                                                       // 868
        name = forceTrailingSlash(name);                                                                               // 869
    }                                                                                                                  // 870
                                                                                                                       // 871
    if (o.createFolders && (parent = parentFolder(name))) {                                                            // 872
        folderAdd.call(this, parent, true);                                                                            // 873
    }                                                                                                                  // 874
                                                                                                                       // 875
    if (o.dir || data === null || typeof data === "undefined") {                                                       // 876
        o.base64 = false;                                                                                              // 877
        o.binary = false;                                                                                              // 878
        data = null;                                                                                                   // 879
        dataType = null;                                                                                               // 880
    }                                                                                                                  // 881
    else if (dataType === "string") {                                                                                  // 882
        if (o.binary && !o.base64) {                                                                                   // 883
            // optimizedBinaryString == true means that the file has already been filtered with a 0xFF mask            // 884
            if (o.optimizedBinaryString !== true) {                                                                    // 885
                // this is a string, not in a base64 format.                                                           // 886
                // Be sure that this is a correct "binary string"                                                      // 887
                data = utils.string2binary(data);                                                                      // 888
            }                                                                                                          // 889
        }                                                                                                              // 890
    }                                                                                                                  // 891
    else { // arraybuffer, uint8array, ...                                                                             // 892
        o.base64 = false;                                                                                              // 893
        o.binary = true;                                                                                               // 894
                                                                                                                       // 895
        if (!dataType && !(data instanceof CompressedObject)) {                                                        // 896
            throw new Error("The data of '" + name + "' is in an unsupported format !");                               // 897
        }                                                                                                              // 898
                                                                                                                       // 899
        // special case : it's way easier to work with Uint8Array than with ArrayBuffer                                // 900
        if (dataType === "arraybuffer") {                                                                              // 901
            data = utils.transformTo("uint8array", data);                                                              // 902
        }                                                                                                              // 903
    }                                                                                                                  // 904
                                                                                                                       // 905
    var object = new ZipObject(name, data, o);                                                                         // 906
    this.files[name] = object;                                                                                         // 907
    return object;                                                                                                     // 908
};                                                                                                                     // 909
                                                                                                                       // 910
/**                                                                                                                    // 911
 * Find the parent folder of the path.                                                                                 // 912
 * @private                                                                                                            // 913
 * @param {string} path the path to use                                                                                // 914
 * @return {string} the parent folder, or ""                                                                           // 915
 */                                                                                                                    // 916
var parentFolder = function (path) {                                                                                   // 917
    if (path.slice(-1) == '/') {                                                                                       // 918
        path = path.substring(0, path.length - 1);                                                                     // 919
    }                                                                                                                  // 920
    var lastSlash = path.lastIndexOf('/');                                                                             // 921
    return (lastSlash > 0) ? path.substring(0, lastSlash) : "";                                                        // 922
};                                                                                                                     // 923
                                                                                                                       // 924
                                                                                                                       // 925
/**                                                                                                                    // 926
 * Returns the path with a slash at the end.                                                                           // 927
 * @private                                                                                                            // 928
 * @param {String} path the path to check.                                                                             // 929
 * @return {String} the path with a trailing slash.                                                                    // 930
 */                                                                                                                    // 931
var forceTrailingSlash = function(path) {                                                                              // 932
    // Check the name ends with a /                                                                                    // 933
    if (path.slice(-1) != "/") {                                                                                       // 934
        path += "/"; // IE doesn't like substr(-1)                                                                     // 935
    }                                                                                                                  // 936
    return path;                                                                                                       // 937
};                                                                                                                     // 938
/**                                                                                                                    // 939
 * Add a (sub) folder in the current folder.                                                                           // 940
 * @private                                                                                                            // 941
 * @param {string} name the folder's name                                                                              // 942
 * @param {boolean=} [createFolders] If true, automatically create sub                                                 // 943
 *  folders. Defaults to false.                                                                                        // 944
 * @return {Object} the new folder.                                                                                    // 945
 */                                                                                                                    // 946
var folderAdd = function(name, createFolders) {                                                                        // 947
    createFolders = (typeof createFolders !== 'undefined') ? createFolders : false;                                    // 948
                                                                                                                       // 949
    name = forceTrailingSlash(name);                                                                                   // 950
                                                                                                                       // 951
    // Does this folder already exist?                                                                                 // 952
    if (!this.files[name]) {                                                                                           // 953
        fileAdd.call(this, name, null, {                                                                               // 954
            dir: true,                                                                                                 // 955
            createFolders: createFolders                                                                               // 956
        });                                                                                                            // 957
    }                                                                                                                  // 958
    return this.files[name];                                                                                           // 959
};                                                                                                                     // 960
                                                                                                                       // 961
/**                                                                                                                    // 962
 * Generate a JSZip.CompressedObject for a given zipOject.                                                             // 963
 * @param {ZipObject} file the object to read.                                                                         // 964
 * @param {JSZip.compression} compression the compression to use.                                                      // 965
 * @param {Object} compressionOptions the options to use when compressing.                                             // 966
 * @return {JSZip.CompressedObject} the compressed result.                                                             // 967
 */                                                                                                                    // 968
var generateCompressedObjectFrom = function(file, compression, compressionOptions) {                                   // 969
    var result = new CompressedObject(),                                                                               // 970
        content;                                                                                                       // 971
                                                                                                                       // 972
    // the data has not been decompressed, we might reuse things !                                                     // 973
    if (file._data instanceof CompressedObject) {                                                                      // 974
        result.uncompressedSize = file._data.uncompressedSize;                                                         // 975
        result.crc32 = file._data.crc32;                                                                               // 976
                                                                                                                       // 977
        if (result.uncompressedSize === 0 || file.dir) {                                                               // 978
            compression = compressions['STORE'];                                                                       // 979
            result.compressedContent = "";                                                                             // 980
            result.crc32 = 0;                                                                                          // 981
        }                                                                                                              // 982
        else if (file._data.compressionMethod === compression.magic) {                                                 // 983
            result.compressedContent = file._data.getCompressedContent();                                              // 984
        }                                                                                                              // 985
        else {                                                                                                         // 986
            content = file._data.getContent();                                                                         // 987
            // need to decompress / recompress                                                                         // 988
            result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
        }                                                                                                              // 990
    }                                                                                                                  // 991
    else {                                                                                                             // 992
        // have uncompressed data                                                                                      // 993
        content = getBinaryData(file);                                                                                 // 994
        if (!content || content.length === 0 || file.dir) {                                                            // 995
            compression = compressions['STORE'];                                                                       // 996
            content = "";                                                                                              // 997
        }                                                                                                              // 998
        result.uncompressedSize = content.length;                                                                      // 999
        result.crc32 = crc32(content);                                                                                 // 1000
        result.compressedContent = compression.compress(utils.transformTo(compression.compressInputType, content), compressionOptions);
    }                                                                                                                  // 1002
                                                                                                                       // 1003
    result.compressedSize = result.compressedContent.length;                                                           // 1004
    result.compressionMethod = compression.magic;                                                                      // 1005
                                                                                                                       // 1006
    return result;                                                                                                     // 1007
};                                                                                                                     // 1008
                                                                                                                       // 1009
                                                                                                                       // 1010
                                                                                                                       // 1011
                                                                                                                       // 1012
/**                                                                                                                    // 1013
 * Generate the UNIX part of the external file attributes.                                                             // 1014
 * @param {Object} unixPermissions the unix permissions or null.                                                       // 1015
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.                                           // 1016
 * @return {Number} a 32 bit integer.                                                                                  // 1017
 *                                                                                                                     // 1018
 * adapted from http://unix.stackexchange.com/questions/14705/the-zip-formats-external-file-attribute :                // 1019
 *                                                                                                                     // 1020
 * TTTTsstrwxrwxrwx0000000000ADVSHR                                                                                    // 1021
 * ^^^^____________________________ file type, see zipinfo.c (UNX_*)                                                   // 1022
 *     ^^^_________________________ setuid, setgid, sticky                                                             // 1023
 *        ^^^^^^^^^________________ permissions                                                                        // 1024
 *                 ^^^^^^^^^^______ not used ?                                                                         // 1025
 *                           ^^^^^^ DOS attribute bits : Archive, Directory, Volume label, System file, Hidden, Read only
 */                                                                                                                    // 1027
var generateUnixExternalFileAttr = function (unixPermissions, isDir) {                                                 // 1028
                                                                                                                       // 1029
    var result = unixPermissions;                                                                                      // 1030
    if (!unixPermissions) {                                                                                            // 1031
        // I can't use octal values in strict mode, hence the hexa.                                                    // 1032
        //  040775 => 0x41fd                                                                                           // 1033
        // 0100664 => 0x81b4                                                                                           // 1034
        result = isDir ? 0x41fd : 0x81b4;                                                                              // 1035
    }                                                                                                                  // 1036
                                                                                                                       // 1037
    return (result & 0xFFFF) << 16;                                                                                    // 1038
};                                                                                                                     // 1039
                                                                                                                       // 1040
/**                                                                                                                    // 1041
 * Generate the DOS part of the external file attributes.                                                              // 1042
 * @param {Object} dosPermissions the dos permissions or null.                                                         // 1043
 * @param {Boolean} isDir true if the entry is a directory, false otherwise.                                           // 1044
 * @return {Number} a 32 bit integer.                                                                                  // 1045
 *                                                                                                                     // 1046
 * Bit 0     Read-Only                                                                                                 // 1047
 * Bit 1     Hidden                                                                                                    // 1048
 * Bit 2     System                                                                                                    // 1049
 * Bit 3     Volume Label                                                                                              // 1050
 * Bit 4     Directory                                                                                                 // 1051
 * Bit 5     Archive                                                                                                   // 1052
 */                                                                                                                    // 1053
var generateDosExternalFileAttr = function (dosPermissions, isDir) {                                                   // 1054
                                                                                                                       // 1055
    // the dir flag is already set for compatibility                                                                   // 1056
                                                                                                                       // 1057
    return (dosPermissions || 0)  & 0x3F;                                                                              // 1058
};                                                                                                                     // 1059
                                                                                                                       // 1060
/**                                                                                                                    // 1061
 * Generate the various parts used in the construction of the final zip file.                                          // 1062
 * @param {string} name the file name.                                                                                 // 1063
 * @param {ZipObject} file the file content.                                                                           // 1064
 * @param {JSZip.CompressedObject} compressedObject the compressed object.                                             // 1065
 * @param {number} offset the current offset from the start of the zip file.                                           // 1066
 * @param {String} platform let's pretend we are this platform (change platform dependents fields)                     // 1067
 * @return {object} the zip parts.                                                                                     // 1068
 */                                                                                                                    // 1069
var generateZipParts = function(name, file, compressedObject, offset, platform) {                                      // 1070
    var data = compressedObject.compressedContent,                                                                     // 1071
        utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),                                  // 1072
        comment = file.comment || "",                                                                                  // 1073
        utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),                                     // 1074
        useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,                                           // 1075
        useUTF8ForComment = utfEncodedComment.length !== comment.length,                                               // 1076
        o = file.options,                                                                                              // 1077
        dosTime,                                                                                                       // 1078
        dosDate,                                                                                                       // 1079
        extraFields = "",                                                                                              // 1080
        unicodePathExtraField = "",                                                                                    // 1081
        unicodeCommentExtraField = "",                                                                                 // 1082
        dir, date;                                                                                                     // 1083
                                                                                                                       // 1084
                                                                                                                       // 1085
    // handle the deprecated options.dir                                                                               // 1086
    if (file._initialMetadata.dir !== file.dir) {                                                                      // 1087
        dir = file.dir;                                                                                                // 1088
    } else {                                                                                                           // 1089
        dir = o.dir;                                                                                                   // 1090
    }                                                                                                                  // 1091
                                                                                                                       // 1092
    // handle the deprecated options.date                                                                              // 1093
    if(file._initialMetadata.date !== file.date) {                                                                     // 1094
        date = file.date;                                                                                              // 1095
    } else {                                                                                                           // 1096
        date = o.date;                                                                                                 // 1097
    }                                                                                                                  // 1098
                                                                                                                       // 1099
    var extFileAttr = 0;                                                                                               // 1100
    var versionMadeBy = 0;                                                                                             // 1101
    if (dir) {                                                                                                         // 1102
        // dos or unix, we set the dos dir flag                                                                        // 1103
        extFileAttr |= 0x00010;                                                                                        // 1104
    }                                                                                                                  // 1105
    if(platform === "UNIX") {                                                                                          // 1106
        versionMadeBy = 0x031E; // UNIX, version 3.0                                                                   // 1107
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);                                        // 1108
    } else { // DOS or other, fallback to DOS                                                                          // 1109
        versionMadeBy = 0x0014; // DOS, version 2.0                                                                    // 1110
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);                                          // 1111
    }                                                                                                                  // 1112
                                                                                                                       // 1113
    // date                                                                                                            // 1114
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/52/13.html                                                     // 1115
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/65/16.html                                                     // 1116
    // @see http://www.delorie.com/djgpp/doc/rbinter/it/66/16.html                                                     // 1117
                                                                                                                       // 1118
    dosTime = date.getHours();                                                                                         // 1119
    dosTime = dosTime << 6;                                                                                            // 1120
    dosTime = dosTime | date.getMinutes();                                                                             // 1121
    dosTime = dosTime << 5;                                                                                            // 1122
    dosTime = dosTime | date.getSeconds() / 2;                                                                         // 1123
                                                                                                                       // 1124
    dosDate = date.getFullYear() - 1980;                                                                               // 1125
    dosDate = dosDate << 4;                                                                                            // 1126
    dosDate = dosDate | (date.getMonth() + 1);                                                                         // 1127
    dosDate = dosDate << 5;                                                                                            // 1128
    dosDate = dosDate | date.getDate();                                                                                // 1129
                                                                                                                       // 1130
    if (useUTF8ForFileName) {                                                                                          // 1131
        // set the unicode path extra field. unzip needs at least one extra                                            // 1132
        // field to correctly handle unicode path, so using the path is as good                                        // 1133
        // as any other information. This could improve the situation with                                             // 1134
        // other archive managers too.                                                                                 // 1135
        // This field is usually used without the utf8 flag, with a non                                                // 1136
        // unicode path in the header (winrar, winzip). This helps (a bit)                                             // 1137
        // with the messy Windows' default compressed folders feature but                                              // 1138
        // breaks on p7zip which doesn't seek the unicode path extra field.                                            // 1139
        // So for now, UTF-8 everywhere !                                                                              // 1140
        unicodePathExtraField =                                                                                        // 1141
            // Version                                                                                                 // 1142
            decToHex(1, 1) +                                                                                           // 1143
            // NameCRC32                                                                                               // 1144
            decToHex(crc32(utfEncodedFileName), 4) +                                                                   // 1145
            // UnicodeName                                                                                             // 1146
            utfEncodedFileName;                                                                                        // 1147
                                                                                                                       // 1148
        extraFields +=                                                                                                 // 1149
            // Info-ZIP Unicode Path Extra Field                                                                       // 1150
            "\x75\x70" +                                                                                               // 1151
            // size                                                                                                    // 1152
            decToHex(unicodePathExtraField.length, 2) +                                                                // 1153
            // content                                                                                                 // 1154
            unicodePathExtraField;                                                                                     // 1155
    }                                                                                                                  // 1156
                                                                                                                       // 1157
    if(useUTF8ForComment) {                                                                                            // 1158
                                                                                                                       // 1159
        unicodeCommentExtraField =                                                                                     // 1160
            // Version                                                                                                 // 1161
            decToHex(1, 1) +                                                                                           // 1162
            // CommentCRC32                                                                                            // 1163
            decToHex(this.crc32(utfEncodedComment), 4) +                                                               // 1164
            // UnicodeName                                                                                             // 1165
            utfEncodedComment;                                                                                         // 1166
                                                                                                                       // 1167
        extraFields +=                                                                                                 // 1168
            // Info-ZIP Unicode Path Extra Field                                                                       // 1169
            "\x75\x63" +                                                                                               // 1170
            // size                                                                                                    // 1171
            decToHex(unicodeCommentExtraField.length, 2) +                                                             // 1172
            // content                                                                                                 // 1173
            unicodeCommentExtraField;                                                                                  // 1174
    }                                                                                                                  // 1175
                                                                                                                       // 1176
    var header = "";                                                                                                   // 1177
                                                                                                                       // 1178
    // version needed to extract                                                                                       // 1179
    header += "\x0A\x00";                                                                                              // 1180
    // general purpose bit flag                                                                                        // 1181
    // set bit 11 if utf8                                                                                              // 1182
    header += (useUTF8ForFileName || useUTF8ForComment) ? "\x00\x08" : "\x00\x00";                                     // 1183
    // compression method                                                                                              // 1184
    header += compressedObject.compressionMethod;                                                                      // 1185
    // last mod file time                                                                                              // 1186
    header += decToHex(dosTime, 2);                                                                                    // 1187
    // last mod file date                                                                                              // 1188
    header += decToHex(dosDate, 2);                                                                                    // 1189
    // crc-32                                                                                                          // 1190
    header += decToHex(compressedObject.crc32, 4);                                                                     // 1191
    // compressed size                                                                                                 // 1192
    header += decToHex(compressedObject.compressedSize, 4);                                                            // 1193
    // uncompressed size                                                                                               // 1194
    header += decToHex(compressedObject.uncompressedSize, 4);                                                          // 1195
    // file name length                                                                                                // 1196
    header += decToHex(utfEncodedFileName.length, 2);                                                                  // 1197
    // extra field length                                                                                              // 1198
    header += decToHex(extraFields.length, 2);                                                                         // 1199
                                                                                                                       // 1200
                                                                                                                       // 1201
    var fileRecord = signature.LOCAL_FILE_HEADER + header + utfEncodedFileName + extraFields;                          // 1202
                                                                                                                       // 1203
    var dirRecord = signature.CENTRAL_FILE_HEADER +                                                                    // 1204
    // version made by (00: DOS)                                                                                       // 1205
    decToHex(versionMadeBy, 2) +                                                                                       // 1206
    // file header (common to file and central directory)                                                              // 1207
    header +                                                                                                           // 1208
    // file comment length                                                                                             // 1209
    decToHex(utfEncodedComment.length, 2) +                                                                            // 1210
    // disk number start                                                                                               // 1211
    "\x00\x00" +                                                                                                       // 1212
    // internal file attributes TODO                                                                                   // 1213
    "\x00\x00" +                                                                                                       // 1214
    // external file attributes                                                                                        // 1215
    decToHex(extFileAttr, 4) +                                                                                         // 1216
    // relative offset of local header                                                                                 // 1217
    decToHex(offset, 4) +                                                                                              // 1218
    // file name                                                                                                       // 1219
    utfEncodedFileName +                                                                                               // 1220
    // extra field                                                                                                     // 1221
    extraFields +                                                                                                      // 1222
    // file comment                                                                                                    // 1223
    utfEncodedComment;                                                                                                 // 1224
                                                                                                                       // 1225
    return {                                                                                                           // 1226
        fileRecord: fileRecord,                                                                                        // 1227
        dirRecord: dirRecord,                                                                                          // 1228
        compressedObject: compressedObject                                                                             // 1229
    };                                                                                                                 // 1230
};                                                                                                                     // 1231
                                                                                                                       // 1232
                                                                                                                       // 1233
// return the actual prototype of JSZip                                                                                // 1234
var out = {                                                                                                            // 1235
    /**                                                                                                                // 1236
     * Read an existing zip and merge the data in the current JSZip object.                                            // 1237
     * The implementation is in jszip-load.js, don't forget to include it.                                             // 1238
     * @param {String|ArrayBuffer|Uint8Array|Buffer} stream  The stream to load                                        // 1239
     * @param {Object} options Options for loading the stream.                                                         // 1240
     *  options.base64 : is the stream in base64 ? default : false                                                     // 1241
     * @return {JSZip} the current JSZip object                                                                        // 1242
     */                                                                                                                // 1243
    load: function(stream, options) {                                                                                  // 1244
        throw new Error("Load method is not defined. Is the file jszip-load.js included ?");                           // 1245
    },                                                                                                                 // 1246
                                                                                                                       // 1247
    /**                                                                                                                // 1248
     * Filter nested files/folders with the specified function.                                                        // 1249
     * @param {Function} search the predicate to use :                                                                 // 1250
     * function (relativePath, file) {...}                                                                             // 1251
     * It takes 2 arguments : the relative path and the file.                                                          // 1252
     * @return {Array} An array of matching elements.                                                                  // 1253
     */                                                                                                                // 1254
    filter: function(search) {                                                                                         // 1255
        var result = [],                                                                                               // 1256
            filename, relativePath, file, fileClone;                                                                   // 1257
        for (filename in this.files) {                                                                                 // 1258
            if (!this.files.hasOwnProperty(filename)) {                                                                // 1259
                continue;                                                                                              // 1260
            }                                                                                                          // 1261
            file = this.files[filename];                                                                               // 1262
            // return a new object, don't let the user mess with our internal objects :)                               // 1263
            fileClone = new ZipObject(file.name, file._data, extend(file.options));                                    // 1264
            relativePath = filename.slice(this.root.length, filename.length);                                          // 1265
            if (filename.slice(0, this.root.length) === this.root && // the file is in the current root                // 1266
            search(relativePath, fileClone)) { // and the file matches the function                                    // 1267
                result.push(fileClone);                                                                                // 1268
            }                                                                                                          // 1269
        }                                                                                                              // 1270
        return result;                                                                                                 // 1271
    },                                                                                                                 // 1272
                                                                                                                       // 1273
    /**                                                                                                                // 1274
     * Add a file to the zip file, or search a file.                                                                   // 1275
     * @param   {string|RegExp} name The name of the file to add (if data is defined),                                 // 1276
     * the name of the file to find (if no data) or a regex to match files.                                            // 1277
     * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded               // 1278
     * @param   {Object} o     File options                                                                            // 1279
     * @return  {JSZip|Object|Array} this JSZip object (when adding a file),                                           // 1280
     * a file (when searching by string) or an array of files (when searching by regex).                               // 1281
     */                                                                                                                // 1282
    file: function(name, data, o) {                                                                                    // 1283
        if (arguments.length === 1) {                                                                                  // 1284
            if (utils.isRegExp(name)) {                                                                                // 1285
                var regexp = name;                                                                                     // 1286
                return this.filter(function(relativePath, file) {                                                      // 1287
                    return !file.dir && regexp.test(relativePath);                                                     // 1288
                });                                                                                                    // 1289
            }                                                                                                          // 1290
            else { // text                                                                                             // 1291
                return this.filter(function(relativePath, file) {                                                      // 1292
                    return !file.dir && relativePath === name;                                                         // 1293
                })[0] || null;                                                                                         // 1294
            }                                                                                                          // 1295
        }                                                                                                              // 1296
        else { // more than one argument : we have data !                                                              // 1297
            name = this.root + name;                                                                                   // 1298
            fileAdd.call(this, name, data, o);                                                                         // 1299
        }                                                                                                              // 1300
        return this;                                                                                                   // 1301
    },                                                                                                                 // 1302
                                                                                                                       // 1303
    /**                                                                                                                // 1304
     * Add a directory to the zip file, or search.                                                                     // 1305
     * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.                    // 1306
     * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.         // 1307
     */                                                                                                                // 1308
    folder: function(arg) {                                                                                            // 1309
        if (!arg) {                                                                                                    // 1310
            return this;                                                                                               // 1311
        }                                                                                                              // 1312
                                                                                                                       // 1313
        if (utils.isRegExp(arg)) {                                                                                     // 1314
            return this.filter(function(relativePath, file) {                                                          // 1315
                return file.dir && arg.test(relativePath);                                                             // 1316
            });                                                                                                        // 1317
        }                                                                                                              // 1318
                                                                                                                       // 1319
        // else, name is a new folder                                                                                  // 1320
        var name = this.root + arg;                                                                                    // 1321
        var newFolder = folderAdd.call(this, name);                                                                    // 1322
                                                                                                                       // 1323
        // Allow chaining by returning a new object with this folder as the root                                       // 1324
        var ret = this.clone();                                                                                        // 1325
        ret.root = newFolder.name;                                                                                     // 1326
        return ret;                                                                                                    // 1327
    },                                                                                                                 // 1328
                                                                                                                       // 1329
    /**                                                                                                                // 1330
     * Delete a file, or a directory and all sub-files, from the zip                                                   // 1331
     * @param {string} name the name of the file to delete                                                             // 1332
     * @return {JSZip} this JSZip object                                                                               // 1333
     */                                                                                                                // 1334
    remove: function(name) {                                                                                           // 1335
        name = this.root + name;                                                                                       // 1336
        var file = this.files[name];                                                                                   // 1337
        if (!file) {                                                                                                   // 1338
            // Look for any folders                                                                                    // 1339
            if (name.slice(-1) != "/") {                                                                               // 1340
                name += "/";                                                                                           // 1341
            }                                                                                                          // 1342
            file = this.files[name];                                                                                   // 1343
        }                                                                                                              // 1344
                                                                                                                       // 1345
        if (file && !file.dir) {                                                                                       // 1346
            // file                                                                                                    // 1347
            delete this.files[name];                                                                                   // 1348
        } else {                                                                                                       // 1349
            // maybe a folder, delete recursively                                                                      // 1350
            var kids = this.filter(function(relativePath, file) {                                                      // 1351
                return file.name.slice(0, name.length) === name;                                                       // 1352
            });                                                                                                        // 1353
            for (var i = 0; i < kids.length; i++) {                                                                    // 1354
                delete this.files[kids[i].name];                                                                       // 1355
            }                                                                                                          // 1356
        }                                                                                                              // 1357
                                                                                                                       // 1358
        return this;                                                                                                   // 1359
    },                                                                                                                 // 1360
                                                                                                                       // 1361
    /**                                                                                                                // 1362
     * Generate the complete zip file                                                                                  // 1363
     * @param {Object} options the options to generate the zip file :                                                  // 1364
     * - base64, (deprecated, use type instead) true to generate base64.                                               // 1365
     * - compression, "STORE" by default.                                                                              // 1366
     * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.                        // 1367
     * @return {String|Uint8Array|ArrayBuffer|Buffer|Blob} the zip file                                                // 1368
     */                                                                                                                // 1369
    generate: function(options) {                                                                                      // 1370
        options = extend(options || {}, {                                                                              // 1371
            base64: true,                                                                                              // 1372
            compression: "STORE",                                                                                      // 1373
            compressionOptions : null,                                                                                 // 1374
            type: "base64",                                                                                            // 1375
            platform: "DOS",                                                                                           // 1376
            comment: null,                                                                                             // 1377
            mimeType: 'application/zip'                                                                                // 1378
        });                                                                                                            // 1379
                                                                                                                       // 1380
        utils.checkSupport(options.type);                                                                              // 1381
                                                                                                                       // 1382
        // accept nodejs `process.platform`                                                                            // 1383
        if(                                                                                                            // 1384
          options.platform === 'darwin' ||                                                                             // 1385
          options.platform === 'freebsd' ||                                                                            // 1386
          options.platform === 'linux' ||                                                                              // 1387
          options.platform === 'sunos'                                                                                 // 1388
        ) {                                                                                                            // 1389
          options.platform = "UNIX";                                                                                   // 1390
        }                                                                                                              // 1391
        if (options.platform === 'win32') {                                                                            // 1392
          options.platform = "DOS";                                                                                    // 1393
        }                                                                                                              // 1394
                                                                                                                       // 1395
        var zipData = [],                                                                                              // 1396
            localDirLength = 0,                                                                                        // 1397
            centralDirLength = 0,                                                                                      // 1398
            writer, i,                                                                                                 // 1399
            utfEncodedComment = utils.transformTo("string", this.utf8encode(options.comment || this.comment || ""));   // 1400
                                                                                                                       // 1401
        // first, generate all the zip parts.                                                                          // 1402
        for (var name in this.files) {                                                                                 // 1403
            if (!this.files.hasOwnProperty(name)) {                                                                    // 1404
                continue;                                                                                              // 1405
            }                                                                                                          // 1406
            var file = this.files[name];                                                                               // 1407
                                                                                                                       // 1408
            var compressionName = file.options.compression || options.compression.toUpperCase();                       // 1409
            var compression = compressions[compressionName];                                                           // 1410
            if (!compression) {                                                                                        // 1411
                throw new Error(compressionName + " is not a valid compression method !");                             // 1412
            }                                                                                                          // 1413
            var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};              // 1414
                                                                                                                       // 1415
            var compressedObject = generateCompressedObjectFrom.call(this, file, compression, compressionOptions);     // 1416
                                                                                                                       // 1417
            var zipPart = generateZipParts.call(this, name, file, compressedObject, localDirLength, options.platform); // 1418
            localDirLength += zipPart.fileRecord.length + compressedObject.compressedSize;                             // 1419
            centralDirLength += zipPart.dirRecord.length;                                                              // 1420
            zipData.push(zipPart);                                                                                     // 1421
        }                                                                                                              // 1422
                                                                                                                       // 1423
        var dirEnd = "";                                                                                               // 1424
                                                                                                                       // 1425
        // end of central dir signature                                                                                // 1426
        dirEnd = signature.CENTRAL_DIRECTORY_END +                                                                     // 1427
        // number of this disk                                                                                         // 1428
        "\x00\x00" +                                                                                                   // 1429
        // number of the disk with the start of the central directory                                                  // 1430
        "\x00\x00" +                                                                                                   // 1431
        // total number of entries in the central directory on this disk                                               // 1432
        decToHex(zipData.length, 2) +                                                                                  // 1433
        // total number of entries in the central directory                                                            // 1434
        decToHex(zipData.length, 2) +                                                                                  // 1435
        // size of the central directory   4 bytes                                                                     // 1436
        decToHex(centralDirLength, 4) +                                                                                // 1437
        // offset of start of central directory with respect to the starting disk number                               // 1438
        decToHex(localDirLength, 4) +                                                                                  // 1439
        // .ZIP file comment length                                                                                    // 1440
        decToHex(utfEncodedComment.length, 2) +                                                                        // 1441
        // .ZIP file comment                                                                                           // 1442
        utfEncodedComment;                                                                                             // 1443
                                                                                                                       // 1444
                                                                                                                       // 1445
        // we have all the parts (and the total length)                                                                // 1446
        // time to create a writer !                                                                                   // 1447
        var typeName = options.type.toLowerCase();                                                                     // 1448
        if(typeName==="uint8array"||typeName==="arraybuffer"||typeName==="blob"||typeName==="nodebuffer") {            // 1449
            writer = new Uint8ArrayWriter(localDirLength + centralDirLength + dirEnd.length);                          // 1450
        }else{                                                                                                         // 1451
            writer = new StringWriter(localDirLength + centralDirLength + dirEnd.length);                              // 1452
        }                                                                                                              // 1453
                                                                                                                       // 1454
        for (i = 0; i < zipData.length; i++) {                                                                         // 1455
            writer.append(zipData[i].fileRecord);                                                                      // 1456
            writer.append(zipData[i].compressedObject.compressedContent);                                              // 1457
        }                                                                                                              // 1458
        for (i = 0; i < zipData.length; i++) {                                                                         // 1459
            writer.append(zipData[i].dirRecord);                                                                       // 1460
        }                                                                                                              // 1461
                                                                                                                       // 1462
        writer.append(dirEnd);                                                                                         // 1463
                                                                                                                       // 1464
        var zip = writer.finalize();                                                                                   // 1465
                                                                                                                       // 1466
                                                                                                                       // 1467
                                                                                                                       // 1468
        switch(options.type.toLowerCase()) {                                                                           // 1469
            // case "zip is an Uint8Array"                                                                             // 1470
            case "uint8array" :                                                                                        // 1471
            case "arraybuffer" :                                                                                       // 1472
            case "nodebuffer" :                                                                                        // 1473
               return utils.transformTo(options.type.toLowerCase(), zip);                                              // 1474
            case "blob" :                                                                                              // 1475
               return utils.arrayBuffer2Blob(utils.transformTo("arraybuffer", zip), options.mimeType);                 // 1476
            // case "zip is a string"                                                                                  // 1477
            case "base64" :                                                                                            // 1478
               return (options.base64) ? base64.encode(zip) : zip;                                                     // 1479
            default : // case "string" :                                                                               // 1480
               return zip;                                                                                             // 1481
         }                                                                                                             // 1482
                                                                                                                       // 1483
    },                                                                                                                 // 1484
                                                                                                                       // 1485
    /**                                                                                                                // 1486
     * @deprecated                                                                                                     // 1487
     * This method will be removed in a future version without replacement.                                            // 1488
     */                                                                                                                // 1489
    crc32: function (input, crc) {                                                                                     // 1490
        return crc32(input, crc);                                                                                      // 1491
    },                                                                                                                 // 1492
                                                                                                                       // 1493
    /**                                                                                                                // 1494
     * @deprecated                                                                                                     // 1495
     * This method will be removed in a future version without replacement.                                            // 1496
     */                                                                                                                // 1497
    utf8encode: function (string) {                                                                                    // 1498
        return utils.transformTo("string", utf8.utf8encode(string));                                                   // 1499
    },                                                                                                                 // 1500
                                                                                                                       // 1501
    /**                                                                                                                // 1502
     * @deprecated                                                                                                     // 1503
     * This method will be removed in a future version without replacement.                                            // 1504
     */                                                                                                                // 1505
    utf8decode: function (input) {                                                                                     // 1506
        return utf8.utf8decode(input);                                                                                 // 1507
    }                                                                                                                  // 1508
};                                                                                                                     // 1509
module.exports = out;                                                                                                  // 1510
                                                                                                                       // 1511
},{"./base64":1,"./compressedObject":2,"./compressions":3,"./crc32":4,"./defaults":6,"./nodeBuffer":11,"./signature":14,"./stringWriter":16,"./support":17,"./uint8ArrayWriter":19,"./utf8":20,"./utils":21}],14:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 1513
exports.LOCAL_FILE_HEADER = "PK\x03\x04";                                                                              // 1514
exports.CENTRAL_FILE_HEADER = "PK\x01\x02";                                                                            // 1515
exports.CENTRAL_DIRECTORY_END = "PK\x05\x06";                                                                          // 1516
exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x06\x07";                                                                // 1517
exports.ZIP64_CENTRAL_DIRECTORY_END = "PK\x06\x06";                                                                    // 1518
exports.DATA_DESCRIPTOR = "PK\x07\x08";                                                                                // 1519
                                                                                                                       // 1520
},{}],15:[function(_dereq_,module,exports){                                                                            // 1521
'use strict';                                                                                                          // 1522
var DataReader = _dereq_('./dataReader');                                                                              // 1523
var utils = _dereq_('./utils');                                                                                        // 1524
                                                                                                                       // 1525
function StringReader(data, optimizedBinaryString) {                                                                   // 1526
    this.data = data;                                                                                                  // 1527
    if (!optimizedBinaryString) {                                                                                      // 1528
        this.data = utils.string2binary(this.data);                                                                    // 1529
    }                                                                                                                  // 1530
    this.length = this.data.length;                                                                                    // 1531
    this.index = 0;                                                                                                    // 1532
}                                                                                                                      // 1533
StringReader.prototype = new DataReader();                                                                             // 1534
/**                                                                                                                    // 1535
 * @see DataReader.byteAt                                                                                              // 1536
 */                                                                                                                    // 1537
StringReader.prototype.byteAt = function(i) {                                                                          // 1538
    return this.data.charCodeAt(i);                                                                                    // 1539
};                                                                                                                     // 1540
/**                                                                                                                    // 1541
 * @see DataReader.lastIndexOfSignature                                                                                // 1542
 */                                                                                                                    // 1543
StringReader.prototype.lastIndexOfSignature = function(sig) {                                                          // 1544
    return this.data.lastIndexOf(sig);                                                                                 // 1545
};                                                                                                                     // 1546
/**                                                                                                                    // 1547
 * @see DataReader.readData                                                                                            // 1548
 */                                                                                                                    // 1549
StringReader.prototype.readData = function(size) {                                                                     // 1550
    this.checkOffset(size);                                                                                            // 1551
    // this will work because the constructor applied the "& 0xff" mask.                                               // 1552
    var result = this.data.slice(this.index, this.index + size);                                                       // 1553
    this.index += size;                                                                                                // 1554
    return result;                                                                                                     // 1555
};                                                                                                                     // 1556
module.exports = StringReader;                                                                                         // 1557
                                                                                                                       // 1558
},{"./dataReader":5,"./utils":21}],16:[function(_dereq_,module,exports){                                               // 1559
'use strict';                                                                                                          // 1560
                                                                                                                       // 1561
var utils = _dereq_('./utils');                                                                                        // 1562
                                                                                                                       // 1563
/**                                                                                                                    // 1564
 * An object to write any content to a string.                                                                         // 1565
 * @constructor                                                                                                        // 1566
 */                                                                                                                    // 1567
var StringWriter = function() {                                                                                        // 1568
    this.data = [];                                                                                                    // 1569
};                                                                                                                     // 1570
StringWriter.prototype = {                                                                                             // 1571
    /**                                                                                                                // 1572
     * Append any content to the current string.                                                                       // 1573
     * @param {Object} input the content to add.                                                                       // 1574
     */                                                                                                                // 1575
    append: function(input) {                                                                                          // 1576
        input = utils.transformTo("string", input);                                                                    // 1577
        this.data.push(input);                                                                                         // 1578
    },                                                                                                                 // 1579
    /**                                                                                                                // 1580
     * Finalize the construction an return the result.                                                                 // 1581
     * @return {string} the generated string.                                                                          // 1582
     */                                                                                                                // 1583
    finalize: function() {                                                                                             // 1584
        return this.data.join("");                                                                                     // 1585
    }                                                                                                                  // 1586
};                                                                                                                     // 1587
                                                                                                                       // 1588
module.exports = StringWriter;                                                                                         // 1589
                                                                                                                       // 1590
},{"./utils":21}],17:[function(_dereq_,module,exports){                                                                // 1591
(function (Buffer){                                                                                                    // 1592
'use strict';                                                                                                          // 1593
exports.base64 = true;                                                                                                 // 1594
exports.array = true;                                                                                                  // 1595
exports.string = true;                                                                                                 // 1596
exports.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";                         // 1597
// contains true if JSZip can read/generate nodejs Buffer, false otherwise.                                            // 1598
// Browserify will provide a Buffer implementation for browsers, which is                                              // 1599
// an augmented Uint8Array (i.e., can be used as either Buffer or U8).                                                 // 1600
exports.nodebuffer = typeof Buffer !== "undefined";                                                                    // 1601
// contains true if JSZip can read/generate Uint8Array, false otherwise.                                               // 1602
exports.uint8array = typeof Uint8Array !== "undefined";                                                                // 1603
                                                                                                                       // 1604
if (typeof ArrayBuffer === "undefined") {                                                                              // 1605
    exports.blob = false;                                                                                              // 1606
}                                                                                                                      // 1607
else {                                                                                                                 // 1608
    var buffer = new ArrayBuffer(0);                                                                                   // 1609
    try {                                                                                                              // 1610
        exports.blob = new Blob([buffer], {                                                                            // 1611
            type: "application/zip"                                                                                    // 1612
        }).size === 0;                                                                                                 // 1613
    }                                                                                                                  // 1614
    catch (e) {                                                                                                        // 1615
        try {                                                                                                          // 1616
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();                                                                               // 1618
            builder.append(buffer);                                                                                    // 1619
            exports.blob = builder.getBlob('application/zip').size === 0;                                              // 1620
        }                                                                                                              // 1621
        catch (e) {                                                                                                    // 1622
            exports.blob = false;                                                                                      // 1623
        }                                                                                                              // 1624
    }                                                                                                                  // 1625
}                                                                                                                      // 1626
                                                                                                                       // 1627
}).call(this,(typeof Buffer !== "undefined" ? Buffer : undefined))                                                     // 1628
},{}],18:[function(_dereq_,module,exports){                                                                            // 1629
'use strict';                                                                                                          // 1630
var DataReader = _dereq_('./dataReader');                                                                              // 1631
                                                                                                                       // 1632
function Uint8ArrayReader(data) {                                                                                      // 1633
    if (data) {                                                                                                        // 1634
        this.data = data;                                                                                              // 1635
        this.length = this.data.length;                                                                                // 1636
        this.index = 0;                                                                                                // 1637
    }                                                                                                                  // 1638
}                                                                                                                      // 1639
Uint8ArrayReader.prototype = new DataReader();                                                                         // 1640
/**                                                                                                                    // 1641
 * @see DataReader.byteAt                                                                                              // 1642
 */                                                                                                                    // 1643
Uint8ArrayReader.prototype.byteAt = function(i) {                                                                      // 1644
    return this.data[i];                                                                                               // 1645
};                                                                                                                     // 1646
/**                                                                                                                    // 1647
 * @see DataReader.lastIndexOfSignature                                                                                // 1648
 */                                                                                                                    // 1649
Uint8ArrayReader.prototype.lastIndexOfSignature = function(sig) {                                                      // 1650
    var sig0 = sig.charCodeAt(0),                                                                                      // 1651
        sig1 = sig.charCodeAt(1),                                                                                      // 1652
        sig2 = sig.charCodeAt(2),                                                                                      // 1653
        sig3 = sig.charCodeAt(3);                                                                                      // 1654
    for (var i = this.length - 4; i >= 0; --i) {                                                                       // 1655
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
            return i;                                                                                                  // 1657
        }                                                                                                              // 1658
    }                                                                                                                  // 1659
                                                                                                                       // 1660
    return -1;                                                                                                         // 1661
};                                                                                                                     // 1662
/**                                                                                                                    // 1663
 * @see DataReader.readData                                                                                            // 1664
 */                                                                                                                    // 1665
Uint8ArrayReader.prototype.readData = function(size) {                                                                 // 1666
    this.checkOffset(size);                                                                                            // 1667
    if(size === 0) {                                                                                                   // 1668
        // in IE10, when using subarray(idx, idx), we get the array [0x00] instead of [].                              // 1669
        return new Uint8Array(0);                                                                                      // 1670
    }                                                                                                                  // 1671
    var result = this.data.subarray(this.index, this.index + size);                                                    // 1672
    this.index += size;                                                                                                // 1673
    return result;                                                                                                     // 1674
};                                                                                                                     // 1675
module.exports = Uint8ArrayReader;                                                                                     // 1676
                                                                                                                       // 1677
},{"./dataReader":5}],19:[function(_dereq_,module,exports){                                                            // 1678
'use strict';                                                                                                          // 1679
                                                                                                                       // 1680
var utils = _dereq_('./utils');                                                                                        // 1681
                                                                                                                       // 1682
/**                                                                                                                    // 1683
 * An object to write any content to an Uint8Array.                                                                    // 1684
 * @constructor                                                                                                        // 1685
 * @param {number} length The length of the array.                                                                     // 1686
 */                                                                                                                    // 1687
var Uint8ArrayWriter = function(length) {                                                                              // 1688
    this.data = new Uint8Array(length);                                                                                // 1689
    this.index = 0;                                                                                                    // 1690
};                                                                                                                     // 1691
Uint8ArrayWriter.prototype = {                                                                                         // 1692
    /**                                                                                                                // 1693
     * Append any content to the current array.                                                                        // 1694
     * @param {Object} input the content to add.                                                                       // 1695
     */                                                                                                                // 1696
    append: function(input) {                                                                                          // 1697
        if (input.length !== 0) {                                                                                      // 1698
            // with an empty Uint8Array, Opera fails with a "Offset larger than array size"                            // 1699
            input = utils.transformTo("uint8array", input);                                                            // 1700
            this.data.set(input, this.index);                                                                          // 1701
            this.index += input.length;                                                                                // 1702
        }                                                                                                              // 1703
    },                                                                                                                 // 1704
    /**                                                                                                                // 1705
     * Finalize the construction an return the result.                                                                 // 1706
     * @return {Uint8Array} the generated array.                                                                       // 1707
     */                                                                                                                // 1708
    finalize: function() {                                                                                             // 1709
        return this.data;                                                                                              // 1710
    }                                                                                                                  // 1711
};                                                                                                                     // 1712
                                                                                                                       // 1713
module.exports = Uint8ArrayWriter;                                                                                     // 1714
                                                                                                                       // 1715
},{"./utils":21}],20:[function(_dereq_,module,exports){                                                                // 1716
'use strict';                                                                                                          // 1717
                                                                                                                       // 1718
var utils = _dereq_('./utils');                                                                                        // 1719
var support = _dereq_('./support');                                                                                    // 1720
var nodeBuffer = _dereq_('./nodeBuffer');                                                                              // 1721
                                                                                                                       // 1722
/**                                                                                                                    // 1723
 * The following functions come from pako, from pako/lib/utils/strings                                                 // 1724
 * released under the MIT license, see pako https://github.com/nodeca/pako/                                            // 1725
 */                                                                                                                    // 1726
                                                                                                                       // 1727
// Table with utf8 lengths (calculated by first byte of sequence)                                                      // 1728
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,                                   // 1729
// because max possible codepoint is 0x10ffff                                                                          // 1730
var _utf8len = new Array(256);                                                                                         // 1731
for (var i=0; i<256; i++) {                                                                                            // 1732
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);                        // 1733
}                                                                                                                      // 1734
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start                                                               // 1735
                                                                                                                       // 1736
// convert string to array (typed, when possible)                                                                      // 1737
var string2buf = function (str) {                                                                                      // 1738
    var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;                                                       // 1739
                                                                                                                       // 1740
    // count binary size                                                                                               // 1741
    for (m_pos = 0; m_pos < str_len; m_pos++) {                                                                        // 1742
        c = str.charCodeAt(m_pos);                                                                                     // 1743
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {                                                          // 1744
            c2 = str.charCodeAt(m_pos+1);                                                                              // 1745
            if ((c2 & 0xfc00) === 0xdc00) {                                                                            // 1746
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);                                                    // 1747
                m_pos++;                                                                                               // 1748
            }                                                                                                          // 1749
        }                                                                                                              // 1750
        buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;                                                 // 1751
    }                                                                                                                  // 1752
                                                                                                                       // 1753
    // allocate buffer                                                                                                 // 1754
    if (support.uint8array) {                                                                                          // 1755
        buf = new Uint8Array(buf_len);                                                                                 // 1756
    } else {                                                                                                           // 1757
        buf = new Array(buf_len);                                                                                      // 1758
    }                                                                                                                  // 1759
                                                                                                                       // 1760
    // convert                                                                                                         // 1761
    for (i=0, m_pos = 0; i < buf_len; m_pos++) {                                                                       // 1762
        c = str.charCodeAt(m_pos);                                                                                     // 1763
        if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {                                                          // 1764
            c2 = str.charCodeAt(m_pos+1);                                                                              // 1765
            if ((c2 & 0xfc00) === 0xdc00) {                                                                            // 1766
                c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);                                                    // 1767
                m_pos++;                                                                                               // 1768
            }                                                                                                          // 1769
        }                                                                                                              // 1770
        if (c < 0x80) {                                                                                                // 1771
            /* one byte */                                                                                             // 1772
            buf[i++] = c;                                                                                              // 1773
        } else if (c < 0x800) {                                                                                        // 1774
            /* two bytes */                                                                                            // 1775
            buf[i++] = 0xC0 | (c >>> 6);                                                                               // 1776
            buf[i++] = 0x80 | (c & 0x3f);                                                                              // 1777
        } else if (c < 0x10000) {                                                                                      // 1778
            /* three bytes */                                                                                          // 1779
            buf[i++] = 0xE0 | (c >>> 12);                                                                              // 1780
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);                                                                        // 1781
            buf[i++] = 0x80 | (c & 0x3f);                                                                              // 1782
        } else {                                                                                                       // 1783
            /* four bytes */                                                                                           // 1784
            buf[i++] = 0xf0 | (c >>> 18);                                                                              // 1785
            buf[i++] = 0x80 | (c >>> 12 & 0x3f);                                                                       // 1786
            buf[i++] = 0x80 | (c >>> 6 & 0x3f);                                                                        // 1787
            buf[i++] = 0x80 | (c & 0x3f);                                                                              // 1788
        }                                                                                                              // 1789
    }                                                                                                                  // 1790
                                                                                                                       // 1791
    return buf;                                                                                                        // 1792
};                                                                                                                     // 1793
                                                                                                                       // 1794
// Calculate max possible position in utf8 buffer,                                                                     // 1795
// that will not break sequence. If that's not possible                                                                // 1796
// - (very small limits) return max size as is.                                                                        // 1797
//                                                                                                                     // 1798
// buf[] - utf8 bytes array                                                                                            // 1799
// max   - length limit (mandatory);                                                                                   // 1800
var utf8border = function(buf, max) {                                                                                  // 1801
    var pos;                                                                                                           // 1802
                                                                                                                       // 1803
    max = max || buf.length;                                                                                           // 1804
    if (max > buf.length) { max = buf.length; }                                                                        // 1805
                                                                                                                       // 1806
    // go back from last position, until start of sequence found                                                       // 1807
    pos = max-1;                                                                                                       // 1808
    while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }                                                          // 1809
                                                                                                                       // 1810
    // Fuckup - very small and broken sequence,                                                                        // 1811
    // return max, because we should return something anyway.                                                          // 1812
    if (pos < 0) { return max; }                                                                                       // 1813
                                                                                                                       // 1814
    // If we came to start of buffer - that means vuffer is too small,                                                 // 1815
    // return max too.                                                                                                 // 1816
    if (pos === 0) { return max; }                                                                                     // 1817
                                                                                                                       // 1818
    return (pos + _utf8len[buf[pos]] > max) ? pos : max;                                                               // 1819
};                                                                                                                     // 1820
                                                                                                                       // 1821
// convert array to string                                                                                             // 1822
var buf2string = function (buf) {                                                                                      // 1823
    var str, i, out, c, c_len;                                                                                         // 1824
    var len = buf.length;                                                                                              // 1825
                                                                                                                       // 1826
    // Reserve max possible length (2 words per char)                                                                  // 1827
    // NB: by unknown reasons, Array is significantly faster for                                                       // 1828
    //     String.fromCharCode.apply than Uint16Array.                                                                 // 1829
    var utf16buf = new Array(len*2);                                                                                   // 1830
                                                                                                                       // 1831
    for (out=0, i=0; i<len;) {                                                                                         // 1832
        c = buf[i++];                                                                                                  // 1833
        // quick process ascii                                                                                         // 1834
        if (c < 0x80) { utf16buf[out++] = c; continue; }                                                               // 1835
                                                                                                                       // 1836
        c_len = _utf8len[c];                                                                                           // 1837
        // skip 5 & 6 byte codes                                                                                       // 1838
        if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }                                           // 1839
                                                                                                                       // 1840
        // apply mask on first byte                                                                                    // 1841
        c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;                                                           // 1842
        // join the rest                                                                                               // 1843
        while (c_len > 1 && i < len) {                                                                                 // 1844
            c = (c << 6) | (buf[i++] & 0x3f);                                                                          // 1845
            c_len--;                                                                                                   // 1846
        }                                                                                                              // 1847
                                                                                                                       // 1848
        // terminated by end of string?                                                                                // 1849
        if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }                                                         // 1850
                                                                                                                       // 1851
        if (c < 0x10000) {                                                                                             // 1852
            utf16buf[out++] = c;                                                                                       // 1853
        } else {                                                                                                       // 1854
            c -= 0x10000;                                                                                              // 1855
            utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);                                                            // 1856
            utf16buf[out++] = 0xdc00 | (c & 0x3ff);                                                                    // 1857
        }                                                                                                              // 1858
    }                                                                                                                  // 1859
                                                                                                                       // 1860
    // shrinkBuf(utf16buf, out)                                                                                        // 1861
    if (utf16buf.length !== out) {                                                                                     // 1862
        if(utf16buf.subarray) {                                                                                        // 1863
            utf16buf = utf16buf.subarray(0, out);                                                                      // 1864
        } else {                                                                                                       // 1865
            utf16buf.length = out;                                                                                     // 1866
        }                                                                                                              // 1867
    }                                                                                                                  // 1868
                                                                                                                       // 1869
    // return String.fromCharCode.apply(null, utf16buf);                                                               // 1870
    return utils.applyFromCharCode(utf16buf);                                                                          // 1871
};                                                                                                                     // 1872
                                                                                                                       // 1873
                                                                                                                       // 1874
// That's all for the pako functions.                                                                                  // 1875
                                                                                                                       // 1876
                                                                                                                       // 1877
/**                                                                                                                    // 1878
 * Transform a javascript string into an array (typed if possible) of bytes,                                           // 1879
 * UTF-8 encoded.                                                                                                      // 1880
 * @param {String} str the string to encode                                                                            // 1881
 * @return {Array|Uint8Array|Buffer} the UTF-8 encoded string.                                                         // 1882
 */                                                                                                                    // 1883
exports.utf8encode = function utf8encode(str) {                                                                        // 1884
    if (support.nodebuffer) {                                                                                          // 1885
        return nodeBuffer(str, "utf-8");                                                                               // 1886
    }                                                                                                                  // 1887
                                                                                                                       // 1888
    return string2buf(str);                                                                                            // 1889
};                                                                                                                     // 1890
                                                                                                                       // 1891
                                                                                                                       // 1892
/**                                                                                                                    // 1893
 * Transform a bytes array (or a representation) representing an UTF-8 encoded                                         // 1894
 * string into a javascript string.                                                                                    // 1895
 * @param {Array|Uint8Array|Buffer} buf the data de decode                                                             // 1896
 * @return {String} the decoded string.                                                                                // 1897
 */                                                                                                                    // 1898
exports.utf8decode = function utf8decode(buf) {                                                                        // 1899
    if (support.nodebuffer) {                                                                                          // 1900
        return utils.transformTo("nodebuffer", buf).toString("utf-8");                                                 // 1901
    }                                                                                                                  // 1902
                                                                                                                       // 1903
    buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);                                         // 1904
                                                                                                                       // 1905
    // return buf2string(buf);                                                                                         // 1906
    // Chrome prefers to work with "small" chunks of data                                                              // 1907
    // for the method buf2string.                                                                                      // 1908
    // Firefox and Chrome has their own shortcut, IE doesn't seem to really care.                                      // 1909
    var result = [], k = 0, len = buf.length, chunk = 65536;                                                           // 1910
    while (k < len) {                                                                                                  // 1911
        var nextBoundary = utf8border(buf, Math.min(k + chunk, len));                                                  // 1912
        if (support.uint8array) {                                                                                      // 1913
            result.push(buf2string(buf.subarray(k, nextBoundary)));                                                    // 1914
        } else {                                                                                                       // 1915
            result.push(buf2string(buf.slice(k, nextBoundary)));                                                       // 1916
        }                                                                                                              // 1917
        k = nextBoundary;                                                                                              // 1918
    }                                                                                                                  // 1919
    return result.join("");                                                                                            // 1920
                                                                                                                       // 1921
};                                                                                                                     // 1922
// vim: set shiftwidth=4 softtabstop=4:                                                                                // 1923
                                                                                                                       // 1924
},{"./nodeBuffer":11,"./support":17,"./utils":21}],21:[function(_dereq_,module,exports){                               // 1925
'use strict';                                                                                                          // 1926
var support = _dereq_('./support');                                                                                    // 1927
var compressions = _dereq_('./compressions');                                                                          // 1928
var nodeBuffer = _dereq_('./nodeBuffer');                                                                              // 1929
/**                                                                                                                    // 1930
 * Convert a string to a "binary string" : a string containing only char codes between 0 and 255.                      // 1931
 * @param {string} str the string to transform.                                                                        // 1932
 * @return {String} the binary string.                                                                                 // 1933
 */                                                                                                                    // 1934
exports.string2binary = function(str) {                                                                                // 1935
    var result = "";                                                                                                   // 1936
    for (var i = 0; i < str.length; i++) {                                                                             // 1937
        result += String.fromCharCode(str.charCodeAt(i) & 0xff);                                                       // 1938
    }                                                                                                                  // 1939
    return result;                                                                                                     // 1940
};                                                                                                                     // 1941
exports.arrayBuffer2Blob = function(buffer, mimeType) {                                                                // 1942
    exports.checkSupport("blob");                                                                                      // 1943
	mimeType = mimeType || 'application/zip';                                                                             // 1944
                                                                                                                       // 1945
    try {                                                                                                              // 1946
        // Blob constructor                                                                                            // 1947
        return new Blob([buffer], {                                                                                    // 1948
            type: mimeType                                                                                             // 1949
        });                                                                                                            // 1950
    }                                                                                                                  // 1951
    catch (e) {                                                                                                        // 1952
                                                                                                                       // 1953
        try {                                                                                                          // 1954
            // deprecated, browser only, old way                                                                       // 1955
            var Builder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
            var builder = new Builder();                                                                               // 1957
            builder.append(buffer);                                                                                    // 1958
            return builder.getBlob(mimeType);                                                                          // 1959
        }                                                                                                              // 1960
        catch (e) {                                                                                                    // 1961
                                                                                                                       // 1962
            // well, fuck ?!                                                                                           // 1963
            throw new Error("Bug : can't construct the Blob.");                                                        // 1964
        }                                                                                                              // 1965
    }                                                                                                                  // 1966
                                                                                                                       // 1967
                                                                                                                       // 1968
};                                                                                                                     // 1969
/**                                                                                                                    // 1970
 * The identity function.                                                                                              // 1971
 * @param {Object} input the input.                                                                                    // 1972
 * @return {Object} the same input.                                                                                    // 1973
 */                                                                                                                    // 1974
function identity(input) {                                                                                             // 1975
    return input;                                                                                                      // 1976
}                                                                                                                      // 1977
                                                                                                                       // 1978
/**                                                                                                                    // 1979
 * Fill in an array with a string.                                                                                     // 1980
 * @param {String} str the string to use.                                                                              // 1981
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to fill in (will be mutated).                          // 1982
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated array.                                                    // 1983
 */                                                                                                                    // 1984
function stringToArrayLike(str, array) {                                                                               // 1985
    for (var i = 0; i < str.length; ++i) {                                                                             // 1986
        array[i] = str.charCodeAt(i) & 0xFF;                                                                           // 1987
    }                                                                                                                  // 1988
    return array;                                                                                                      // 1989
}                                                                                                                      // 1990
                                                                                                                       // 1991
/**                                                                                                                    // 1992
 * Transform an array-like object to a string.                                                                         // 1993
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.                                          // 1994
 * @return {String} the result.                                                                                        // 1995
 */                                                                                                                    // 1996
function arrayLikeToString(array) {                                                                                    // 1997
    // Performances notes :                                                                                            // 1998
    // --------------------                                                                                            // 1999
    // String.fromCharCode.apply(null, array) is the fastest, see                                                      // 2000
    // see http://jsperf.com/converting-a-uint8array-to-a-string/2                                                     // 2001
    // but the stack is limited (and we can get huge arrays !).                                                        // 2002
    //                                                                                                                 // 2003
    // result += String.fromCharCode(array[i]); generate too many strings !                                            // 2004
    //                                                                                                                 // 2005
    // This code is inspired by http://jsperf.com/arraybuffer-to-string-apply-performance/2                            // 2006
    var chunk = 65536;                                                                                                 // 2007
    var result = [],                                                                                                   // 2008
        len = array.length,                                                                                            // 2009
        type = exports.getTypeOf(array),                                                                               // 2010
        k = 0,                                                                                                         // 2011
        canUseApply = true;                                                                                            // 2012
      try {                                                                                                            // 2013
         switch(type) {                                                                                                // 2014
            case "uint8array":                                                                                         // 2015
               String.fromCharCode.apply(null, new Uint8Array(0));                                                     // 2016
               break;                                                                                                  // 2017
            case "nodebuffer":                                                                                         // 2018
               String.fromCharCode.apply(null, nodeBuffer(0));                                                         // 2019
               break;                                                                                                  // 2020
         }                                                                                                             // 2021
      } catch(e) {                                                                                                     // 2022
         canUseApply = false;                                                                                          // 2023
      }                                                                                                                // 2024
                                                                                                                       // 2025
      // no apply : slow and painful algorithm                                                                         // 2026
      // default browser on android 4.*                                                                                // 2027
      if (!canUseApply) {                                                                                              // 2028
         var resultStr = "";                                                                                           // 2029
         for(var i = 0; i < array.length;i++) {                                                                        // 2030
            resultStr += String.fromCharCode(array[i]);                                                                // 2031
         }                                                                                                             // 2032
    return resultStr;                                                                                                  // 2033
    }                                                                                                                  // 2034
    while (k < len && chunk > 1) {                                                                                     // 2035
        try {                                                                                                          // 2036
            if (type === "array" || type === "nodebuffer") {                                                           // 2037
                result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));                // 2038
            }                                                                                                          // 2039
            else {                                                                                                     // 2040
                result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));             // 2041
            }                                                                                                          // 2042
            k += chunk;                                                                                                // 2043
        }                                                                                                              // 2044
        catch (e) {                                                                                                    // 2045
            chunk = Math.floor(chunk / 2);                                                                             // 2046
        }                                                                                                              // 2047
    }                                                                                                                  // 2048
    return result.join("");                                                                                            // 2049
}                                                                                                                      // 2050
                                                                                                                       // 2051
exports.applyFromCharCode = arrayLikeToString;                                                                         // 2052
                                                                                                                       // 2053
                                                                                                                       // 2054
/**                                                                                                                    // 2055
 * Copy the data from an array-like to an other array-like.                                                            // 2056
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayFrom the origin array.                                            // 2057
 * @param {Array|ArrayBuffer|Uint8Array|Buffer} arrayTo the destination array which will be mutated.                   // 2058
 * @return {Array|ArrayBuffer|Uint8Array|Buffer} the updated destination array.                                        // 2059
 */                                                                                                                    // 2060
function arrayLikeToArrayLike(arrayFrom, arrayTo) {                                                                    // 2061
    for (var i = 0; i < arrayFrom.length; i++) {                                                                       // 2062
        arrayTo[i] = arrayFrom[i];                                                                                     // 2063
    }                                                                                                                  // 2064
    return arrayTo;                                                                                                    // 2065
}                                                                                                                      // 2066
                                                                                                                       // 2067
// a matrix containing functions to transform everything into everything.                                              // 2068
var transform = {};                                                                                                    // 2069
                                                                                                                       // 2070
// string to ?                                                                                                         // 2071
transform["string"] = {                                                                                                // 2072
    "string": identity,                                                                                                // 2073
    "array": function(input) {                                                                                         // 2074
        return stringToArrayLike(input, new Array(input.length));                                                      // 2075
    },                                                                                                                 // 2076
    "arraybuffer": function(input) {                                                                                   // 2077
        return transform["string"]["uint8array"](input).buffer;                                                        // 2078
    },                                                                                                                 // 2079
    "uint8array": function(input) {                                                                                    // 2080
        return stringToArrayLike(input, new Uint8Array(input.length));                                                 // 2081
    },                                                                                                                 // 2082
    "nodebuffer": function(input) {                                                                                    // 2083
        return stringToArrayLike(input, nodeBuffer(input.length));                                                     // 2084
    }                                                                                                                  // 2085
};                                                                                                                     // 2086
                                                                                                                       // 2087
// array to ?                                                                                                          // 2088
transform["array"] = {                                                                                                 // 2089
    "string": arrayLikeToString,                                                                                       // 2090
    "array": identity,                                                                                                 // 2091
    "arraybuffer": function(input) {                                                                                   // 2092
        return (new Uint8Array(input)).buffer;                                                                         // 2093
    },                                                                                                                 // 2094
    "uint8array": function(input) {                                                                                    // 2095
        return new Uint8Array(input);                                                                                  // 2096
    },                                                                                                                 // 2097
    "nodebuffer": function(input) {                                                                                    // 2098
        return nodeBuffer(input);                                                                                      // 2099
    }                                                                                                                  // 2100
};                                                                                                                     // 2101
                                                                                                                       // 2102
// arraybuffer to ?                                                                                                    // 2103
transform["arraybuffer"] = {                                                                                           // 2104
    "string": function(input) {                                                                                        // 2105
        return arrayLikeToString(new Uint8Array(input));                                                               // 2106
    },                                                                                                                 // 2107
    "array": function(input) {                                                                                         // 2108
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));                               // 2109
    },                                                                                                                 // 2110
    "arraybuffer": identity,                                                                                           // 2111
    "uint8array": function(input) {                                                                                    // 2112
        return new Uint8Array(input);                                                                                  // 2113
    },                                                                                                                 // 2114
    "nodebuffer": function(input) {                                                                                    // 2115
        return nodeBuffer(new Uint8Array(input));                                                                      // 2116
    }                                                                                                                  // 2117
};                                                                                                                     // 2118
                                                                                                                       // 2119
// uint8array to ?                                                                                                     // 2120
transform["uint8array"] = {                                                                                            // 2121
    "string": arrayLikeToString,                                                                                       // 2122
    "array": function(input) {                                                                                         // 2123
        return arrayLikeToArrayLike(input, new Array(input.length));                                                   // 2124
    },                                                                                                                 // 2125
    "arraybuffer": function(input) {                                                                                   // 2126
        return input.buffer;                                                                                           // 2127
    },                                                                                                                 // 2128
    "uint8array": identity,                                                                                            // 2129
    "nodebuffer": function(input) {                                                                                    // 2130
        return nodeBuffer(input);                                                                                      // 2131
    }                                                                                                                  // 2132
};                                                                                                                     // 2133
                                                                                                                       // 2134
// nodebuffer to ?                                                                                                     // 2135
transform["nodebuffer"] = {                                                                                            // 2136
    "string": arrayLikeToString,                                                                                       // 2137
    "array": function(input) {                                                                                         // 2138
        return arrayLikeToArrayLike(input, new Array(input.length));                                                   // 2139
    },                                                                                                                 // 2140
    "arraybuffer": function(input) {                                                                                   // 2141
        return transform["nodebuffer"]["uint8array"](input).buffer;                                                    // 2142
    },                                                                                                                 // 2143
    "uint8array": function(input) {                                                                                    // 2144
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));                                              // 2145
    },                                                                                                                 // 2146
    "nodebuffer": identity                                                                                             // 2147
};                                                                                                                     // 2148
                                                                                                                       // 2149
/**                                                                                                                    // 2150
 * Transform an input into any type.                                                                                   // 2151
 * The supported output type are : string, array, uint8array, arraybuffer, nodebuffer.                                 // 2152
 * If no output type is specified, the unmodified input will be returned.                                              // 2153
 * @param {String} outputType the output type.                                                                         // 2154
 * @param {String|Array|ArrayBuffer|Uint8Array|Buffer} input the input to convert.                                     // 2155
 * @throws {Error} an Error if the browser doesn't support the requested output type.                                  // 2156
 */                                                                                                                    // 2157
exports.transformTo = function(outputType, input) {                                                                    // 2158
    if (!input) {                                                                                                      // 2159
        // undefined, null, etc                                                                                        // 2160
        // an empty string won't harm.                                                                                 // 2161
        input = "";                                                                                                    // 2162
    }                                                                                                                  // 2163
    if (!outputType) {                                                                                                 // 2164
        return input;                                                                                                  // 2165
    }                                                                                                                  // 2166
    exports.checkSupport(outputType);                                                                                  // 2167
    var inputType = exports.getTypeOf(input);                                                                          // 2168
    var result = transform[inputType][outputType](input);                                                              // 2169
    return result;                                                                                                     // 2170
};                                                                                                                     // 2171
                                                                                                                       // 2172
/**                                                                                                                    // 2173
 * Return the type of the input.                                                                                       // 2174
 * The type will be in a format valid for JSZip.utils.transformTo : string, array, uint8array, arraybuffer.            // 2175
 * @param {Object} input the input to identify.                                                                        // 2176
 * @return {String} the (lowercase) type of the input.                                                                 // 2177
 */                                                                                                                    // 2178
exports.getTypeOf = function(input) {                                                                                  // 2179
    if (typeof input === "string") {                                                                                   // 2180
        return "string";                                                                                               // 2181
    }                                                                                                                  // 2182
    if (Object.prototype.toString.call(input) === "[object Array]") {                                                  // 2183
        return "array";                                                                                                // 2184
    }                                                                                                                  // 2185
    if (support.nodebuffer && nodeBuffer.test(input)) {                                                                // 2186
        return "nodebuffer";                                                                                           // 2187
    }                                                                                                                  // 2188
    if (support.uint8array && input instanceof Uint8Array) {                                                           // 2189
        return "uint8array";                                                                                           // 2190
    }                                                                                                                  // 2191
    if (support.arraybuffer && input instanceof ArrayBuffer) {                                                         // 2192
        return "arraybuffer";                                                                                          // 2193
    }                                                                                                                  // 2194
};                                                                                                                     // 2195
                                                                                                                       // 2196
/**                                                                                                                    // 2197
 * Throw an exception if the type is not supported.                                                                    // 2198
 * @param {String} type the type to check.                                                                             // 2199
 * @throws {Error} an Error if the browser doesn't support the requested type.                                         // 2200
 */                                                                                                                    // 2201
exports.checkSupport = function(type) {                                                                                // 2202
    var supported = support[type.toLowerCase()];                                                                       // 2203
    if (!supported) {                                                                                                  // 2204
        throw new Error(type + " is not supported by this browser");                                                   // 2205
    }                                                                                                                  // 2206
};                                                                                                                     // 2207
exports.MAX_VALUE_16BITS = 65535;                                                                                      // 2208
exports.MAX_VALUE_32BITS = -1; // well, "\xFF\xFF\xFF\xFF\xFF\xFF\xFF\xFF" is parsed as -1                             // 2209
                                                                                                                       // 2210
/**                                                                                                                    // 2211
 * Prettify a string read as binary.                                                                                   // 2212
 * @param {string} str the string to prettify.                                                                         // 2213
 * @return {string} a pretty string.                                                                                   // 2214
 */                                                                                                                    // 2215
exports.pretty = function(str) {                                                                                       // 2216
    var res = '',                                                                                                      // 2217
        code, i;                                                                                                       // 2218
    for (i = 0; i < (str || "").length; i++) {                                                                         // 2219
        code = str.charCodeAt(i);                                                                                      // 2220
        res += '\\x' + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();                                       // 2221
    }                                                                                                                  // 2222
    return res;                                                                                                        // 2223
};                                                                                                                     // 2224
                                                                                                                       // 2225
/**                                                                                                                    // 2226
 * Find a compression registered in JSZip.                                                                             // 2227
 * @param {string} compressionMethod the method magic to find.                                                         // 2228
 * @return {Object|null} the JSZip compression object, null if none found.                                             // 2229
 */                                                                                                                    // 2230
exports.findCompression = function(compressionMethod) {                                                                // 2231
    for (var method in compressions) {                                                                                 // 2232
        if (!compressions.hasOwnProperty(method)) {                                                                    // 2233
            continue;                                                                                                  // 2234
        }                                                                                                              // 2235
        if (compressions[method].magic === compressionMethod) {                                                        // 2236
            return compressions[method];                                                                               // 2237
        }                                                                                                              // 2238
    }                                                                                                                  // 2239
    return null;                                                                                                       // 2240
};                                                                                                                     // 2241
/**                                                                                                                    // 2242
* Cross-window, cross-Node-context regular expression detection                                                        // 2243
* @param  {Object}  object Anything                                                                                    // 2244
* @return {Boolean}        true if the object is a regular expression,                                                 // 2245
* false otherwise                                                                                                      // 2246
*/                                                                                                                     // 2247
exports.isRegExp = function (object) {                                                                                 // 2248
    return Object.prototype.toString.call(object) === "[object RegExp]";                                               // 2249
};                                                                                                                     // 2250
                                                                                                                       // 2251
                                                                                                                       // 2252
},{"./compressions":3,"./nodeBuffer":11,"./support":17}],22:[function(_dereq_,module,exports){                         // 2253
'use strict';                                                                                                          // 2254
var StringReader = _dereq_('./stringReader');                                                                          // 2255
var NodeBufferReader = _dereq_('./nodeBufferReader');                                                                  // 2256
var Uint8ArrayReader = _dereq_('./uint8ArrayReader');                                                                  // 2257
var utils = _dereq_('./utils');                                                                                        // 2258
var sig = _dereq_('./signature');                                                                                      // 2259
var ZipEntry = _dereq_('./zipEntry');                                                                                  // 2260
var support = _dereq_('./support');                                                                                    // 2261
var jszipProto = _dereq_('./object');                                                                                  // 2262
//  class ZipEntries {{{                                                                                               // 2263
/**                                                                                                                    // 2264
 * All the entries in the zip file.                                                                                    // 2265
 * @constructor                                                                                                        // 2266
 * @param {String|ArrayBuffer|Uint8Array} data the binary stream to load.                                              // 2267
 * @param {Object} loadOptions Options for loading the stream.                                                         // 2268
 */                                                                                                                    // 2269
function ZipEntries(data, loadOptions) {                                                                               // 2270
    this.files = [];                                                                                                   // 2271
    this.loadOptions = loadOptions;                                                                                    // 2272
    if (data) {                                                                                                        // 2273
        this.load(data);                                                                                               // 2274
    }                                                                                                                  // 2275
}                                                                                                                      // 2276
ZipEntries.prototype = {                                                                                               // 2277
    /**                                                                                                                // 2278
     * Check that the reader is on the speficied signature.                                                            // 2279
     * @param {string} expectedSignature the expected signature.                                                       // 2280
     * @throws {Error} if it is an other signature.                                                                    // 2281
     */                                                                                                                // 2282
    checkSignature: function(expectedSignature) {                                                                      // 2283
        var signature = this.reader.readString(4);                                                                     // 2284
        if (signature !== expectedSignature) {                                                                         // 2285
            throw new Error("Corrupted zip or bug : unexpected signature " + "(" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }                                                                                                              // 2287
    },                                                                                                                 // 2288
    /**                                                                                                                // 2289
     * Read the end of the central directory.                                                                          // 2290
     */                                                                                                                // 2291
    readBlockEndOfCentral: function() {                                                                                // 2292
        this.diskNumber = this.reader.readInt(2);                                                                      // 2293
        this.diskWithCentralDirStart = this.reader.readInt(2);                                                         // 2294
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);                                                     // 2295
        this.centralDirRecords = this.reader.readInt(2);                                                               // 2296
        this.centralDirSize = this.reader.readInt(4);                                                                  // 2297
        this.centralDirOffset = this.reader.readInt(4);                                                                // 2298
                                                                                                                       // 2299
        this.zipCommentLength = this.reader.readInt(2);                                                                // 2300
        // warning : the encoding depends of the system locale                                                         // 2301
        // On a linux machine with LANG=en_US.utf8, this field is utf8 encoded.                                        // 2302
        // On a windows machine, this field is encoded with the localized windows code page.                           // 2303
        this.zipComment = this.reader.readString(this.zipCommentLength);                                               // 2304
        // To get consistent behavior with the generation part, we will assume that                                    // 2305
        // this is utf8 encoded.                                                                                       // 2306
        this.zipComment = jszipProto.utf8decode(this.zipComment);                                                      // 2307
    },                                                                                                                 // 2308
    /**                                                                                                                // 2309
     * Read the end of the Zip 64 central directory.                                                                   // 2310
     * Not merged with the method readEndOfCentral :                                                                   // 2311
     * The end of central can coexist with its Zip64 brother,                                                          // 2312
     * I don't want to read the wrong number of bytes !                                                                // 2313
     */                                                                                                                // 2314
    readBlockZip64EndOfCentral: function() {                                                                           // 2315
        this.zip64EndOfCentralSize = this.reader.readInt(8);                                                           // 2316
        this.versionMadeBy = this.reader.readString(2);                                                                // 2317
        this.versionNeeded = this.reader.readInt(2);                                                                   // 2318
        this.diskNumber = this.reader.readInt(4);                                                                      // 2319
        this.diskWithCentralDirStart = this.reader.readInt(4);                                                         // 2320
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);                                                     // 2321
        this.centralDirRecords = this.reader.readInt(8);                                                               // 2322
        this.centralDirSize = this.reader.readInt(8);                                                                  // 2323
        this.centralDirOffset = this.reader.readInt(8);                                                                // 2324
                                                                                                                       // 2325
        this.zip64ExtensibleData = {};                                                                                 // 2326
        var extraDataSize = this.zip64EndOfCentralSize - 44,                                                           // 2327
            index = 0,                                                                                                 // 2328
            extraFieldId,                                                                                              // 2329
            extraFieldLength,                                                                                          // 2330
            extraFieldValue;                                                                                           // 2331
        while (index < extraDataSize) {                                                                                // 2332
            extraFieldId = this.reader.readInt(2);                                                                     // 2333
            extraFieldLength = this.reader.readInt(4);                                                                 // 2334
            extraFieldValue = this.reader.readString(extraFieldLength);                                                // 2335
            this.zip64ExtensibleData[extraFieldId] = {                                                                 // 2336
                id: extraFieldId,                                                                                      // 2337
                length: extraFieldLength,                                                                              // 2338
                value: extraFieldValue                                                                                 // 2339
            };                                                                                                         // 2340
        }                                                                                                              // 2341
    },                                                                                                                 // 2342
    /**                                                                                                                // 2343
     * Read the end of the Zip 64 central directory locator.                                                           // 2344
     */                                                                                                                // 2345
    readBlockZip64EndOfCentralLocator: function() {                                                                    // 2346
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);                                                    // 2347
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);                                              // 2348
        this.disksCount = this.reader.readInt(4);                                                                      // 2349
        if (this.disksCount > 1) {                                                                                     // 2350
            throw new Error("Multi-volumes zip are not supported");                                                    // 2351
        }                                                                                                              // 2352
    },                                                                                                                 // 2353
    /**                                                                                                                // 2354
     * Read the local files, based on the offset read in the central part.                                             // 2355
     */                                                                                                                // 2356
    readLocalFiles: function() {                                                                                       // 2357
        var i, file;                                                                                                   // 2358
        for (i = 0; i < this.files.length; i++) {                                                                      // 2359
            file = this.files[i];                                                                                      // 2360
            this.reader.setIndex(file.localHeaderOffset);                                                              // 2361
            this.checkSignature(sig.LOCAL_FILE_HEADER);                                                                // 2362
            file.readLocalPart(this.reader);                                                                           // 2363
            file.handleUTF8();                                                                                         // 2364
            file.processAttributes();                                                                                  // 2365
        }                                                                                                              // 2366
    },                                                                                                                 // 2367
    /**                                                                                                                // 2368
     * Read the central directory.                                                                                     // 2369
     */                                                                                                                // 2370
    readCentralDir: function() {                                                                                       // 2371
        var file;                                                                                                      // 2372
                                                                                                                       // 2373
        this.reader.setIndex(this.centralDirOffset);                                                                   // 2374
        while (this.reader.readString(4) === sig.CENTRAL_FILE_HEADER) {                                                // 2375
            file = new ZipEntry({                                                                                      // 2376
                zip64: this.zip64                                                                                      // 2377
            }, this.loadOptions);                                                                                      // 2378
            file.readCentralPart(this.reader);                                                                         // 2379
            this.files.push(file);                                                                                     // 2380
        }                                                                                                              // 2381
    },                                                                                                                 // 2382
    /**                                                                                                                // 2383
     * Read the end of central directory.                                                                              // 2384
     */                                                                                                                // 2385
    readEndOfCentral: function() {                                                                                     // 2386
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);                                      // 2387
        if (offset === -1) {                                                                                           // 2388
            // Check if the content is a truncated zip or complete garbage.                                            // 2389
            // A "LOCAL_FILE_HEADER" is not required at the beginning (auto                                            // 2390
            // extractible zip for example) but it can give a good hint.                                               // 2391
            // If an ajax request was used without responseType, we will also                                          // 2392
            // get unreadable data.                                                                                    // 2393
            var isGarbage = true;                                                                                      // 2394
            try {                                                                                                      // 2395
                this.reader.setIndex(0);                                                                               // 2396
                this.checkSignature(sig.LOCAL_FILE_HEADER);                                                            // 2397
                isGarbage = false;                                                                                     // 2398
            } catch (e) {}                                                                                             // 2399
                                                                                                                       // 2400
            if (isGarbage) {                                                                                           // 2401
                throw new Error("Can't find end of central directory : is this a zip file ? " +                        // 2402
                                "If it is, see http://stuk.github.io/jszip/documentation/howto/read_zip.html");        // 2403
            } else {                                                                                                   // 2404
                throw new Error("Corrupted zip : can't find end of central directory");                                // 2405
            }                                                                                                          // 2406
        }                                                                                                              // 2407
        this.reader.setIndex(offset);                                                                                  // 2408
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);                                                                // 2409
        this.readBlockEndOfCentral();                                                                                  // 2410
                                                                                                                       // 2411
                                                                                                                       // 2412
        /* extract from the zip spec :                                                                                 // 2413
            4)  If one of the fields in the end of central directory                                                   // 2414
                record is too small to hold required data, the field                                                   // 2415
                should be set to -1 (0xFFFF or 0xFFFFFFFF) and the                                                     // 2416
                ZIP64 format record should be created.                                                                 // 2417
            5)  The end of central directory record and the                                                            // 2418
                Zip64 end of central directory locator record must                                                     // 2419
                reside on the same disk when splitting or spanning                                                     // 2420
                an archive.                                                                                            // 2421
         */                                                                                                            // 2422
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
            this.zip64 = true;                                                                                         // 2424
                                                                                                                       // 2425
            /*                                                                                                         // 2426
            Warning : the zip64 extension is supported, but ONLY if the 64bits integer read from                       // 2427
            the zip file can fit into a 32bits integer. This cannot be solved : Javascript represents                  // 2428
            all numbers as 64-bit double precision IEEE 754 floating point numbers.                                    // 2429
            So, we have 53bits for integers and bitwise operations treat everything as 32bits.                         // 2430
            see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators              // 2431
            and http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf section 8.5                  // 2432
            */                                                                                                         // 2433
                                                                                                                       // 2434
            // should look for a zip64 EOCD locator                                                                    // 2435
            offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);                            // 2436
            if (offset === -1) {                                                                                       // 2437
                throw new Error("Corrupted zip : can't find the ZIP64 end of central directory locator");              // 2438
            }                                                                                                          // 2439
            this.reader.setIndex(offset);                                                                              // 2440
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);                                                  // 2441
            this.readBlockZip64EndOfCentralLocator();                                                                  // 2442
                                                                                                                       // 2443
            // now the zip64 EOCD record                                                                               // 2444
            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);                                             // 2445
            this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);                                                      // 2446
            this.readBlockZip64EndOfCentral();                                                                         // 2447
        }                                                                                                              // 2448
    },                                                                                                                 // 2449
    prepareReader: function(data) {                                                                                    // 2450
        var type = utils.getTypeOf(data);                                                                              // 2451
        if (type === "string" && !support.uint8array) {                                                                // 2452
            this.reader = new StringReader(data, this.loadOptions.optimizedBinaryString);                              // 2453
        }                                                                                                              // 2454
        else if (type === "nodebuffer") {                                                                              // 2455
            this.reader = new NodeBufferReader(data);                                                                  // 2456
        }                                                                                                              // 2457
        else {                                                                                                         // 2458
            this.reader = new Uint8ArrayReader(utils.transformTo("uint8array", data));                                 // 2459
        }                                                                                                              // 2460
    },                                                                                                                 // 2461
    /**                                                                                                                // 2462
     * Read a zip file and create ZipEntries.                                                                          // 2463
     * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.                   // 2464
     */                                                                                                                // 2465
    load: function(data) {                                                                                             // 2466
        this.prepareReader(data);                                                                                      // 2467
        this.readEndOfCentral();                                                                                       // 2468
        this.readCentralDir();                                                                                         // 2469
        this.readLocalFiles();                                                                                         // 2470
    }                                                                                                                  // 2471
};                                                                                                                     // 2472
// }}} end of ZipEntries                                                                                               // 2473
module.exports = ZipEntries;                                                                                           // 2474
                                                                                                                       // 2475
},{"./nodeBufferReader":12,"./object":13,"./signature":14,"./stringReader":15,"./support":17,"./uint8ArrayReader":18,"./utils":21,"./zipEntry":23}],23:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 2477
var StringReader = _dereq_('./stringReader');                                                                          // 2478
var utils = _dereq_('./utils');                                                                                        // 2479
var CompressedObject = _dereq_('./compressedObject');                                                                  // 2480
var jszipProto = _dereq_('./object');                                                                                  // 2481
                                                                                                                       // 2482
var MADE_BY_DOS = 0x00;                                                                                                // 2483
var MADE_BY_UNIX = 0x03;                                                                                               // 2484
                                                                                                                       // 2485
// class ZipEntry {{{                                                                                                  // 2486
/**                                                                                                                    // 2487
 * An entry in the zip file.                                                                                           // 2488
 * @constructor                                                                                                        // 2489
 * @param {Object} options Options of the current file.                                                                // 2490
 * @param {Object} loadOptions Options for loading the stream.                                                         // 2491
 */                                                                                                                    // 2492
function ZipEntry(options, loadOptions) {                                                                              // 2493
    this.options = options;                                                                                            // 2494
    this.loadOptions = loadOptions;                                                                                    // 2495
}                                                                                                                      // 2496
ZipEntry.prototype = {                                                                                                 // 2497
    /**                                                                                                                // 2498
     * say if the file is encrypted.                                                                                   // 2499
     * @return {boolean} true if the file is encrypted, false otherwise.                                               // 2500
     */                                                                                                                // 2501
    isEncrypted: function() {                                                                                          // 2502
        // bit 1 is set                                                                                                // 2503
        return (this.bitFlag & 0x0001) === 0x0001;                                                                     // 2504
    },                                                                                                                 // 2505
    /**                                                                                                                // 2506
     * say if the file has utf-8 filename/comment.                                                                     // 2507
     * @return {boolean} true if the filename/comment is in utf-8, false otherwise.                                    // 2508
     */                                                                                                                // 2509
    useUTF8: function() {                                                                                              // 2510
        // bit 11 is set                                                                                               // 2511
        return (this.bitFlag & 0x0800) === 0x0800;                                                                     // 2512
    },                                                                                                                 // 2513
    /**                                                                                                                // 2514
     * Prepare the function used to generate the compressed content from this ZipFile.                                 // 2515
     * @param {DataReader} reader the reader to use.                                                                   // 2516
     * @param {number} from the offset from where we should read the data.                                             // 2517
     * @param {number} length the length of the data to read.                                                          // 2518
     * @return {Function} the callback to get the compressed content (the type depends of the DataReader class).       // 2519
     */                                                                                                                // 2520
    prepareCompressedContent: function(reader, from, length) {                                                         // 2521
        return function() {                                                                                            // 2522
            var previousIndex = reader.index;                                                                          // 2523
            reader.setIndex(from);                                                                                     // 2524
            var compressedFileData = reader.readData(length);                                                          // 2525
            reader.setIndex(previousIndex);                                                                            // 2526
                                                                                                                       // 2527
            return compressedFileData;                                                                                 // 2528
        };                                                                                                             // 2529
    },                                                                                                                 // 2530
    /**                                                                                                                // 2531
     * Prepare the function used to generate the uncompressed content from this ZipFile.                               // 2532
     * @param {DataReader} reader the reader to use.                                                                   // 2533
     * @param {number} from the offset from where we should read the data.                                             // 2534
     * @param {number} length the length of the data to read.                                                          // 2535
     * @param {JSZip.compression} compression the compression used on this file.                                       // 2536
     * @param {number} uncompressedSize the uncompressed size to expect.                                               // 2537
     * @return {Function} the callback to get the uncompressed content (the type depends of the DataReader class).     // 2538
     */                                                                                                                // 2539
    prepareContent: function(reader, from, length, compression, uncompressedSize) {                                    // 2540
        return function() {                                                                                            // 2541
                                                                                                                       // 2542
            var compressedFileData = utils.transformTo(compression.uncompressInputType, this.getCompressedContent());  // 2543
            var uncompressedFileData = compression.uncompress(compressedFileData);                                     // 2544
                                                                                                                       // 2545
            if (uncompressedFileData.length !== uncompressedSize) {                                                    // 2546
                throw new Error("Bug : uncompressed data size mismatch");                                              // 2547
            }                                                                                                          // 2548
                                                                                                                       // 2549
            return uncompressedFileData;                                                                               // 2550
        };                                                                                                             // 2551
    },                                                                                                                 // 2552
    /**                                                                                                                // 2553
     * Read the local part of a zip file and add the info in this object.                                              // 2554
     * @param {DataReader} reader the reader to use.                                                                   // 2555
     */                                                                                                                // 2556
    readLocalPart: function(reader) {                                                                                  // 2557
        var compression, localExtraFieldsLength;                                                                       // 2558
                                                                                                                       // 2559
        // we already know everything from the central dir !                                                           // 2560
        // If the central dir data are false, we are doomed.                                                           // 2561
        // On the bright side, the local part is scary  : zip64, data descriptors, both, etc.                          // 2562
        // The less data we get here, the more reliable this should be.                                                // 2563
        // Let's skip the whole header and dash to the data !                                                          // 2564
        reader.skip(22);                                                                                               // 2565
        // in some zip created on windows, the filename stored in the central dir contains \ instead of /.             // 2566
        // Strangely, the filename here is OK.                                                                         // 2567
        // I would love to treat these zip files as corrupted (see http://www.info-zip.org/FAQ.html#backslashes        // 2568
        // or APPNOTE#4.4.17.1, "All slashes MUST be forward slashes '/'") but there are a lot of bad zip generators...
        // Search "unzip mismatching "local" filename continuing with "central" filename version" on                   // 2570
        // the internet.                                                                                               // 2571
        //                                                                                                             // 2572
        // I think I see the logic here : the central directory is used to display                                     // 2573
        // content and the local directory is used to extract the files. Mixing / and \
        // may be used to display \ to windows users and use / when extracting the files.                              // 2575
        // Unfortunately, this lead also to some issues : http://seclists.org/fulldisclosure/2009/Sep/394              // 2576
        this.fileNameLength = reader.readInt(2);                                                                       // 2577
        localExtraFieldsLength = reader.readInt(2); // can't be sure this will be the same as the central dir          // 2578
        this.fileName = reader.readString(this.fileNameLength);                                                        // 2579
        reader.skip(localExtraFieldsLength);                                                                           // 2580
                                                                                                                       // 2581
        if (this.compressedSize == -1 || this.uncompressedSize == -1) {                                                // 2582
            throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory " + "(compressedSize == -1 || uncompressedSize == -1)");
        }                                                                                                              // 2584
                                                                                                                       // 2585
        compression = utils.findCompression(this.compressionMethod);                                                   // 2586
        if (compression === null) { // no compression found                                                            // 2587
            throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + this.fileName + ")");
        }                                                                                                              // 2589
        this.decompressed = new CompressedObject();                                                                    // 2590
        this.decompressed.compressedSize = this.compressedSize;                                                        // 2591
        this.decompressed.uncompressedSize = this.uncompressedSize;                                                    // 2592
        this.decompressed.crc32 = this.crc32;                                                                          // 2593
        this.decompressed.compressionMethod = this.compressionMethod;                                                  // 2594
        this.decompressed.getCompressedContent = this.prepareCompressedContent(reader, reader.index, this.compressedSize, compression);
        this.decompressed.getContent = this.prepareContent(reader, reader.index, this.compressedSize, compression, this.uncompressedSize);
                                                                                                                       // 2597
        // we need to compute the crc32...                                                                             // 2598
        if (this.loadOptions.checkCRC32) {                                                                             // 2599
            this.decompressed = utils.transformTo("string", this.decompressed.getContent());                           // 2600
            if (jszipProto.crc32(this.decompressed) !== this.crc32) {                                                  // 2601
                throw new Error("Corrupted zip : CRC32 mismatch");                                                     // 2602
            }                                                                                                          // 2603
        }                                                                                                              // 2604
    },                                                                                                                 // 2605
                                                                                                                       // 2606
    /**                                                                                                                // 2607
     * Read the central part of a zip file and add the info in this object.                                            // 2608
     * @param {DataReader} reader the reader to use.                                                                   // 2609
     */                                                                                                                // 2610
    readCentralPart: function(reader) {                                                                                // 2611
        this.versionMadeBy = reader.readInt(2);                                                                        // 2612
        this.versionNeeded = reader.readInt(2);                                                                        // 2613
        this.bitFlag = reader.readInt(2);                                                                              // 2614
        this.compressionMethod = reader.readString(2);                                                                 // 2615
        this.date = reader.readDate();                                                                                 // 2616
        this.crc32 = reader.readInt(4);                                                                                // 2617
        this.compressedSize = reader.readInt(4);                                                                       // 2618
        this.uncompressedSize = reader.readInt(4);                                                                     // 2619
        this.fileNameLength = reader.readInt(2);                                                                       // 2620
        this.extraFieldsLength = reader.readInt(2);                                                                    // 2621
        this.fileCommentLength = reader.readInt(2);                                                                    // 2622
        this.diskNumberStart = reader.readInt(2);                                                                      // 2623
        this.internalFileAttributes = reader.readInt(2);                                                               // 2624
        this.externalFileAttributes = reader.readInt(4);                                                               // 2625
        this.localHeaderOffset = reader.readInt(4);                                                                    // 2626
                                                                                                                       // 2627
        if (this.isEncrypted()) {                                                                                      // 2628
            throw new Error("Encrypted zip are not supported");                                                        // 2629
        }                                                                                                              // 2630
                                                                                                                       // 2631
        this.fileName = reader.readString(this.fileNameLength);                                                        // 2632
        this.readExtraFields(reader);                                                                                  // 2633
        this.parseZIP64ExtraField(reader);                                                                             // 2634
        this.fileComment = reader.readString(this.fileCommentLength);                                                  // 2635
    },                                                                                                                 // 2636
                                                                                                                       // 2637
    /**                                                                                                                // 2638
     * Parse the external file attributes and get the unix/dos permissions.                                            // 2639
     */                                                                                                                // 2640
    processAttributes: function () {                                                                                   // 2641
        this.unixPermissions = null;                                                                                   // 2642
        this.dosPermissions = null;                                                                                    // 2643
        var madeBy = this.versionMadeBy >> 8;                                                                          // 2644
                                                                                                                       // 2645
        // Check if we have the DOS directory flag set.                                                                // 2646
        // We look for it in the DOS and UNIX permissions                                                              // 2647
        // but some unknown platform could set it as a compatibility flag.                                             // 2648
        this.dir = this.externalFileAttributes & 0x0010 ? true : false;                                                // 2649
                                                                                                                       // 2650
        if(madeBy === MADE_BY_DOS) {                                                                                   // 2651
            // first 6 bits (0 to 5)                                                                                   // 2652
            this.dosPermissions = this.externalFileAttributes & 0x3F;                                                  // 2653
        }                                                                                                              // 2654
                                                                                                                       // 2655
        if(madeBy === MADE_BY_UNIX) {                                                                                  // 2656
            this.unixPermissions = (this.externalFileAttributes >> 16) & 0xFFFF;                                       // 2657
            // the octal permissions are in (this.unixPermissions & 0x01FF).toString(8);                               // 2658
        }                                                                                                              // 2659
                                                                                                                       // 2660
        // fail safe : if the name ends with a / it probably means a folder                                            // 2661
        if (!this.dir && this.fileName.slice(-1) === '/') {                                                            // 2662
            this.dir = true;                                                                                           // 2663
        }                                                                                                              // 2664
    },                                                                                                                 // 2665
                                                                                                                       // 2666
    /**                                                                                                                // 2667
     * Parse the ZIP64 extra field and merge the info in the current ZipEntry.                                         // 2668
     * @param {DataReader} reader the reader to use.                                                                   // 2669
     */                                                                                                                // 2670
    parseZIP64ExtraField: function(reader) {                                                                           // 2671
                                                                                                                       // 2672
        if (!this.extraFields[0x0001]) {                                                                               // 2673
            return;                                                                                                    // 2674
        }                                                                                                              // 2675
                                                                                                                       // 2676
        // should be something, preparing the extra reader                                                             // 2677
        var extraReader = new StringReader(this.extraFields[0x0001].value);                                            // 2678
                                                                                                                       // 2679
        // I really hope that these 64bits integer can fit in 32 bits integer, because js                              // 2680
        // won't let us have more.                                                                                     // 2681
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {                                                        // 2682
            this.uncompressedSize = extraReader.readInt(8);                                                            // 2683
        }                                                                                                              // 2684
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {                                                          // 2685
            this.compressedSize = extraReader.readInt(8);                                                              // 2686
        }                                                                                                              // 2687
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {                                                       // 2688
            this.localHeaderOffset = extraReader.readInt(8);                                                           // 2689
        }                                                                                                              // 2690
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {                                                         // 2691
            this.diskNumberStart = extraReader.readInt(4);                                                             // 2692
        }                                                                                                              // 2693
    },                                                                                                                 // 2694
    /**                                                                                                                // 2695
     * Read the central part of a zip file and add the info in this object.                                            // 2696
     * @param {DataReader} reader the reader to use.                                                                   // 2697
     */                                                                                                                // 2698
    readExtraFields: function(reader) {                                                                                // 2699
        var start = reader.index,                                                                                      // 2700
            extraFieldId,                                                                                              // 2701
            extraFieldLength,                                                                                          // 2702
            extraFieldValue;                                                                                           // 2703
                                                                                                                       // 2704
        this.extraFields = this.extraFields || {};                                                                     // 2705
                                                                                                                       // 2706
        while (reader.index < start + this.extraFieldsLength) {                                                        // 2707
            extraFieldId = reader.readInt(2);                                                                          // 2708
            extraFieldLength = reader.readInt(2);                                                                      // 2709
            extraFieldValue = reader.readString(extraFieldLength);                                                     // 2710
                                                                                                                       // 2711
            this.extraFields[extraFieldId] = {                                                                         // 2712
                id: extraFieldId,                                                                                      // 2713
                length: extraFieldLength,                                                                              // 2714
                value: extraFieldValue                                                                                 // 2715
            };                                                                                                         // 2716
        }                                                                                                              // 2717
    },                                                                                                                 // 2718
    /**                                                                                                                // 2719
     * Apply an UTF8 transformation if needed.                                                                         // 2720
     */                                                                                                                // 2721
    handleUTF8: function() {                                                                                           // 2722
        if (this.useUTF8()) {                                                                                          // 2723
            this.fileName = jszipProto.utf8decode(this.fileName);                                                      // 2724
            this.fileComment = jszipProto.utf8decode(this.fileComment);                                                // 2725
        } else {                                                                                                       // 2726
            var upath = this.findExtraFieldUnicodePath();                                                              // 2727
            if (upath !== null) {                                                                                      // 2728
                this.fileName = upath;                                                                                 // 2729
            }                                                                                                          // 2730
            var ucomment = this.findExtraFieldUnicodeComment();                                                        // 2731
            if (ucomment !== null) {                                                                                   // 2732
                this.fileComment = ucomment;                                                                           // 2733
            }                                                                                                          // 2734
        }                                                                                                              // 2735
    },                                                                                                                 // 2736
                                                                                                                       // 2737
    /**                                                                                                                // 2738
     * Find the unicode path declared in the extra field, if any.                                                      // 2739
     * @return {String} the unicode path, null otherwise.                                                              // 2740
     */                                                                                                                // 2741
    findExtraFieldUnicodePath: function() {                                                                            // 2742
        var upathField = this.extraFields[0x7075];                                                                     // 2743
        if (upathField) {                                                                                              // 2744
            var extraReader = new StringReader(upathField.value);                                                      // 2745
                                                                                                                       // 2746
            // wrong version                                                                                           // 2747
            if (extraReader.readInt(1) !== 1) {                                                                        // 2748
                return null;                                                                                           // 2749
            }                                                                                                          // 2750
                                                                                                                       // 2751
            // the crc of the filename changed, this field is out of date.                                             // 2752
            if (jszipProto.crc32(this.fileName) !== extraReader.readInt(4)) {                                          // 2753
                return null;                                                                                           // 2754
            }                                                                                                          // 2755
                                                                                                                       // 2756
            return jszipProto.utf8decode(extraReader.readString(upathField.length - 5));                               // 2757
        }                                                                                                              // 2758
        return null;                                                                                                   // 2759
    },                                                                                                                 // 2760
                                                                                                                       // 2761
    /**                                                                                                                // 2762
     * Find the unicode comment declared in the extra field, if any.                                                   // 2763
     * @return {String} the unicode comment, null otherwise.                                                           // 2764
     */                                                                                                                // 2765
    findExtraFieldUnicodeComment: function() {                                                                         // 2766
        var ucommentField = this.extraFields[0x6375];                                                                  // 2767
        if (ucommentField) {                                                                                           // 2768
            var extraReader = new StringReader(ucommentField.value);                                                   // 2769
                                                                                                                       // 2770
            // wrong version                                                                                           // 2771
            if (extraReader.readInt(1) !== 1) {                                                                        // 2772
                return null;                                                                                           // 2773
            }                                                                                                          // 2774
                                                                                                                       // 2775
            // the crc of the comment changed, this field is out of date.                                              // 2776
            if (jszipProto.crc32(this.fileComment) !== extraReader.readInt(4)) {                                       // 2777
                return null;                                                                                           // 2778
            }                                                                                                          // 2779
                                                                                                                       // 2780
            return jszipProto.utf8decode(extraReader.readString(ucommentField.length - 5));                            // 2781
        }                                                                                                              // 2782
        return null;                                                                                                   // 2783
    }                                                                                                                  // 2784
};                                                                                                                     // 2785
module.exports = ZipEntry;                                                                                             // 2786
                                                                                                                       // 2787
},{"./compressedObject":2,"./object":13,"./stringReader":15,"./utils":21}],24:[function(_dereq_,module,exports){       // 2788
// Top level file is just a mixin of submodules & constants                                                            // 2789
'use strict';                                                                                                          // 2790
                                                                                                                       // 2791
var assign    = _dereq_('./lib/utils/common').assign;                                                                  // 2792
                                                                                                                       // 2793
var deflate   = _dereq_('./lib/deflate');                                                                              // 2794
var inflate   = _dereq_('./lib/inflate');                                                                              // 2795
var constants = _dereq_('./lib/zlib/constants');                                                                       // 2796
                                                                                                                       // 2797
var pako = {};                                                                                                         // 2798
                                                                                                                       // 2799
assign(pako, deflate, inflate, constants);                                                                             // 2800
                                                                                                                       // 2801
module.exports = pako;                                                                                                 // 2802
},{"./lib/deflate":25,"./lib/inflate":26,"./lib/utils/common":27,"./lib/zlib/constants":30}],25:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 2804
                                                                                                                       // 2805
                                                                                                                       // 2806
var zlib_deflate = _dereq_('./zlib/deflate.js');                                                                       // 2807
var utils = _dereq_('./utils/common');                                                                                 // 2808
var strings = _dereq_('./utils/strings');                                                                              // 2809
var msg = _dereq_('./zlib/messages');                                                                                  // 2810
var zstream = _dereq_('./zlib/zstream');                                                                               // 2811
                                                                                                                       // 2812
                                                                                                                       // 2813
/* Public constants ==========================================================*/                                       // 2814
/* ===========================================================================*/                                       // 2815
                                                                                                                       // 2816
var Z_NO_FLUSH      = 0;                                                                                               // 2817
var Z_FINISH        = 4;                                                                                               // 2818
                                                                                                                       // 2819
var Z_OK            = 0;                                                                                               // 2820
var Z_STREAM_END    = 1;                                                                                               // 2821
                                                                                                                       // 2822
var Z_DEFAULT_COMPRESSION = -1;                                                                                        // 2823
                                                                                                                       // 2824
var Z_DEFAULT_STRATEGY    = 0;                                                                                         // 2825
                                                                                                                       // 2826
var Z_DEFLATED  = 8;                                                                                                   // 2827
                                                                                                                       // 2828
/* ===========================================================================*/                                       // 2829
                                                                                                                       // 2830
                                                                                                                       // 2831
/**                                                                                                                    // 2832
 * class Deflate                                                                                                       // 2833
 *                                                                                                                     // 2834
 * Generic JS-style wrapper for zlib calls. If you don't need                                                          // 2835
 * streaming behaviour - use more simple functions: [[deflate]],                                                       // 2836
 * [[deflateRaw]] and [[gzip]].                                                                                        // 2837
 **/                                                                                                                   // 2838
                                                                                                                       // 2839
/* internal                                                                                                            // 2840
 * Deflate.chunks -> Array                                                                                             // 2841
 *                                                                                                                     // 2842
 * Chunks of output data, if [[Deflate#onData]] not overriden.                                                         // 2843
 **/                                                                                                                   // 2844
                                                                                                                       // 2845
/**                                                                                                                    // 2846
 * Deflate.result -> Uint8Array|Array                                                                                  // 2847
 *                                                                                                                     // 2848
 * Compressed result, generated by default [[Deflate#onData]]                                                          // 2849
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk                                                    // 2850
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param).                                                             // 2851
 **/                                                                                                                   // 2852
                                                                                                                       // 2853
/**                                                                                                                    // 2854
 * Deflate.err -> Number                                                                                               // 2855
 *                                                                                                                     // 2856
 * Error code after deflate finished. 0 (Z_OK) on success.                                                             // 2857
 * You will not need it in real life, because deflate errors                                                           // 2858
 * are possible only on wrong options or bad `onData` / `onEnd`                                                        // 2859
 * custom handlers.                                                                                                    // 2860
 **/                                                                                                                   // 2861
                                                                                                                       // 2862
/**                                                                                                                    // 2863
 * Deflate.msg -> String                                                                                               // 2864
 *                                                                                                                     // 2865
 * Error message, if [[Deflate.err]] != 0                                                                              // 2866
 **/                                                                                                                   // 2867
                                                                                                                       // 2868
                                                                                                                       // 2869
/**                                                                                                                    // 2870
 * new Deflate(options)                                                                                                // 2871
 * - options (Object): zlib deflate options.                                                                           // 2872
 *                                                                                                                     // 2873
 * Creates new deflator instance with specified params. Throws exception                                               // 2874
 * on bad params. Supported options:                                                                                   // 2875
 *                                                                                                                     // 2876
 * - `level`                                                                                                           // 2877
 * - `windowBits`                                                                                                      // 2878
 * - `memLevel`                                                                                                        // 2879
 * - `strategy`                                                                                                        // 2880
 *                                                                                                                     // 2881
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)                                        // 2882
 * for more information on these.                                                                                      // 2883
 *                                                                                                                     // 2884
 * Additional options, for internal needs:                                                                             // 2885
 *                                                                                                                     // 2886
 * - `chunkSize` - size of generated data chunks (16K by default)                                                      // 2887
 * - `raw` (Boolean) - do raw deflate                                                                                  // 2888
 * - `gzip` (Boolean) - create gzip wrapper                                                                            // 2889
 * - `to` (String) - if equal to 'string', then result will be "binary string"                                         // 2890
 *    (each char code [0..255])                                                                                        // 2891
 * - `header` (Object) - custom header for gzip                                                                        // 2892
 *   - `text` (Boolean) - true if compressed data believed to be text                                                  // 2893
 *   - `time` (Number) - modification time, unix timestamp                                                             // 2894
 *   - `os` (Number) - operation system code                                                                           // 2895
 *   - `extra` (Array) - array of bytes with extra data (max 65536)                                                    // 2896
 *   - `name` (String) - file name (binary string)                                                                     // 2897
 *   - `comment` (String) - comment (binary string)                                                                    // 2898
 *   - `hcrc` (Boolean) - true if header crc should be added                                                           // 2899
 *                                                                                                                     // 2900
 * ##### Example:                                                                                                      // 2901
 *                                                                                                                     // 2902
 * ```javascript                                                                                                       // 2903
 * var pako = require('pako')                                                                                          // 2904
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])                                                                        // 2905
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);                                                           // 2906
 *                                                                                                                     // 2907
 * var deflate = new pako.Deflate({ level: 3});                                                                        // 2908
 *                                                                                                                     // 2909
 * deflate.push(chunk1, false);                                                                                        // 2910
 * deflate.push(chunk2, true);  // true -> last chunk                                                                  // 2911
 *                                                                                                                     // 2912
 * if (deflate.err) { throw new Error(deflate.err); }                                                                  // 2913
 *                                                                                                                     // 2914
 * console.log(deflate.result);                                                                                        // 2915
 * ```                                                                                                                 // 2916
 **/                                                                                                                   // 2917
var Deflate = function(options) {                                                                                      // 2918
                                                                                                                       // 2919
  this.options = utils.assign({                                                                                        // 2920
    level: Z_DEFAULT_COMPRESSION,                                                                                      // 2921
    method: Z_DEFLATED,                                                                                                // 2922
    chunkSize: 16384,                                                                                                  // 2923
    windowBits: 15,                                                                                                    // 2924
    memLevel: 8,                                                                                                       // 2925
    strategy: Z_DEFAULT_STRATEGY,                                                                                      // 2926
    to: ''                                                                                                             // 2927
  }, options || {});                                                                                                   // 2928
                                                                                                                       // 2929
  var opt = this.options;                                                                                              // 2930
                                                                                                                       // 2931
  if (opt.raw && (opt.windowBits > 0)) {                                                                               // 2932
    opt.windowBits = -opt.windowBits;                                                                                  // 2933
  }                                                                                                                    // 2934
                                                                                                                       // 2935
  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {                                                // 2936
    opt.windowBits += 16;                                                                                              // 2937
  }                                                                                                                    // 2938
                                                                                                                       // 2939
  this.err    = 0;      // error code, if happens (0 = Z_OK)                                                           // 2940
  this.msg    = '';     // error message                                                                               // 2941
  this.ended  = false;  // used to avoid multiple onEnd() calls                                                        // 2942
  this.chunks = [];     // chunks of compressed data                                                                   // 2943
                                                                                                                       // 2944
  this.strm = new zstream();                                                                                           // 2945
  this.strm.avail_out = 0;                                                                                             // 2946
                                                                                                                       // 2947
  var status = zlib_deflate.deflateInit2(                                                                              // 2948
    this.strm,                                                                                                         // 2949
    opt.level,                                                                                                         // 2950
    opt.method,                                                                                                        // 2951
    opt.windowBits,                                                                                                    // 2952
    opt.memLevel,                                                                                                      // 2953
    opt.strategy                                                                                                       // 2954
  );                                                                                                                   // 2955
                                                                                                                       // 2956
  if (status !== Z_OK) {                                                                                               // 2957
    throw new Error(msg[status]);                                                                                      // 2958
  }                                                                                                                    // 2959
                                                                                                                       // 2960
  if (opt.header) {                                                                                                    // 2961
    zlib_deflate.deflateSetHeader(this.strm, opt.header);                                                              // 2962
  }                                                                                                                    // 2963
};                                                                                                                     // 2964
                                                                                                                       // 2965
/**                                                                                                                    // 2966
 * Deflate#push(data[, mode]) -> Boolean                                                                               // 2967
 * - data (Uint8Array|Array|String): input data. Strings will be converted to                                          // 2968
 *   utf8 byte sequence.                                                                                               // 2969
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.                                           // 2970
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.                                       // 2971
 *                                                                                                                     // 2972
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with                                          // 2973
 * new compressed chunks. Returns `true` on success. The last data block must have                                     // 2974
 * mode Z_FINISH (or `true`). That flush internal pending buffers and call                                             // 2975
 * [[Deflate#onEnd]].                                                                                                  // 2976
 *                                                                                                                     // 2977
 * On fail call [[Deflate#onEnd]] with error code and return false.                                                    // 2978
 *                                                                                                                     // 2979
 * We strongly recommend to use `Uint8Array` on input for best speed (output                                           // 2980
 * array format is detected automatically). Also, don't skip last param and always                                     // 2981
 * use the same type in your code (boolean or number). That will improve JS speed.                                     // 2982
 *                                                                                                                     // 2983
 * For regular `Array`-s make sure all elements are [0..255].                                                          // 2984
 *                                                                                                                     // 2985
 * ##### Example                                                                                                       // 2986
 *                                                                                                                     // 2987
 * ```javascript                                                                                                       // 2988
 * push(chunk, false); // push one of data chunks                                                                      // 2989
 * ...                                                                                                                 // 2990
 * push(chunk, true);  // push last chunk                                                                              // 2991
 * ```                                                                                                                 // 2992
 **/                                                                                                                   // 2993
Deflate.prototype.push = function(data, mode) {                                                                        // 2994
  var strm = this.strm;                                                                                                // 2995
  var chunkSize = this.options.chunkSize;                                                                              // 2996
  var status, _mode;                                                                                                   // 2997
                                                                                                                       // 2998
  if (this.ended) { return false; }                                                                                    // 2999
                                                                                                                       // 3000
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);                                        // 3001
                                                                                                                       // 3002
  // Convert data if needed                                                                                            // 3003
  if (typeof data === 'string') {                                                                                      // 3004
    // If we need to compress text, change encoding to utf8.                                                           // 3005
    strm.input = strings.string2buf(data);                                                                             // 3006
  } else {                                                                                                             // 3007
    strm.input = data;                                                                                                 // 3008
  }                                                                                                                    // 3009
                                                                                                                       // 3010
  strm.next_in = 0;                                                                                                    // 3011
  strm.avail_in = strm.input.length;                                                                                   // 3012
                                                                                                                       // 3013
  do {                                                                                                                 // 3014
    if (strm.avail_out === 0) {                                                                                        // 3015
      strm.output = new utils.Buf8(chunkSize);                                                                         // 3016
      strm.next_out = 0;                                                                                               // 3017
      strm.avail_out = chunkSize;                                                                                      // 3018
    }                                                                                                                  // 3019
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */                                           // 3020
                                                                                                                       // 3021
    if (status !== Z_STREAM_END && status !== Z_OK) {                                                                  // 3022
      this.onEnd(status);                                                                                              // 3023
      this.ended = true;                                                                                               // 3024
      return false;                                                                                                    // 3025
    }                                                                                                                  // 3026
    if (strm.avail_out === 0 || (strm.avail_in === 0 && _mode === Z_FINISH)) {                                         // 3027
      if (this.options.to === 'string') {                                                                              // 3028
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));                               // 3029
      } else {                                                                                                         // 3030
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));                                                      // 3031
      }                                                                                                                // 3032
    }                                                                                                                  // 3033
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);                                    // 3034
                                                                                                                       // 3035
  // Finalize on the last chunk.                                                                                       // 3036
  if (_mode === Z_FINISH) {                                                                                            // 3037
    status = zlib_deflate.deflateEnd(this.strm);                                                                       // 3038
    this.onEnd(status);                                                                                                // 3039
    this.ended = true;                                                                                                 // 3040
    return status === Z_OK;                                                                                            // 3041
  }                                                                                                                    // 3042
                                                                                                                       // 3043
  return true;                                                                                                         // 3044
};                                                                                                                     // 3045
                                                                                                                       // 3046
                                                                                                                       // 3047
/**                                                                                                                    // 3048
 * Deflate#onData(chunk) -> Void                                                                                       // 3049
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends                                                // 3050
 *   on js engine support. When string output requested, each chunk                                                    // 3051
 *   will be string.                                                                                                   // 3052
 *                                                                                                                     // 3053
 * By default, stores data blocks in `chunks[]` property and glue                                                      // 3054
 * those in `onEnd`. Override this handler, if you need another behaviour.                                             // 3055
 **/                                                                                                                   // 3056
Deflate.prototype.onData = function(chunk) {                                                                           // 3057
  this.chunks.push(chunk);                                                                                             // 3058
};                                                                                                                     // 3059
                                                                                                                       // 3060
                                                                                                                       // 3061
/**                                                                                                                    // 3062
 * Deflate#onEnd(status) -> Void                                                                                       // 3063
 * - status (Number): deflate status. 0 (Z_OK) on success,                                                             // 3064
 *   other if not.                                                                                                     // 3065
 *                                                                                                                     // 3066
 * Called once after you tell deflate that input stream complete                                                       // 3067
 * or error happenned. By default - join collected chunks,                                                             // 3068
 * free memory and fill `results` / `err` properties.                                                                  // 3069
 **/                                                                                                                   // 3070
Deflate.prototype.onEnd = function(status) {                                                                           // 3071
  // On success - join                                                                                                 // 3072
  if (status === Z_OK) {                                                                                               // 3073
    if (this.options.to === 'string') {                                                                                // 3074
      this.result = this.chunks.join('');                                                                              // 3075
    } else {                                                                                                           // 3076
      this.result = utils.flattenChunks(this.chunks);                                                                  // 3077
    }                                                                                                                  // 3078
  }                                                                                                                    // 3079
  this.chunks = [];                                                                                                    // 3080
  this.err = status;                                                                                                   // 3081
  this.msg = this.strm.msg;                                                                                            // 3082
};                                                                                                                     // 3083
                                                                                                                       // 3084
                                                                                                                       // 3085
/**                                                                                                                    // 3086
 * deflate(data[, options]) -> Uint8Array|Array|String                                                                 // 3087
 * - data (Uint8Array|Array|String): input data to compress.                                                           // 3088
 * - options (Object): zlib deflate options.                                                                           // 3089
 *                                                                                                                     // 3090
 * Compress `data` with deflate alrorythm and `options`.                                                               // 3091
 *                                                                                                                     // 3092
 * Supported options are:                                                                                              // 3093
 *                                                                                                                     // 3094
 * - level                                                                                                             // 3095
 * - windowBits                                                                                                        // 3096
 * - memLevel                                                                                                          // 3097
 * - strategy                                                                                                          // 3098
 *                                                                                                                     // 3099
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)                                        // 3100
 * for more information on these.                                                                                      // 3101
 *                                                                                                                     // 3102
 * Sugar (options):                                                                                                    // 3103
 *                                                                                                                     // 3104
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify                                  // 3105
 *   negative windowBits implicitly.                                                                                   // 3106
 * - `to` (String) - if equal to 'string', then result will be "binary string"                                         // 3107
 *    (each char code [0..255])                                                                                        // 3108
 *                                                                                                                     // 3109
 * ##### Example:                                                                                                      // 3110
 *                                                                                                                     // 3111
 * ```javascript                                                                                                       // 3112
 * var pako = require('pako')                                                                                          // 3113
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);                                                                         // 3114
 *                                                                                                                     // 3115
 * console.log(pako.deflate(data));                                                                                    // 3116
 * ```                                                                                                                 // 3117
 **/                                                                                                                   // 3118
function deflate(input, options) {                                                                                     // 3119
  var deflator = new Deflate(options);                                                                                 // 3120
                                                                                                                       // 3121
  deflator.push(input, true);                                                                                          // 3122
                                                                                                                       // 3123
  // That will never happens, if you don't cheat with options :)                                                       // 3124
  if (deflator.err) { throw deflator.msg; }                                                                            // 3125
                                                                                                                       // 3126
  return deflator.result;                                                                                              // 3127
}                                                                                                                      // 3128
                                                                                                                       // 3129
                                                                                                                       // 3130
/**                                                                                                                    // 3131
 * deflateRaw(data[, options]) -> Uint8Array|Array|String                                                              // 3132
 * - data (Uint8Array|Array|String): input data to compress.                                                           // 3133
 * - options (Object): zlib deflate options.                                                                           // 3134
 *                                                                                                                     // 3135
 * The same as [[deflate]], but creates raw data, without wrapper                                                      // 3136
 * (header and adler32 crc).                                                                                           // 3137
 **/                                                                                                                   // 3138
function deflateRaw(input, options) {                                                                                  // 3139
  options = options || {};                                                                                             // 3140
  options.raw = true;                                                                                                  // 3141
  return deflate(input, options);                                                                                      // 3142
}                                                                                                                      // 3143
                                                                                                                       // 3144
                                                                                                                       // 3145
/**                                                                                                                    // 3146
 * gzip(data[, options]) -> Uint8Array|Array|String                                                                    // 3147
 * - data (Uint8Array|Array|String): input data to compress.                                                           // 3148
 * - options (Object): zlib deflate options.                                                                           // 3149
 *                                                                                                                     // 3150
 * The same as [[deflate]], but create gzip wrapper instead of                                                         // 3151
 * deflate one.                                                                                                        // 3152
 **/                                                                                                                   // 3153
function gzip(input, options) {                                                                                        // 3154
  options = options || {};                                                                                             // 3155
  options.gzip = true;                                                                                                 // 3156
  return deflate(input, options);                                                                                      // 3157
}                                                                                                                      // 3158
                                                                                                                       // 3159
                                                                                                                       // 3160
exports.Deflate = Deflate;                                                                                             // 3161
exports.deflate = deflate;                                                                                             // 3162
exports.deflateRaw = deflateRaw;                                                                                       // 3163
exports.gzip = gzip;                                                                                                   // 3164
},{"./utils/common":27,"./utils/strings":28,"./zlib/deflate.js":32,"./zlib/messages":37,"./zlib/zstream":39}],26:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 3166
                                                                                                                       // 3167
                                                                                                                       // 3168
var zlib_inflate = _dereq_('./zlib/inflate.js');                                                                       // 3169
var utils = _dereq_('./utils/common');                                                                                 // 3170
var strings = _dereq_('./utils/strings');                                                                              // 3171
var c = _dereq_('./zlib/constants');                                                                                   // 3172
var msg = _dereq_('./zlib/messages');                                                                                  // 3173
var zstream = _dereq_('./zlib/zstream');                                                                               // 3174
var gzheader = _dereq_('./zlib/gzheader');                                                                             // 3175
                                                                                                                       // 3176
                                                                                                                       // 3177
/**                                                                                                                    // 3178
 * class Inflate                                                                                                       // 3179
 *                                                                                                                     // 3180
 * Generic JS-style wrapper for zlib calls. If you don't need                                                          // 3181
 * streaming behaviour - use more simple functions: [[inflate]]                                                        // 3182
 * and [[inflateRaw]].                                                                                                 // 3183
 **/                                                                                                                   // 3184
                                                                                                                       // 3185
/* internal                                                                                                            // 3186
 * inflate.chunks -> Array                                                                                             // 3187
 *                                                                                                                     // 3188
 * Chunks of output data, if [[Inflate#onData]] not overriden.                                                         // 3189
 **/                                                                                                                   // 3190
                                                                                                                       // 3191
/**                                                                                                                    // 3192
 * Inflate.result -> Uint8Array|Array|String                                                                           // 3193
 *                                                                                                                     // 3194
 * Uncompressed result, generated by default [[Inflate#onData]]                                                        // 3195
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk                                                    // 3196
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param).                                                             // 3197
 **/                                                                                                                   // 3198
                                                                                                                       // 3199
/**                                                                                                                    // 3200
 * Inflate.err -> Number                                                                                               // 3201
 *                                                                                                                     // 3202
 * Error code after inflate finished. 0 (Z_OK) on success.                                                             // 3203
 * Should be checked if broken data possible.                                                                          // 3204
 **/                                                                                                                   // 3205
                                                                                                                       // 3206
/**                                                                                                                    // 3207
 * Inflate.msg -> String                                                                                               // 3208
 *                                                                                                                     // 3209
 * Error message, if [[Inflate.err]] != 0                                                                              // 3210
 **/                                                                                                                   // 3211
                                                                                                                       // 3212
                                                                                                                       // 3213
/**                                                                                                                    // 3214
 * new Inflate(options)                                                                                                // 3215
 * - options (Object): zlib inflate options.                                                                           // 3216
 *                                                                                                                     // 3217
 * Creates new inflator instance with specified params. Throws exception                                               // 3218
 * on bad params. Supported options:                                                                                   // 3219
 *                                                                                                                     // 3220
 * - `windowBits`                                                                                                      // 3221
 *                                                                                                                     // 3222
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)                                        // 3223
 * for more information on these.                                                                                      // 3224
 *                                                                                                                     // 3225
 * Additional options, for internal needs:                                                                             // 3226
 *                                                                                                                     // 3227
 * - `chunkSize` - size of generated data chunks (16K by default)                                                      // 3228
 * - `raw` (Boolean) - do raw inflate                                                                                  // 3229
 * - `to` (String) - if equal to 'string', then result will be converted                                               // 3230
 *   from utf8 to utf16 (javascript) string. When string output requested,                                             // 3231
 *   chunk length can differ from `chunkSize`, depending on content.                                                   // 3232
 *                                                                                                                     // 3233
 * By default, when no options set, autodetect deflate/gzip data format via                                            // 3234
 * wrapper header.                                                                                                     // 3235
 *                                                                                                                     // 3236
 * ##### Example:                                                                                                      // 3237
 *                                                                                                                     // 3238
 * ```javascript                                                                                                       // 3239
 * var pako = require('pako')                                                                                          // 3240
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])                                                                        // 3241
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);                                                           // 3242
 *                                                                                                                     // 3243
 * var inflate = new pako.Inflate({ level: 3});                                                                        // 3244
 *                                                                                                                     // 3245
 * inflate.push(chunk1, false);                                                                                        // 3246
 * inflate.push(chunk2, true);  // true -> last chunk                                                                  // 3247
 *                                                                                                                     // 3248
 * if (inflate.err) { throw new Error(inflate.err); }                                                                  // 3249
 *                                                                                                                     // 3250
 * console.log(inflate.result);                                                                                        // 3251
 * ```                                                                                                                 // 3252
 **/                                                                                                                   // 3253
var Inflate = function(options) {                                                                                      // 3254
                                                                                                                       // 3255
  this.options = utils.assign({                                                                                        // 3256
    chunkSize: 16384,                                                                                                  // 3257
    windowBits: 0,                                                                                                     // 3258
    to: ''                                                                                                             // 3259
  }, options || {});                                                                                                   // 3260
                                                                                                                       // 3261
  var opt = this.options;                                                                                              // 3262
                                                                                                                       // 3263
  // Force window size for `raw` data, if not set directly,                                                            // 3264
  // because we have no header for autodetect.                                                                         // 3265
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {                                                     // 3266
    opt.windowBits = -opt.windowBits;                                                                                  // 3267
    if (opt.windowBits === 0) { opt.windowBits = -15; }                                                                // 3268
  }                                                                                                                    // 3269
                                                                                                                       // 3270
  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate                             // 3271
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&                                                                // 3272
      !(options && options.windowBits)) {                                                                              // 3273
    opt.windowBits += 32;                                                                                              // 3274
  }                                                                                                                    // 3275
                                                                                                                       // 3276
  // Gzip header has no info about windows size, we can do autodetect only                                             // 3277
  // for deflate. So, if window size not set, force it to max when gzip possible                                       // 3278
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {                                                                // 3279
    // bit 3 (16) -> gzipped data                                                                                      // 3280
    // bit 4 (32) -> autodetect gzip/deflate                                                                           // 3281
    if ((opt.windowBits & 15) === 0) {                                                                                 // 3282
      opt.windowBits |= 15;                                                                                            // 3283
    }                                                                                                                  // 3284
  }                                                                                                                    // 3285
                                                                                                                       // 3286
  this.err    = 0;      // error code, if happens (0 = Z_OK)                                                           // 3287
  this.msg    = '';     // error message                                                                               // 3288
  this.ended  = false;  // used to avoid multiple onEnd() calls                                                        // 3289
  this.chunks = [];     // chunks of compressed data                                                                   // 3290
                                                                                                                       // 3291
  this.strm   = new zstream();                                                                                         // 3292
  this.strm.avail_out = 0;                                                                                             // 3293
                                                                                                                       // 3294
  var status  = zlib_inflate.inflateInit2(                                                                             // 3295
    this.strm,                                                                                                         // 3296
    opt.windowBits                                                                                                     // 3297
  );                                                                                                                   // 3298
                                                                                                                       // 3299
  if (status !== c.Z_OK) {                                                                                             // 3300
    throw new Error(msg[status]);                                                                                      // 3301
  }                                                                                                                    // 3302
                                                                                                                       // 3303
  this.header = new gzheader();                                                                                        // 3304
                                                                                                                       // 3305
  zlib_inflate.inflateGetHeader(this.strm, this.header);                                                               // 3306
};                                                                                                                     // 3307
                                                                                                                       // 3308
/**                                                                                                                    // 3309
 * Inflate#push(data[, mode]) -> Boolean                                                                               // 3310
 * - data (Uint8Array|Array|String): input data                                                                        // 3311
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.                                           // 3312
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.                                       // 3313
 *                                                                                                                     // 3314
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with                                          // 3315
 * new output chunks. Returns `true` on success. The last data block must have                                         // 3316
 * mode Z_FINISH (or `true`). That flush internal pending buffers and call                                             // 3317
 * [[Inflate#onEnd]].                                                                                                  // 3318
 *                                                                                                                     // 3319
 * On fail call [[Inflate#onEnd]] with error code and return false.                                                    // 3320
 *                                                                                                                     // 3321
 * We strongly recommend to use `Uint8Array` on input for best speed (output                                           // 3322
 * format is detected automatically). Also, don't skip last param and always                                           // 3323
 * use the same type in your code (boolean or number). That will improve JS speed.                                     // 3324
 *                                                                                                                     // 3325
 * For regular `Array`-s make sure all elements are [0..255].                                                          // 3326
 *                                                                                                                     // 3327
 * ##### Example                                                                                                       // 3328
 *                                                                                                                     // 3329
 * ```javascript                                                                                                       // 3330
 * push(chunk, false); // push one of data chunks                                                                      // 3331
 * ...                                                                                                                 // 3332
 * push(chunk, true);  // push last chunk                                                                              // 3333
 * ```                                                                                                                 // 3334
 **/                                                                                                                   // 3335
Inflate.prototype.push = function(data, mode) {                                                                        // 3336
  var strm = this.strm;                                                                                                // 3337
  var chunkSize = this.options.chunkSize;                                                                              // 3338
  var status, _mode;                                                                                                   // 3339
  var next_out_utf8, tail, utf8str;                                                                                    // 3340
                                                                                                                       // 3341
  if (this.ended) { return false; }                                                                                    // 3342
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);                                    // 3343
                                                                                                                       // 3344
  // Convert data if needed                                                                                            // 3345
  if (typeof data === 'string') {                                                                                      // 3346
    // Only binary strings can be decompressed on practice                                                             // 3347
    strm.input = strings.binstring2buf(data);                                                                          // 3348
  } else {                                                                                                             // 3349
    strm.input = data;                                                                                                 // 3350
  }                                                                                                                    // 3351
                                                                                                                       // 3352
  strm.next_in = 0;                                                                                                    // 3353
  strm.avail_in = strm.input.length;                                                                                   // 3354
                                                                                                                       // 3355
  do {                                                                                                                 // 3356
    if (strm.avail_out === 0) {                                                                                        // 3357
      strm.output = new utils.Buf8(chunkSize);                                                                         // 3358
      strm.next_out = 0;                                                                                               // 3359
      strm.avail_out = chunkSize;                                                                                      // 3360
    }                                                                                                                  // 3361
                                                                                                                       // 3362
    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */                                    // 3363
                                                                                                                       // 3364
    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {                                                              // 3365
      this.onEnd(status);                                                                                              // 3366
      this.ended = true;                                                                                               // 3367
      return false;                                                                                                    // 3368
    }                                                                                                                  // 3369
                                                                                                                       // 3370
    if (strm.next_out) {                                                                                               // 3371
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && _mode === c.Z_FINISH)) {        // 3372
                                                                                                                       // 3373
        if (this.options.to === 'string') {                                                                            // 3374
                                                                                                                       // 3375
          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);                                              // 3376
                                                                                                                       // 3377
          tail = strm.next_out - next_out_utf8;                                                                        // 3378
          utf8str = strings.buf2string(strm.output, next_out_utf8);                                                    // 3379
                                                                                                                       // 3380
          // move tail                                                                                                 // 3381
          strm.next_out = tail;                                                                                        // 3382
          strm.avail_out = chunkSize - tail;                                                                           // 3383
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }                              // 3384
                                                                                                                       // 3385
          this.onData(utf8str);                                                                                        // 3386
                                                                                                                       // 3387
        } else {                                                                                                       // 3388
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));                                                    // 3389
        }                                                                                                              // 3390
      }                                                                                                                // 3391
    }                                                                                                                  // 3392
  } while ((strm.avail_in > 0) && status !== c.Z_STREAM_END);                                                          // 3393
                                                                                                                       // 3394
  if (status === c.Z_STREAM_END) {                                                                                     // 3395
    _mode = c.Z_FINISH;                                                                                                // 3396
  }                                                                                                                    // 3397
  // Finalize on the last chunk.                                                                                       // 3398
  if (_mode === c.Z_FINISH) {                                                                                          // 3399
    status = zlib_inflate.inflateEnd(this.strm);                                                                       // 3400
    this.onEnd(status);                                                                                                // 3401
    this.ended = true;                                                                                                 // 3402
    return status === c.Z_OK;                                                                                          // 3403
  }                                                                                                                    // 3404
                                                                                                                       // 3405
  return true;                                                                                                         // 3406
};                                                                                                                     // 3407
                                                                                                                       // 3408
                                                                                                                       // 3409
/**                                                                                                                    // 3410
 * Inflate#onData(chunk) -> Void                                                                                       // 3411
 * - chunk (Uint8Array|Array|String): ouput data. Type of array depends                                                // 3412
 *   on js engine support. When string output requested, each chunk                                                    // 3413
 *   will be string.                                                                                                   // 3414
 *                                                                                                                     // 3415
 * By default, stores data blocks in `chunks[]` property and glue                                                      // 3416
 * those in `onEnd`. Override this handler, if you need another behaviour.                                             // 3417
 **/                                                                                                                   // 3418
Inflate.prototype.onData = function(chunk) {                                                                           // 3419
  this.chunks.push(chunk);                                                                                             // 3420
};                                                                                                                     // 3421
                                                                                                                       // 3422
                                                                                                                       // 3423
/**                                                                                                                    // 3424
 * Inflate#onEnd(status) -> Void                                                                                       // 3425
 * - status (Number): inflate status. 0 (Z_OK) on success,                                                             // 3426
 *   other if not.                                                                                                     // 3427
 *                                                                                                                     // 3428
 * Called once after you tell inflate that input stream complete                                                       // 3429
 * or error happenned. By default - join collected chunks,                                                             // 3430
 * free memory and fill `results` / `err` properties.                                                                  // 3431
 **/                                                                                                                   // 3432
Inflate.prototype.onEnd = function(status) {                                                                           // 3433
  // On success - join                                                                                                 // 3434
  if (status === c.Z_OK) {                                                                                             // 3435
    if (this.options.to === 'string') {                                                                                // 3436
      // Glue & convert here, until we teach pako to send                                                              // 3437
      // utf8 alligned strings to onData                                                                               // 3438
      this.result = this.chunks.join('');                                                                              // 3439
    } else {                                                                                                           // 3440
      this.result = utils.flattenChunks(this.chunks);                                                                  // 3441
    }                                                                                                                  // 3442
  }                                                                                                                    // 3443
  this.chunks = [];                                                                                                    // 3444
  this.err = status;                                                                                                   // 3445
  this.msg = this.strm.msg;                                                                                            // 3446
};                                                                                                                     // 3447
                                                                                                                       // 3448
                                                                                                                       // 3449
/**                                                                                                                    // 3450
 * inflate(data[, options]) -> Uint8Array|Array|String                                                                 // 3451
 * - data (Uint8Array|Array|String): input data to decompress.                                                         // 3452
 * - options (Object): zlib inflate options.                                                                           // 3453
 *                                                                                                                     // 3454
 * Decompress `data` with inflate/ungzip and `options`. Autodetect                                                     // 3455
 * format via wrapper header by default. That's why we don't provide                                                   // 3456
 * separate `ungzip` method.                                                                                           // 3457
 *                                                                                                                     // 3458
 * Supported options are:                                                                                              // 3459
 *                                                                                                                     // 3460
 * - windowBits                                                                                                        // 3461
 *                                                                                                                     // 3462
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)                                        // 3463
 * for more information.                                                                                               // 3464
 *                                                                                                                     // 3465
 * Sugar (options):                                                                                                    // 3466
 *                                                                                                                     // 3467
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify                                  // 3468
 *   negative windowBits implicitly.                                                                                   // 3469
 * - `to` (String) - if equal to 'string', then result will be converted                                               // 3470
 *   from utf8 to utf16 (javascript) string. When string output requested,                                             // 3471
 *   chunk length can differ from `chunkSize`, depending on content.                                                   // 3472
 *                                                                                                                     // 3473
 *                                                                                                                     // 3474
 * ##### Example:                                                                                                      // 3475
 *                                                                                                                     // 3476
 * ```javascript                                                                                                       // 3477
 * var pako = require('pako')                                                                                          // 3478
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])                                                                       // 3479
 *   , output;                                                                                                         // 3480
 *                                                                                                                     // 3481
 * try {                                                                                                               // 3482
 *   output = pako.inflate(input);                                                                                     // 3483
 * } catch (err)                                                                                                       // 3484
 *   console.log(err);                                                                                                 // 3485
 * }                                                                                                                   // 3486
 * ```                                                                                                                 // 3487
 **/                                                                                                                   // 3488
function inflate(input, options) {                                                                                     // 3489
  var inflator = new Inflate(options);                                                                                 // 3490
                                                                                                                       // 3491
  inflator.push(input, true);                                                                                          // 3492
                                                                                                                       // 3493
  // That will never happens, if you don't cheat with options :)                                                       // 3494
  if (inflator.err) { throw inflator.msg; }                                                                            // 3495
                                                                                                                       // 3496
  return inflator.result;                                                                                              // 3497
}                                                                                                                      // 3498
                                                                                                                       // 3499
                                                                                                                       // 3500
/**                                                                                                                    // 3501
 * inflateRaw(data[, options]) -> Uint8Array|Array|String                                                              // 3502
 * - data (Uint8Array|Array|String): input data to decompress.                                                         // 3503
 * - options (Object): zlib inflate options.                                                                           // 3504
 *                                                                                                                     // 3505
 * The same as [[inflate]], but creates raw data, without wrapper                                                      // 3506
 * (header and adler32 crc).                                                                                           // 3507
 **/                                                                                                                   // 3508
function inflateRaw(input, options) {                                                                                  // 3509
  options = options || {};                                                                                             // 3510
  options.raw = true;                                                                                                  // 3511
  return inflate(input, options);                                                                                      // 3512
}                                                                                                                      // 3513
                                                                                                                       // 3514
                                                                                                                       // 3515
/**                                                                                                                    // 3516
 * ungzip(data[, options]) -> Uint8Array|Array|String                                                                  // 3517
 * - data (Uint8Array|Array|String): input data to decompress.                                                         // 3518
 * - options (Object): zlib inflate options.                                                                           // 3519
 *                                                                                                                     // 3520
 * Just shortcut to [[inflate]], because it autodetects format                                                         // 3521
 * by header.content. Done for convenience.                                                                            // 3522
 **/                                                                                                                   // 3523
                                                                                                                       // 3524
                                                                                                                       // 3525
exports.Inflate = Inflate;                                                                                             // 3526
exports.inflate = inflate;                                                                                             // 3527
exports.inflateRaw = inflateRaw;                                                                                       // 3528
exports.ungzip  = inflate;                                                                                             // 3529
                                                                                                                       // 3530
},{"./utils/common":27,"./utils/strings":28,"./zlib/constants":30,"./zlib/gzheader":33,"./zlib/inflate.js":35,"./zlib/messages":37,"./zlib/zstream":39}],27:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 3532
                                                                                                                       // 3533
                                                                                                                       // 3534
var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&                                                                 // 3535
                (typeof Uint16Array !== 'undefined') &&                                                                // 3536
                (typeof Int32Array !== 'undefined');                                                                   // 3537
                                                                                                                       // 3538
                                                                                                                       // 3539
exports.assign = function (obj /*from1, from2, from3, ...*/) {                                                         // 3540
  var sources = Array.prototype.slice.call(arguments, 1);                                                              // 3541
  while (sources.length) {                                                                                             // 3542
    var source = sources.shift();                                                                                      // 3543
    if (!source) { continue; }                                                                                         // 3544
                                                                                                                       // 3545
    if (typeof(source) !== 'object') {                                                                                 // 3546
      throw new TypeError(source + 'must be non-object');                                                              // 3547
    }                                                                                                                  // 3548
                                                                                                                       // 3549
    for (var p in source) {                                                                                            // 3550
      if (source.hasOwnProperty(p)) {                                                                                  // 3551
        obj[p] = source[p];                                                                                            // 3552
      }                                                                                                                // 3553
    }                                                                                                                  // 3554
  }                                                                                                                    // 3555
                                                                                                                       // 3556
  return obj;                                                                                                          // 3557
};                                                                                                                     // 3558
                                                                                                                       // 3559
                                                                                                                       // 3560
// reduce buffer size, avoiding mem copy                                                                               // 3561
exports.shrinkBuf = function (buf, size) {                                                                             // 3562
  if (buf.length === size) { return buf; }                                                                             // 3563
  if (buf.subarray) { return buf.subarray(0, size); }                                                                  // 3564
  buf.length = size;                                                                                                   // 3565
  return buf;                                                                                                          // 3566
};                                                                                                                     // 3567
                                                                                                                       // 3568
                                                                                                                       // 3569
var fnTyped = {                                                                                                        // 3570
  arraySet: function (dest, src, src_offs, len, dest_offs) {                                                           // 3571
    if (src.subarray && dest.subarray) {                                                                               // 3572
      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);                                                       // 3573
      return;                                                                                                          // 3574
    }                                                                                                                  // 3575
    // Fallback to ordinary array                                                                                      // 3576
    for(var i=0; i<len; i++) {                                                                                         // 3577
      dest[dest_offs + i] = src[src_offs + i];                                                                         // 3578
    }                                                                                                                  // 3579
  },                                                                                                                   // 3580
  // Join array of chunks to single array.                                                                             // 3581
  flattenChunks: function(chunks) {                                                                                    // 3582
    var i, l, len, pos, chunk, result;                                                                                 // 3583
                                                                                                                       // 3584
    // calculate data length                                                                                           // 3585
    len = 0;                                                                                                           // 3586
    for (i=0, l=chunks.length; i<l; i++) {                                                                             // 3587
      len += chunks[i].length;                                                                                         // 3588
    }                                                                                                                  // 3589
                                                                                                                       // 3590
    // join chunks                                                                                                     // 3591
    result = new Uint8Array(len);                                                                                      // 3592
    pos = 0;                                                                                                           // 3593
    for (i=0, l=chunks.length; i<l; i++) {                                                                             // 3594
      chunk = chunks[i];                                                                                               // 3595
      result.set(chunk, pos);                                                                                          // 3596
      pos += chunk.length;                                                                                             // 3597
    }                                                                                                                  // 3598
                                                                                                                       // 3599
    return result;                                                                                                     // 3600
  }                                                                                                                    // 3601
};                                                                                                                     // 3602
                                                                                                                       // 3603
var fnUntyped = {                                                                                                      // 3604
  arraySet: function (dest, src, src_offs, len, dest_offs) {                                                           // 3605
    for(var i=0; i<len; i++) {                                                                                         // 3606
      dest[dest_offs + i] = src[src_offs + i];                                                                         // 3607
    }                                                                                                                  // 3608
  },                                                                                                                   // 3609
  // Join array of chunks to single array.                                                                             // 3610
  flattenChunks: function(chunks) {                                                                                    // 3611
    return [].concat.apply([], chunks);                                                                                // 3612
  }                                                                                                                    // 3613
};                                                                                                                     // 3614
                                                                                                                       // 3615
                                                                                                                       // 3616
// Enable/Disable typed arrays use, for testing                                                                        // 3617
//                                                                                                                     // 3618
exports.setTyped = function (on) {                                                                                     // 3619
  if (on) {                                                                                                            // 3620
    exports.Buf8  = Uint8Array;                                                                                        // 3621
    exports.Buf16 = Uint16Array;                                                                                       // 3622
    exports.Buf32 = Int32Array;                                                                                        // 3623
    exports.assign(exports, fnTyped);                                                                                  // 3624
  } else {                                                                                                             // 3625
    exports.Buf8  = Array;                                                                                             // 3626
    exports.Buf16 = Array;                                                                                             // 3627
    exports.Buf32 = Array;                                                                                             // 3628
    exports.assign(exports, fnUntyped);                                                                                // 3629
  }                                                                                                                    // 3630
};                                                                                                                     // 3631
                                                                                                                       // 3632
exports.setTyped(TYPED_OK);                                                                                            // 3633
},{}],28:[function(_dereq_,module,exports){                                                                            // 3634
// String encode/decode helpers                                                                                        // 3635
'use strict';                                                                                                          // 3636
                                                                                                                       // 3637
                                                                                                                       // 3638
var utils = _dereq_('./common');                                                                                       // 3639
                                                                                                                       // 3640
                                                                                                                       // 3641
// Quick check if we can use fast array to bin string conversion                                                       // 3642
//                                                                                                                     // 3643
// - apply(Array) can fail on Android 2.2                                                                              // 3644
// - apply(Uint8Array) can fail on iOS 5.1 Safary                                                                      // 3645
//                                                                                                                     // 3646
var STR_APPLY_OK = true;                                                                                               // 3647
var STR_APPLY_UIA_OK = true;                                                                                           // 3648
                                                                                                                       // 3649
try { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }                                      // 3650
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }                    // 3651
                                                                                                                       // 3652
                                                                                                                       // 3653
// Table with utf8 lengths (calculated by first byte of sequence)                                                      // 3654
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,                                   // 3655
// because max possible codepoint is 0x10ffff                                                                          // 3656
var _utf8len = new utils.Buf8(256);                                                                                    // 3657
for (var i=0; i<256; i++) {                                                                                            // 3658
  _utf8len[i] = (i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1);                        // 3659
}                                                                                                                      // 3660
_utf8len[254]=_utf8len[254]=1; // Invalid sequence start                                                               // 3661
                                                                                                                       // 3662
                                                                                                                       // 3663
// convert string to array (typed, when possible)                                                                      // 3664
exports.string2buf = function (str) {                                                                                  // 3665
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;                                                         // 3666
                                                                                                                       // 3667
  // count binary size                                                                                                 // 3668
  for (m_pos = 0; m_pos < str_len; m_pos++) {                                                                          // 3669
    c = str.charCodeAt(m_pos);                                                                                         // 3670
    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {                                                              // 3671
      c2 = str.charCodeAt(m_pos+1);                                                                                    // 3672
      if ((c2 & 0xfc00) === 0xdc00) {                                                                                  // 3673
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);                                                            // 3674
        m_pos++;                                                                                                       // 3675
      }                                                                                                                // 3676
    }                                                                                                                  // 3677
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;                                                     // 3678
  }                                                                                                                    // 3679
                                                                                                                       // 3680
  // allocate buffer                                                                                                   // 3681
  buf = new utils.Buf8(buf_len);                                                                                       // 3682
                                                                                                                       // 3683
  // convert                                                                                                           // 3684
  for (i=0, m_pos = 0; i < buf_len; m_pos++) {                                                                         // 3685
    c = str.charCodeAt(m_pos);                                                                                         // 3686
    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {                                                              // 3687
      c2 = str.charCodeAt(m_pos+1);                                                                                    // 3688
      if ((c2 & 0xfc00) === 0xdc00) {                                                                                  // 3689
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);                                                            // 3690
        m_pos++;                                                                                                       // 3691
      }                                                                                                                // 3692
    }                                                                                                                  // 3693
    if (c < 0x80) {                                                                                                    // 3694
      /* one byte */                                                                                                   // 3695
      buf[i++] = c;                                                                                                    // 3696
    } else if (c < 0x800) {                                                                                            // 3697
      /* two bytes */                                                                                                  // 3698
      buf[i++] = 0xC0 | (c >>> 6);                                                                                     // 3699
      buf[i++] = 0x80 | (c & 0x3f);                                                                                    // 3700
    } else if (c < 0x10000) {                                                                                          // 3701
      /* three bytes */                                                                                                // 3702
      buf[i++] = 0xE0 | (c >>> 12);                                                                                    // 3703
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);                                                                              // 3704
      buf[i++] = 0x80 | (c & 0x3f);                                                                                    // 3705
    } else {                                                                                                           // 3706
      /* four bytes */                                                                                                 // 3707
      buf[i++] = 0xf0 | (c >>> 18);                                                                                    // 3708
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);                                                                             // 3709
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);                                                                              // 3710
      buf[i++] = 0x80 | (c & 0x3f);                                                                                    // 3711
    }                                                                                                                  // 3712
  }                                                                                                                    // 3713
                                                                                                                       // 3714
  return buf;                                                                                                          // 3715
};                                                                                                                     // 3716
                                                                                                                       // 3717
// Helper (used in 2 places)                                                                                           // 3718
function buf2binstring(buf, len) {                                                                                     // 3719
  // use fallback for big arrays to avoid stack overflow                                                               // 3720
  if (len < 65537) {                                                                                                   // 3721
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {                                       // 3722
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));                                               // 3723
    }                                                                                                                  // 3724
  }                                                                                                                    // 3725
                                                                                                                       // 3726
  var result = '';                                                                                                     // 3727
  for(var i=0; i < len; i++) {                                                                                         // 3728
    result += String.fromCharCode(buf[i]);                                                                             // 3729
  }                                                                                                                    // 3730
  return result;                                                                                                       // 3731
}                                                                                                                      // 3732
                                                                                                                       // 3733
                                                                                                                       // 3734
// Convert byte array to binary string                                                                                 // 3735
exports.buf2binstring = function(buf) {                                                                                // 3736
  return buf2binstring(buf, buf.length);                                                                               // 3737
};                                                                                                                     // 3738
                                                                                                                       // 3739
                                                                                                                       // 3740
// Convert binary string (typed, when possible)                                                                        // 3741
exports.binstring2buf = function(str) {                                                                                // 3742
  var buf = new utils.Buf8(str.length);                                                                                // 3743
  for(var i=0, len=buf.length; i < len; i++) {                                                                         // 3744
    buf[i] = str.charCodeAt(i);                                                                                        // 3745
  }                                                                                                                    // 3746
  return buf;                                                                                                          // 3747
};                                                                                                                     // 3748
                                                                                                                       // 3749
                                                                                                                       // 3750
// convert array to string                                                                                             // 3751
exports.buf2string = function (buf, max) {                                                                             // 3752
  var i, out, c, c_len;                                                                                                // 3753
  var len = max || buf.length;                                                                                         // 3754
                                                                                                                       // 3755
  // Reserve max possible length (2 words per char)                                                                    // 3756
  // NB: by unknown reasons, Array is significantly faster for                                                         // 3757
  //     String.fromCharCode.apply than Uint16Array.                                                                   // 3758
  var utf16buf = new Array(len*2);                                                                                     // 3759
                                                                                                                       // 3760
  for (out=0, i=0; i<len;) {                                                                                           // 3761
    c = buf[i++];                                                                                                      // 3762
    // quick process ascii                                                                                             // 3763
    if (c < 0x80) { utf16buf[out++] = c; continue; }                                                                   // 3764
                                                                                                                       // 3765
    c_len = _utf8len[c];                                                                                               // 3766
    // skip 5 & 6 byte codes                                                                                           // 3767
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }                                               // 3768
                                                                                                                       // 3769
    // apply mask on first byte                                                                                        // 3770
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;                                                               // 3771
    // join the rest                                                                                                   // 3772
    while (c_len > 1 && i < len) {                                                                                     // 3773
      c = (c << 6) | (buf[i++] & 0x3f);                                                                                // 3774
      c_len--;                                                                                                         // 3775
    }                                                                                                                  // 3776
                                                                                                                       // 3777
    // terminated by end of string?                                                                                    // 3778
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }                                                             // 3779
                                                                                                                       // 3780
    if (c < 0x10000) {                                                                                                 // 3781
      utf16buf[out++] = c;                                                                                             // 3782
    } else {                                                                                                           // 3783
      c -= 0x10000;                                                                                                    // 3784
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);                                                                  // 3785
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);                                                                          // 3786
    }                                                                                                                  // 3787
  }                                                                                                                    // 3788
                                                                                                                       // 3789
  return buf2binstring(utf16buf, out);                                                                                 // 3790
};                                                                                                                     // 3791
                                                                                                                       // 3792
                                                                                                                       // 3793
// Calculate max possible position in utf8 buffer,                                                                     // 3794
// that will not break sequence. If that's not possible                                                                // 3795
// - (very small limits) return max size as is.                                                                        // 3796
//                                                                                                                     // 3797
// buf[] - utf8 bytes array                                                                                            // 3798
// max   - length limit (mandatory);                                                                                   // 3799
exports.utf8border = function(buf, max) {                                                                              // 3800
  var pos;                                                                                                             // 3801
                                                                                                                       // 3802
  max = max || buf.length;                                                                                             // 3803
  if (max > buf.length) { max = buf.length; }                                                                          // 3804
                                                                                                                       // 3805
  // go back from last position, until start of sequence found                                                         // 3806
  pos = max-1;                                                                                                         // 3807
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }                                                            // 3808
                                                                                                                       // 3809
  // Fuckup - very small and broken sequence,                                                                          // 3810
  // return max, because we should return something anyway.                                                            // 3811
  if (pos < 0) { return max; }                                                                                         // 3812
                                                                                                                       // 3813
  // If we came to start of buffer - that means vuffer is too small,                                                   // 3814
  // return max too.                                                                                                   // 3815
  if (pos === 0) { return max; }                                                                                       // 3816
                                                                                                                       // 3817
  return (pos + _utf8len[buf[pos]] > max) ? pos : max;                                                                 // 3818
};                                                                                                                     // 3819
                                                                                                                       // 3820
},{"./common":27}],29:[function(_dereq_,module,exports){                                                               // 3821
'use strict';                                                                                                          // 3822
                                                                                                                       // 3823
// Note: adler32 takes 12% for level 0 and 2% for level 6.                                                             // 3824
// It doesn't worth to make additional optimizationa as in original.                                                   // 3825
// Small size is preferable.                                                                                           // 3826
                                                                                                                       // 3827
function adler32(adler, buf, len, pos) {                                                                               // 3828
  var s1 = (adler & 0xffff) |0                                                                                         // 3829
    , s2 = ((adler >>> 16) & 0xffff) |0                                                                                // 3830
    , n = 0;                                                                                                           // 3831
                                                                                                                       // 3832
  while (len !== 0) {                                                                                                  // 3833
    // Set limit ~ twice less than 5552, to keep                                                                       // 3834
    // s2 in 31-bits, because we force signed ints.                                                                    // 3835
    // in other case %= will fail.                                                                                     // 3836
    n = len > 2000 ? 2000 : len;                                                                                       // 3837
    len -= n;                                                                                                          // 3838
                                                                                                                       // 3839
    do {                                                                                                               // 3840
      s1 = (s1 + buf[pos++]) |0;                                                                                       // 3841
      s2 = (s2 + s1) |0;                                                                                               // 3842
    } while (--n);                                                                                                     // 3843
                                                                                                                       // 3844
    s1 %= 65521;                                                                                                       // 3845
    s2 %= 65521;                                                                                                       // 3846
  }                                                                                                                    // 3847
                                                                                                                       // 3848
  return (s1 | (s2 << 16)) |0;                                                                                         // 3849
}                                                                                                                      // 3850
                                                                                                                       // 3851
                                                                                                                       // 3852
module.exports = adler32;                                                                                              // 3853
},{}],30:[function(_dereq_,module,exports){                                                                            // 3854
module.exports = {                                                                                                     // 3855
                                                                                                                       // 3856
  /* Allowed flush values; see deflate() and inflate() below for details */                                            // 3857
  Z_NO_FLUSH:         0,                                                                                               // 3858
  Z_PARTIAL_FLUSH:    1,                                                                                               // 3859
  Z_SYNC_FLUSH:       2,                                                                                               // 3860
  Z_FULL_FLUSH:       3,                                                                                               // 3861
  Z_FINISH:           4,                                                                                               // 3862
  Z_BLOCK:            5,                                                                                               // 3863
  Z_TREES:            6,                                                                                               // 3864
                                                                                                                       // 3865
  /* Return codes for the compression/decompression functions. Negative values                                         // 3866
  * are errors, positive values are used for special but normal events.                                                // 3867
  */                                                                                                                   // 3868
  Z_OK:               0,                                                                                               // 3869
  Z_STREAM_END:       1,                                                                                               // 3870
  Z_NEED_DICT:        2,                                                                                               // 3871
  Z_ERRNO:           -1,                                                                                               // 3872
  Z_STREAM_ERROR:    -2,                                                                                               // 3873
  Z_DATA_ERROR:      -3,                                                                                               // 3874
  //Z_MEM_ERROR:     -4,                                                                                               // 3875
  Z_BUF_ERROR:       -5,                                                                                               // 3876
  //Z_VERSION_ERROR: -6,                                                                                               // 3877
                                                                                                                       // 3878
  /* compression levels */                                                                                             // 3879
  Z_NO_COMPRESSION:         0,                                                                                         // 3880
  Z_BEST_SPEED:             1,                                                                                         // 3881
  Z_BEST_COMPRESSION:       9,                                                                                         // 3882
  Z_DEFAULT_COMPRESSION:   -1,                                                                                         // 3883
                                                                                                                       // 3884
                                                                                                                       // 3885
  Z_FILTERED:               1,                                                                                         // 3886
  Z_HUFFMAN_ONLY:           2,                                                                                         // 3887
  Z_RLE:                    3,                                                                                         // 3888
  Z_FIXED:                  4,                                                                                         // 3889
  Z_DEFAULT_STRATEGY:       0,                                                                                         // 3890
                                                                                                                       // 3891
  /* Possible values of the data_type field (though see inflate()) */                                                  // 3892
  Z_BINARY:                 0,                                                                                         // 3893
  Z_TEXT:                   1,                                                                                         // 3894
  //Z_ASCII:                1, // = Z_TEXT (deprecated)                                                                // 3895
  Z_UNKNOWN:                2,                                                                                         // 3896
                                                                                                                       // 3897
  /* The deflate compression method */                                                                                 // 3898
  Z_DEFLATED:               8                                                                                          // 3899
  //Z_NULL:                 null // Use -1 or null inline, depending on var type                                       // 3900
};                                                                                                                     // 3901
},{}],31:[function(_dereq_,module,exports){                                                                            // 3902
'use strict';                                                                                                          // 3903
                                                                                                                       // 3904
// Note: we can't get significant speed boost here.                                                                    // 3905
// So write code to minimize size - no pregenerated tables                                                             // 3906
// and array tools dependencies.                                                                                       // 3907
                                                                                                                       // 3908
                                                                                                                       // 3909
// Use ordinary array, since untyped makes no boost here                                                               // 3910
function makeTable() {                                                                                                 // 3911
  var c, table = [];                                                                                                   // 3912
                                                                                                                       // 3913
  for(var n =0; n < 256; n++){                                                                                         // 3914
    c = n;                                                                                                             // 3915
    for(var k =0; k < 8; k++){                                                                                         // 3916
      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));                                                              // 3917
    }                                                                                                                  // 3918
    table[n] = c;                                                                                                      // 3919
  }                                                                                                                    // 3920
                                                                                                                       // 3921
  return table;                                                                                                        // 3922
}                                                                                                                      // 3923
                                                                                                                       // 3924
// Create table on load. Just 255 signed longs. Not a problem.                                                         // 3925
var crcTable = makeTable();                                                                                            // 3926
                                                                                                                       // 3927
                                                                                                                       // 3928
function crc32(crc, buf, len, pos) {                                                                                   // 3929
  var t = crcTable                                                                                                     // 3930
    , end = pos + len;                                                                                                 // 3931
                                                                                                                       // 3932
  crc = crc ^ (-1);                                                                                                    // 3933
                                                                                                                       // 3934
  for (var i = pos; i < end; i++ ) {                                                                                   // 3935
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];                                                                      // 3936
  }                                                                                                                    // 3937
                                                                                                                       // 3938
  return (crc ^ (-1)); // >>> 0;                                                                                       // 3939
}                                                                                                                      // 3940
                                                                                                                       // 3941
                                                                                                                       // 3942
module.exports = crc32;                                                                                                // 3943
},{}],32:[function(_dereq_,module,exports){                                                                            // 3944
'use strict';                                                                                                          // 3945
                                                                                                                       // 3946
var utils   = _dereq_('../utils/common');                                                                              // 3947
var trees   = _dereq_('./trees');                                                                                      // 3948
var adler32 = _dereq_('./adler32');                                                                                    // 3949
var crc32   = _dereq_('./crc32');                                                                                      // 3950
var msg   = _dereq_('./messages');                                                                                     // 3951
                                                                                                                       // 3952
/* Public constants ==========================================================*/                                       // 3953
/* ===========================================================================*/                                       // 3954
                                                                                                                       // 3955
                                                                                                                       // 3956
/* Allowed flush values; see deflate() and inflate() below for details */                                              // 3957
var Z_NO_FLUSH      = 0;                                                                                               // 3958
var Z_PARTIAL_FLUSH = 1;                                                                                               // 3959
//var Z_SYNC_FLUSH    = 2;                                                                                             // 3960
var Z_FULL_FLUSH    = 3;                                                                                               // 3961
var Z_FINISH        = 4;                                                                                               // 3962
var Z_BLOCK         = 5;                                                                                               // 3963
//var Z_TREES         = 6;                                                                                             // 3964
                                                                                                                       // 3965
                                                                                                                       // 3966
/* Return codes for the compression/decompression functions. Negative values                                           // 3967
 * are errors, positive values are used for special but normal events.                                                 // 3968
 */                                                                                                                    // 3969
var Z_OK            = 0;                                                                                               // 3970
var Z_STREAM_END    = 1;                                                                                               // 3971
//var Z_NEED_DICT     = 2;                                                                                             // 3972
//var Z_ERRNO         = -1;                                                                                            // 3973
var Z_STREAM_ERROR  = -2;                                                                                              // 3974
var Z_DATA_ERROR    = -3;                                                                                              // 3975
//var Z_MEM_ERROR     = -4;                                                                                            // 3976
var Z_BUF_ERROR     = -5;                                                                                              // 3977
//var Z_VERSION_ERROR = -6;                                                                                            // 3978
                                                                                                                       // 3979
                                                                                                                       // 3980
/* compression levels */                                                                                               // 3981
//var Z_NO_COMPRESSION      = 0;                                                                                       // 3982
//var Z_BEST_SPEED          = 1;                                                                                       // 3983
//var Z_BEST_COMPRESSION    = 9;                                                                                       // 3984
var Z_DEFAULT_COMPRESSION = -1;                                                                                        // 3985
                                                                                                                       // 3986
                                                                                                                       // 3987
var Z_FILTERED            = 1;                                                                                         // 3988
var Z_HUFFMAN_ONLY        = 2;                                                                                         // 3989
var Z_RLE                 = 3;                                                                                         // 3990
var Z_FIXED               = 4;                                                                                         // 3991
var Z_DEFAULT_STRATEGY    = 0;                                                                                         // 3992
                                                                                                                       // 3993
/* Possible values of the data_type field (though see inflate()) */                                                    // 3994
//var Z_BINARY              = 0;                                                                                       // 3995
//var Z_TEXT                = 1;                                                                                       // 3996
//var Z_ASCII               = 1; // = Z_TEXT                                                                           // 3997
var Z_UNKNOWN             = 2;                                                                                         // 3998
                                                                                                                       // 3999
                                                                                                                       // 4000
/* The deflate compression method */                                                                                   // 4001
var Z_DEFLATED  = 8;                                                                                                   // 4002
                                                                                                                       // 4003
/*============================================================================*/                                       // 4004
                                                                                                                       // 4005
                                                                                                                       // 4006
var MAX_MEM_LEVEL = 9;                                                                                                 // 4007
/* Maximum value for memLevel in deflateInit2 */                                                                       // 4008
var MAX_WBITS = 15;                                                                                                    // 4009
/* 32K LZ77 window */                                                                                                  // 4010
var DEF_MEM_LEVEL = 8;                                                                                                 // 4011
                                                                                                                       // 4012
                                                                                                                       // 4013
var LENGTH_CODES  = 29;                                                                                                // 4014
/* number of length codes, not counting the special END_BLOCK code */                                                  // 4015
var LITERALS      = 256;                                                                                               // 4016
/* number of literal bytes 0..255 */                                                                                   // 4017
var L_CODES       = LITERALS + 1 + LENGTH_CODES;                                                                       // 4018
/* number of Literal or Length codes, including the END_BLOCK code */                                                  // 4019
var D_CODES       = 30;                                                                                                // 4020
/* number of distance codes */                                                                                         // 4021
var BL_CODES      = 19;                                                                                                // 4022
/* number of codes used to transfer the bit lengths */                                                                 // 4023
var HEAP_SIZE     = 2*L_CODES + 1;                                                                                     // 4024
/* maximum heap size */                                                                                                // 4025
var MAX_BITS  = 15;                                                                                                    // 4026
/* All codes must not exceed MAX_BITS bits */                                                                          // 4027
                                                                                                                       // 4028
var MIN_MATCH = 3;                                                                                                     // 4029
var MAX_MATCH = 258;                                                                                                   // 4030
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);                                                                       // 4031
                                                                                                                       // 4032
var PRESET_DICT = 0x20;                                                                                                // 4033
                                                                                                                       // 4034
var INIT_STATE = 42;                                                                                                   // 4035
var EXTRA_STATE = 69;                                                                                                  // 4036
var NAME_STATE = 73;                                                                                                   // 4037
var COMMENT_STATE = 91;                                                                                                // 4038
var HCRC_STATE = 103;                                                                                                  // 4039
var BUSY_STATE = 113;                                                                                                  // 4040
var FINISH_STATE = 666;                                                                                                // 4041
                                                                                                                       // 4042
var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */                                   // 4043
var BS_BLOCK_DONE     = 2; /* block flush performed */                                                                 // 4044
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */                                 // 4045
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */                                           // 4046
                                                                                                                       // 4047
var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.                                                       // 4048
                                                                                                                       // 4049
function err(strm, errorCode) {                                                                                        // 4050
  strm.msg = msg[errorCode];                                                                                           // 4051
  return errorCode;                                                                                                    // 4052
}                                                                                                                      // 4053
                                                                                                                       // 4054
function rank(f) {                                                                                                     // 4055
  return ((f) << 1) - ((f) > 4 ? 9 : 0);                                                                               // 4056
}                                                                                                                      // 4057
                                                                                                                       // 4058
function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }                                      // 4059
                                                                                                                       // 4060
                                                                                                                       // 4061
/* =========================================================================                                           // 4062
 * Flush as much pending output as possible. All deflate() output goes                                                 // 4063
 * through this function so some applications may wish to modify it                                                    // 4064
 * to avoid allocating a large strm->output buffer and copying into it.                                                // 4065
 * (See also read_buf()).                                                                                              // 4066
 */                                                                                                                    // 4067
function flush_pending(strm) {                                                                                         // 4068
  var s = strm.state;                                                                                                  // 4069
                                                                                                                       // 4070
  //_tr_flush_bits(s);                                                                                                 // 4071
  var len = s.pending;                                                                                                 // 4072
  if (len > strm.avail_out) {                                                                                          // 4073
    len = strm.avail_out;                                                                                              // 4074
  }                                                                                                                    // 4075
  if (len === 0) { return; }                                                                                           // 4076
                                                                                                                       // 4077
  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);                                       // 4078
  strm.next_out += len;                                                                                                // 4079
  s.pending_out += len;                                                                                                // 4080
  strm.total_out += len;                                                                                               // 4081
  strm.avail_out -= len;                                                                                               // 4082
  s.pending -= len;                                                                                                    // 4083
  if (s.pending === 0) {                                                                                               // 4084
    s.pending_out = 0;                                                                                                 // 4085
  }                                                                                                                    // 4086
}                                                                                                                      // 4087
                                                                                                                       // 4088
                                                                                                                       // 4089
function flush_block_only (s, last) {                                                                                  // 4090
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);               // 4091
  s.block_start = s.strstart;                                                                                          // 4092
  flush_pending(s.strm);                                                                                               // 4093
}                                                                                                                      // 4094
                                                                                                                       // 4095
                                                                                                                       // 4096
function put_byte(s, b) {                                                                                              // 4097
  s.pending_buf[s.pending++] = b;                                                                                      // 4098
}                                                                                                                      // 4099
                                                                                                                       // 4100
                                                                                                                       // 4101
/* =========================================================================                                           // 4102
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.                                            // 4103
 * IN assertion: the stream state is correct and there is enough room in                                               // 4104
 * pending_buf.                                                                                                        // 4105
 */                                                                                                                    // 4106
function putShortMSB(s, b) {                                                                                           // 4107
//  put_byte(s, (Byte)(b >> 8));                                                                                       // 4108
//  put_byte(s, (Byte)(b & 0xff));                                                                                     // 4109
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;                                                                       // 4110
  s.pending_buf[s.pending++] = b & 0xff;                                                                               // 4111
}                                                                                                                      // 4112
                                                                                                                       // 4113
                                                                                                                       // 4114
/* ===========================================================================                                         // 4115
 * Read a new buffer from the current input stream, update the adler32                                                 // 4116
 * and total number of bytes read.  All deflate() input goes through                                                   // 4117
 * this function so some applications may wish to modify it to avoid                                                   // 4118
 * allocating a large strm->input buffer and copying from it.                                                          // 4119
 * (See also flush_pending()).                                                                                         // 4120
 */                                                                                                                    // 4121
function read_buf(strm, buf, start, size) {                                                                            // 4122
  var len = strm.avail_in;                                                                                             // 4123
                                                                                                                       // 4124
  if (len > size) { len = size; }                                                                                      // 4125
  if (len === 0) { return 0; }                                                                                         // 4126
                                                                                                                       // 4127
  strm.avail_in -= len;                                                                                                // 4128
                                                                                                                       // 4129
  utils.arraySet(buf, strm.input, strm.next_in, len, start);                                                           // 4130
  if (strm.state.wrap === 1) {                                                                                         // 4131
    strm.adler = adler32(strm.adler, buf, len, start);                                                                 // 4132
  }                                                                                                                    // 4133
                                                                                                                       // 4134
  else if (strm.state.wrap === 2) {                                                                                    // 4135
    strm.adler = crc32(strm.adler, buf, len, start);                                                                   // 4136
  }                                                                                                                    // 4137
                                                                                                                       // 4138
  strm.next_in += len;                                                                                                 // 4139
  strm.total_in += len;                                                                                                // 4140
                                                                                                                       // 4141
  return len;                                                                                                          // 4142
}                                                                                                                      // 4143
                                                                                                                       // 4144
                                                                                                                       // 4145
/* ===========================================================================                                         // 4146
 * Set match_start to the longest match starting at the given string and                                               // 4147
 * return its length. Matches shorter or equal to prev_length are discarded,                                           // 4148
 * in which case the result is equal to prev_length and match_start is                                                 // 4149
 * garbage.                                                                                                            // 4150
 * IN assertions: cur_match is the head of the hash chain for the current                                              // 4151
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1                                           // 4152
 * OUT assertion: the match length is not greater than s->lookahead.                                                   // 4153
 */                                                                                                                    // 4154
function longest_match(s, cur_match) {                                                                                 // 4155
  var chain_length = s.max_chain_length;      /* max hash chain length */                                              // 4156
  var scan = s.strstart; /* current string */                                                                          // 4157
  var match;                       /* matched string */                                                                // 4158
  var len;                           /* length of current match */                                                     // 4159
  var best_len = s.prev_length;              /* best match length so far */                                            // 4160
  var nice_match = s.nice_match;             /* stop if match long enough */                                           // 4161
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?                                                              // 4162
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;                                                              // 4163
                                                                                                                       // 4164
  var _win = s.window; // shortcut                                                                                     // 4165
                                                                                                                       // 4166
  var wmask = s.w_mask;                                                                                                // 4167
  var prev  = s.prev;                                                                                                  // 4168
                                                                                                                       // 4169
  /* Stop when cur_match becomes <= limit. To simplify the code,                                                       // 4170
   * we prevent matches with the string of window index 0.                                                             // 4171
   */                                                                                                                  // 4172
                                                                                                                       // 4173
  var strend = s.strstart + MAX_MATCH;                                                                                 // 4174
  var scan_end1  = _win[scan + best_len - 1];                                                                          // 4175
  var scan_end   = _win[scan + best_len];                                                                              // 4176
                                                                                                                       // 4177
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.                                          // 4178
   * It is easy to get rid of this optimization if necessary.                                                          // 4179
   */                                                                                                                  // 4180
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");                                                 // 4181
                                                                                                                       // 4182
  /* Do not waste too much time if we already have a good match: */                                                    // 4183
  if (s.prev_length >= s.good_match) {                                                                                 // 4184
    chain_length >>= 2;                                                                                                // 4185
  }                                                                                                                    // 4186
  /* Do not look for matches beyond the end of the input. This is necessary                                            // 4187
   * to make deflate deterministic.                                                                                    // 4188
   */                                                                                                                  // 4189
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }                                                          // 4190
                                                                                                                       // 4191
  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");                                       // 4192
                                                                                                                       // 4193
  do {                                                                                                                 // 4194
    // Assert(cur_match < s->strstart, "no future");                                                                   // 4195
    match = cur_match;                                                                                                 // 4196
                                                                                                                       // 4197
    /* Skip to next match if the match length cannot increase                                                          // 4198
     * or if the match length is less than 2.  Note that the checks below                                              // 4199
     * for insufficient lookahead only occur occasionally for performance                                              // 4200
     * reasons.  Therefore uninitialized memory will be accessed, and                                                  // 4201
     * conditional jumps will be made that depend on those values.                                                     // 4202
     * However the length of the match is limited to the lookahead, so                                                 // 4203
     * the output of deflate is not affected by the uninitialized values.                                              // 4204
     */                                                                                                                // 4205
                                                                                                                       // 4206
    if (_win[match + best_len]     !== scan_end  ||                                                                    // 4207
        _win[match + best_len - 1] !== scan_end1 ||                                                                    // 4208
        _win[match]                !== _win[scan] ||                                                                   // 4209
        _win[++match]              !== _win[scan + 1]) {                                                               // 4210
      continue;                                                                                                        // 4211
    }                                                                                                                  // 4212
                                                                                                                       // 4213
    /* The check at best_len-1 can be removed because it will be made                                                  // 4214
     * again later. (This heuristic is not always a win.)                                                              // 4215
     * It is not necessary to compare scan[2] and match[2] since they                                                  // 4216
     * are always equal when the other bytes match, given that                                                         // 4217
     * the hash keys are equal and that HASH_BITS >= 8.                                                                // 4218
     */                                                                                                                // 4219
    scan += 2;                                                                                                         // 4220
    match++;                                                                                                           // 4221
    // Assert(*scan == *match, "match[2]?");                                                                           // 4222
                                                                                                                       // 4223
    /* We check for insufficient lookahead only every 8th comparison;                                                  // 4224
     * the 256th check will be made at strstart+258.                                                                   // 4225
     */                                                                                                                // 4226
    do {                                                                                                               // 4227
      /*jshint noempty:false*/                                                                                         // 4228
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&                                       // 4229
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&                                       // 4230
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&                                       // 4231
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&                                       // 4232
             scan < strend);                                                                                           // 4233
                                                                                                                       // 4234
    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");                                            // 4235
                                                                                                                       // 4236
    len = MAX_MATCH - (strend - scan);                                                                                 // 4237
    scan = strend - MAX_MATCH;                                                                                         // 4238
                                                                                                                       // 4239
    if (len > best_len) {                                                                                              // 4240
      s.match_start = cur_match;                                                                                       // 4241
      best_len = len;                                                                                                  // 4242
      if (len >= nice_match) {                                                                                         // 4243
        break;                                                                                                         // 4244
      }                                                                                                                // 4245
      scan_end1  = _win[scan + best_len - 1];                                                                          // 4246
      scan_end   = _win[scan + best_len];                                                                              // 4247
    }                                                                                                                  // 4248
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);                                     // 4249
                                                                                                                       // 4250
  if (best_len <= s.lookahead) {                                                                                       // 4251
    return best_len;                                                                                                   // 4252
  }                                                                                                                    // 4253
  return s.lookahead;                                                                                                  // 4254
}                                                                                                                      // 4255
                                                                                                                       // 4256
                                                                                                                       // 4257
/* ===========================================================================                                         // 4258
 * Fill the window when the lookahead becomes insufficient.                                                            // 4259
 * Updates strstart and lookahead.                                                                                     // 4260
 *                                                                                                                     // 4261
 * IN assertion: lookahead < MIN_LOOKAHEAD                                                                             // 4262
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD                                                               // 4263
 *    At least one byte has been read, or avail_in == 0; reads are                                                     // 4264
 *    performed for at least two bytes (required for the zip translate_eol                                             // 4265
 *    option -- not supported here).                                                                                   // 4266
 */                                                                                                                    // 4267
function fill_window(s) {                                                                                              // 4268
  var _w_size = s.w_size;                                                                                              // 4269
  var p, n, m, more, str;                                                                                              // 4270
                                                                                                                       // 4271
  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");                                                  // 4272
                                                                                                                       // 4273
  do {                                                                                                                 // 4274
    more = s.window_size - s.lookahead - s.strstart;                                                                   // 4275
                                                                                                                       // 4276
    // JS ints have 32 bit, block below not needed                                                                     // 4277
    /* Deal with !@#$% 64K limit: */                                                                                   // 4278
    //if (sizeof(int) <= 2) {                                                                                          // 4279
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {                                                    // 4280
    //        more = wsize;                                                                                            // 4281
    //                                                                                                                 // 4282
    //  } else if (more == (unsigned)(-1)) {                                                                           // 4283
    //        /* Very unlikely, but possible on 16 bit machine if                                                      // 4284
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)                                           // 4285
    //         */                                                                                                      // 4286
    //        more--;                                                                                                  // 4287
    //    }                                                                                                            // 4288
    //}                                                                                                                // 4289
                                                                                                                       // 4290
                                                                                                                       // 4291
    /* If the window is almost full and there is insufficient lookahead,                                               // 4292
     * move the upper half to the lower one to make room in the upper half.                                            // 4293
     */                                                                                                                // 4294
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {                                                           // 4295
                                                                                                                       // 4296
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);                                                         // 4297
      s.match_start -= _w_size;                                                                                        // 4298
      s.strstart -= _w_size;                                                                                           // 4299
      /* we now have strstart >= MAX_DIST */                                                                           // 4300
      s.block_start -= _w_size;                                                                                        // 4301
                                                                                                                       // 4302
      /* Slide the hash table (could be avoided with 32 bit values                                                     // 4303
       at the expense of memory usage). We slide even when level == 0                                                  // 4304
       to keep the hash table consistent if we switch back to level > 0                                                // 4305
       later. (Using level 0 permanently is not an optimal usage of                                                    // 4306
       zlib, so we don't care about this pathological case.)                                                           // 4307
       */                                                                                                              // 4308
                                                                                                                       // 4309
      n = s.hash_size;                                                                                                 // 4310
      p = n;                                                                                                           // 4311
      do {                                                                                                             // 4312
        m = s.head[--p];                                                                                               // 4313
        s.head[p] = (m >= _w_size ? m - _w_size : 0);                                                                  // 4314
      } while (--n);                                                                                                   // 4315
                                                                                                                       // 4316
      n = _w_size;                                                                                                     // 4317
      p = n;                                                                                                           // 4318
      do {                                                                                                             // 4319
        m = s.prev[--p];                                                                                               // 4320
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);                                                                  // 4321
        /* If n is not on any hash chain, prev[n] is garbage but                                                       // 4322
         * its value will never be used.                                                                               // 4323
         */                                                                                                            // 4324
      } while (--n);                                                                                                   // 4325
                                                                                                                       // 4326
      more += _w_size;                                                                                                 // 4327
    }                                                                                                                  // 4328
    if (s.strm.avail_in === 0) {                                                                                       // 4329
      break;                                                                                                           // 4330
    }                                                                                                                  // 4331
                                                                                                                       // 4332
    /* If there was no sliding:                                                                                        // 4333
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&                                            // 4334
     *    more == window_size - lookahead - strstart                                                                   // 4335
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)                                                 // 4336
     * => more >= window_size - 2*WSIZE + 2                                                                            // 4337
     * In the BIG_MEM or MMAP case (not yet supported),                                                                // 4338
     *   window_size == input_size + MIN_LOOKAHEAD  &&                                                                 // 4339
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.                                               // 4340
     * Otherwise, window_size == 2*WSIZE so more >= 2.                                                                 // 4341
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.                                                // 4342
     */                                                                                                                // 4343
    //Assert(more >= 2, "more < 2");                                                                                   // 4344
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);                                                    // 4345
    s.lookahead += n;                                                                                                  // 4346
                                                                                                                       // 4347
    /* Initialize the hash value now that we have some input: */                                                       // 4348
    if (s.lookahead + s.insert >= MIN_MATCH) {                                                                         // 4349
      str = s.strstart - s.insert;                                                                                     // 4350
      s.ins_h = s.window[str];                                                                                         // 4351
                                                                                                                       // 4352
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */                                                              // 4353
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;                                         // 4354
//#if MIN_MATCH != 3                                                                                                   // 4355
//        Call update_hash() MIN_MATCH-3 more times                                                                    // 4356
//#endif                                                                                                               // 4357
      while (s.insert) {                                                                                               // 4358
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */                                                  // 4359
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;                             // 4360
                                                                                                                       // 4361
        s.prev[str & s.w_mask] = s.head[s.ins_h];                                                                      // 4362
        s.head[s.ins_h] = str;                                                                                         // 4363
        str++;                                                                                                         // 4364
        s.insert--;                                                                                                    // 4365
        if (s.lookahead + s.insert < MIN_MATCH) {                                                                      // 4366
          break;                                                                                                       // 4367
        }                                                                                                              // 4368
      }                                                                                                                // 4369
    }                                                                                                                  // 4370
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,                                             // 4371
     * but this is not important since only literal bytes will be emitted.                                             // 4372
     */                                                                                                                // 4373
                                                                                                                       // 4374
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);                                                      // 4375
                                                                                                                       // 4376
  /* If the WIN_INIT bytes after the end of the current data have never been                                           // 4377
   * written, then zero those bytes in order to avoid memory check reports of                                          // 4378
   * the use of uninitialized (or uninitialised as Julian writes) bytes by                                             // 4379
   * the longest match routines.  Update the high water mark for the next                                              // 4380
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match                                          // 4381
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.                                              // 4382
   */                                                                                                                  // 4383
//  if (s.high_water < s.window_size) {                                                                                // 4384
//    var curr = s.strstart + s.lookahead;                                                                             // 4385
//    var init = 0;                                                                                                    // 4386
//                                                                                                                     // 4387
//    if (s.high_water < curr) {                                                                                       // 4388
//      /* Previous high water mark below current data -- zero WIN_INIT                                                // 4389
//       * bytes or up to end of window, whichever is less.                                                            // 4390
//       */                                                                                                            // 4391
//      init = s.window_size - curr;                                                                                   // 4392
//      if (init > WIN_INIT)                                                                                           // 4393
//        init = WIN_INIT;                                                                                             // 4394
//      zmemzero(s->window + curr, (unsigned)init);                                                                    // 4395
//      s->high_water = curr + init;                                                                                   // 4396
//    }                                                                                                                // 4397
//    else if (s->high_water < (ulg)curr + WIN_INIT) {                                                                 // 4398
//      /* High water mark at or above current data, but below current data                                            // 4399
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up                                              // 4400
//       * to end of window, whichever is less.                                                                        // 4401
//       */                                                                                                            // 4402
//      init = (ulg)curr + WIN_INIT - s->high_water;                                                                   // 4403
//      if (init > s->window_size - s->high_water)                                                                     // 4404
//        init = s->window_size - s->high_water;                                                                       // 4405
//      zmemzero(s->window + s->high_water, (unsigned)init);                                                           // 4406
//      s->high_water += init;                                                                                         // 4407
//    }                                                                                                                // 4408
//  }                                                                                                                  // 4409
//                                                                                                                     // 4410
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,                                                         // 4411
//    "not enough room for search");                                                                                   // 4412
}                                                                                                                      // 4413
                                                                                                                       // 4414
/* ===========================================================================                                         // 4415
 * Copy without compression as much as possible from the input stream, return                                          // 4416
 * the current block state.                                                                                            // 4417
 * This function does not insert new strings in the dictionary since                                                   // 4418
 * uncompressible data is probably not useful. This function is used                                                   // 4419
 * only for the level=0 compression option.                                                                            // 4420
 * NOTE: this function should be optimized to avoid extra copying from                                                 // 4421
 * window to pending_buf.                                                                                              // 4422
 */                                                                                                                    // 4423
function deflate_stored(s, flush) {                                                                                    // 4424
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited                                                 // 4425
   * to pending_buf_size, and each stored block has a 5 byte header:                                                   // 4426
   */                                                                                                                  // 4427
  var max_block_size = 0xffff;                                                                                         // 4428
                                                                                                                       // 4429
  if (max_block_size > s.pending_buf_size - 5) {                                                                       // 4430
    max_block_size = s.pending_buf_size - 5;                                                                           // 4431
  }                                                                                                                    // 4432
                                                                                                                       // 4433
  /* Copy as much as possible from input to output: */                                                                 // 4434
  for (;;) {                                                                                                           // 4435
    /* Fill the window as much as possible: */                                                                         // 4436
    if (s.lookahead <= 1) {                                                                                            // 4437
                                                                                                                       // 4438
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||                                                                  // 4439
      //  s->block_start >= (long)s->w_size, "slide too late");                                                        // 4440
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||                                                    // 4441
//        s.block_start >= s.w_size)) {                                                                                // 4442
//        throw  new Error("slide too late");                                                                          // 4443
//      }                                                                                                              // 4444
                                                                                                                       // 4445
      fill_window(s);                                                                                                  // 4446
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {                                                                 // 4447
        return BS_NEED_MORE;                                                                                           // 4448
      }                                                                                                                // 4449
                                                                                                                       // 4450
      if (s.lookahead === 0) {                                                                                         // 4451
        break;                                                                                                         // 4452
      }                                                                                                                // 4453
      /* flush the current block */                                                                                    // 4454
    }                                                                                                                  // 4455
    //Assert(s->block_start >= 0L, "block gone");                                                                      // 4456
//    if (s.block_start < 0) throw new Error("block gone");                                                            // 4457
                                                                                                                       // 4458
    s.strstart += s.lookahead;                                                                                         // 4459
    s.lookahead = 0;                                                                                                   // 4460
                                                                                                                       // 4461
    /* Emit a stored block if pending_buf will be full: */                                                             // 4462
    var max_start = s.block_start + max_block_size;                                                                    // 4463
                                                                                                                       // 4464
    if (s.strstart === 0 || s.strstart >= max_start) {                                                                 // 4465
      /* strstart == 0 is possible when wraparound on 16-bit machine */                                                // 4466
      s.lookahead = s.strstart - max_start;                                                                            // 4467
      s.strstart = max_start;                                                                                          // 4468
      /*** FLUSH_BLOCK(s, 0); ***/                                                                                     // 4469
      flush_block_only(s, false);                                                                                      // 4470
      if (s.strm.avail_out === 0) {                                                                                    // 4471
        return BS_NEED_MORE;                                                                                           // 4472
      }                                                                                                                // 4473
      /***/                                                                                                            // 4474
                                                                                                                       // 4475
                                                                                                                       // 4476
    }                                                                                                                  // 4477
    /* Flush if we may have to slide, otherwise block_start may become                                                 // 4478
     * negative and the data will be gone:                                                                             // 4479
     */                                                                                                                // 4480
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {                                                    // 4481
      /*** FLUSH_BLOCK(s, 0); ***/                                                                                     // 4482
      flush_block_only(s, false);                                                                                      // 4483
      if (s.strm.avail_out === 0) {                                                                                    // 4484
        return BS_NEED_MORE;                                                                                           // 4485
      }                                                                                                                // 4486
      /***/                                                                                                            // 4487
    }                                                                                                                  // 4488
  }                                                                                                                    // 4489
                                                                                                                       // 4490
  s.insert = 0;                                                                                                        // 4491
                                                                                                                       // 4492
  if (flush === Z_FINISH) {                                                                                            // 4493
    /*** FLUSH_BLOCK(s, 1); ***/                                                                                       // 4494
    flush_block_only(s, true);                                                                                         // 4495
    if (s.strm.avail_out === 0) {                                                                                      // 4496
      return BS_FINISH_STARTED;                                                                                        // 4497
    }                                                                                                                  // 4498
    /***/                                                                                                              // 4499
    return BS_FINISH_DONE;                                                                                             // 4500
  }                                                                                                                    // 4501
                                                                                                                       // 4502
  if (s.strstart > s.block_start) {                                                                                    // 4503
    /*** FLUSH_BLOCK(s, 0); ***/                                                                                       // 4504
    flush_block_only(s, false);                                                                                        // 4505
    if (s.strm.avail_out === 0) {                                                                                      // 4506
      return BS_NEED_MORE;                                                                                             // 4507
    }                                                                                                                  // 4508
    /***/                                                                                                              // 4509
  }                                                                                                                    // 4510
                                                                                                                       // 4511
  return BS_NEED_MORE;                                                                                                 // 4512
}                                                                                                                      // 4513
                                                                                                                       // 4514
/* ===========================================================================                                         // 4515
 * Compress as much as possible from the input stream, return the current                                              // 4516
 * block state.                                                                                                        // 4517
 * This function does not perform lazy evaluation of matches and inserts                                               // 4518
 * new strings in the dictionary only for unmatched strings or for short                                               // 4519
 * matches. It is used only for the fast compression options.                                                          // 4520
 */                                                                                                                    // 4521
function deflate_fast(s, flush) {                                                                                      // 4522
  var hash_head;        /* head of the hash chain */                                                                   // 4523
  var bflush;           /* set if current block must be flushed */                                                     // 4524
                                                                                                                       // 4525
  for (;;) {                                                                                                           // 4526
    /* Make sure that we always have enough lookahead, except                                                          // 4527
     * at the end of the input file. We need MAX_MATCH bytes                                                           // 4528
     * for the next match, plus MIN_MATCH bytes to insert the                                                          // 4529
     * string following the next match.                                                                                // 4530
     */                                                                                                                // 4531
    if (s.lookahead < MIN_LOOKAHEAD) {                                                                                 // 4532
      fill_window(s);                                                                                                  // 4533
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {                                                       // 4534
        return BS_NEED_MORE;                                                                                           // 4535
      }                                                                                                                // 4536
      if (s.lookahead === 0) {                                                                                         // 4537
        break; /* flush the current block */                                                                           // 4538
      }                                                                                                                // 4539
    }                                                                                                                  // 4540
                                                                                                                       // 4541
    /* Insert the string window[strstart .. strstart+2] in the                                                         // 4542
     * dictionary, and set hash_head to the head of the hash chain:                                                    // 4543
     */                                                                                                                // 4544
    hash_head = 0/*NIL*/;                                                                                              // 4545
    if (s.lookahead >= MIN_MATCH) {                                                                                    // 4546
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/                                                               // 4547
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;                      // 4548
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];                                                     // 4549
      s.head[s.ins_h] = s.strstart;                                                                                    // 4550
      /***/                                                                                                            // 4551
    }                                                                                                                  // 4552
                                                                                                                       // 4553
    /* Find the longest match, discarding those <= prev_length.                                                        // 4554
     * At this point we have always match_length < MIN_MATCH                                                           // 4555
     */                                                                                                                // 4556
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {                          // 4557
      /* To simplify the code, we prevent matches with the string                                                      // 4558
       * of window index 0 (in particular we have to avoid a match                                                     // 4559
       * of the string with itself at the start of the input file).                                                    // 4560
       */                                                                                                              // 4561
      s.match_length = longest_match(s, hash_head);                                                                    // 4562
      /* longest_match() sets match_start */                                                                           // 4563
    }                                                                                                                  // 4564
    if (s.match_length >= MIN_MATCH) {                                                                                 // 4565
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only                                  // 4566
                                                                                                                       // 4567
      /*** _tr_tally_dist(s, s.strstart - s.match_start,                                                               // 4568
                     s.match_length - MIN_MATCH, bflush); ***/                                                         // 4569
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);                             // 4570
                                                                                                                       // 4571
      s.lookahead -= s.match_length;                                                                                   // 4572
                                                                                                                       // 4573
      /* Insert new strings in the hash table only if the match length                                                 // 4574
       * is not too large. This saves time but degrades compression.                                                   // 4575
       */                                                                                                              // 4576
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {                       // 4577
        s.match_length--; /* string at strstart already in table */                                                    // 4578
        do {                                                                                                           // 4579
          s.strstart++;                                                                                                // 4580
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/                                                           // 4581
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;                  // 4582
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];                                                 // 4583
          s.head[s.ins_h] = s.strstart;                                                                                // 4584
          /***/                                                                                                        // 4585
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are                                                      // 4586
           * always MIN_MATCH bytes ahead.                                                                             // 4587
           */                                                                                                          // 4588
        } while (--s.match_length !== 0);                                                                              // 4589
        s.strstart++;                                                                                                  // 4590
      } else                                                                                                           // 4591
      {                                                                                                                // 4592
        s.strstart += s.match_length;                                                                                  // 4593
        s.match_length = 0;                                                                                            // 4594
        s.ins_h = s.window[s.strstart];                                                                                // 4595
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */                                                         // 4596
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;                                // 4597
                                                                                                                       // 4598
//#if MIN_MATCH != 3                                                                                                   // 4599
//                Call UPDATE_HASH() MIN_MATCH-3 more times                                                            // 4600
//#endif                                                                                                               // 4601
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not                                                 // 4602
         * matter since it will be recomputed at next deflate call.                                                    // 4603
         */                                                                                                            // 4604
      }                                                                                                                // 4605
    } else {                                                                                                           // 4606
      /* No match, output a literal byte */                                                                            // 4607
      //Tracevv((stderr,"%c", s.window[s.strstart]));                                                                  // 4608
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/                                                        // 4609
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);                                                            // 4610
                                                                                                                       // 4611
      s.lookahead--;                                                                                                   // 4612
      s.strstart++;                                                                                                    // 4613
    }                                                                                                                  // 4614
    if (bflush) {                                                                                                      // 4615
      /*** FLUSH_BLOCK(s, 0); ***/                                                                                     // 4616
      flush_block_only(s, false);                                                                                      // 4617
      if (s.strm.avail_out === 0) {                                                                                    // 4618
        return BS_NEED_MORE;                                                                                           // 4619
      }                                                                                                                // 4620
      /***/                                                                                                            // 4621
    }                                                                                                                  // 4622
  }                                                                                                                    // 4623
  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);                                                // 4624
  if (flush === Z_FINISH) {                                                                                            // 4625
    /*** FLUSH_BLOCK(s, 1); ***/                                                                                       // 4626
    flush_block_only(s, true);                                                                                         // 4627
    if (s.strm.avail_out === 0) {                                                                                      // 4628
      return BS_FINISH_STARTED;                                                                                        // 4629
    }                                                                                                                  // 4630
    /***/                                                                                                              // 4631
    return BS_FINISH_DONE;                                                                                             // 4632
  }                                                                                                                    // 4633
  if (s.last_lit) {                                                                                                    // 4634
    /*** FLUSH_BLOCK(s, 0); ***/                                                                                       // 4635
    flush_block_only(s, false);                                                                                        // 4636
    if (s.strm.avail_out === 0) {                                                                                      // 4637
      return BS_NEED_MORE;                                                                                             // 4638
    }                                                                                                                  // 4639
    /***/                                                                                                              // 4640
  }                                                                                                                    // 4641
  return BS_BLOCK_DONE;                                                                                                // 4642
}                                                                                                                      // 4643
                                                                                                                       // 4644
/* ===========================================================================                                         // 4645
 * Same as above, but achieves better compression. We use a lazy                                                       // 4646
 * evaluation for matches: a match is finally adopted only if there is                                                 // 4647
 * no better match at the next window position.                                                                        // 4648
 */                                                                                                                    // 4649
function deflate_slow(s, flush) {                                                                                      // 4650
  var hash_head;          /* head of hash chain */                                                                     // 4651
  var bflush;              /* set if current block must be flushed */                                                  // 4652
                                                                                                                       // 4653
  var max_insert;                                                                                                      // 4654
                                                                                                                       // 4655
  /* Process the input block. */                                                                                       // 4656
  for (;;) {                                                                                                           // 4657
    /* Make sure that we always have enough lookahead, except                                                          // 4658
     * at the end of the input file. We need MAX_MATCH bytes                                                           // 4659
     * for the next match, plus MIN_MATCH bytes to insert the                                                          // 4660
     * string following the next match.                                                                                // 4661
     */                                                                                                                // 4662
    if (s.lookahead < MIN_LOOKAHEAD) {                                                                                 // 4663
      fill_window(s);                                                                                                  // 4664
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {                                                       // 4665
        return BS_NEED_MORE;                                                                                           // 4666
      }                                                                                                                // 4667
      if (s.lookahead === 0) { break; } /* flush the current block */                                                  // 4668
    }                                                                                                                  // 4669
                                                                                                                       // 4670
    /* Insert the string window[strstart .. strstart+2] in the                                                         // 4671
     * dictionary, and set hash_head to the head of the hash chain:                                                    // 4672
     */                                                                                                                // 4673
    hash_head = 0/*NIL*/;                                                                                              // 4674
    if (s.lookahead >= MIN_MATCH) {                                                                                    // 4675
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/                                                               // 4676
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;                      // 4677
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];                                                     // 4678
      s.head[s.ins_h] = s.strstart;                                                                                    // 4679
      /***/                                                                                                            // 4680
    }                                                                                                                  // 4681
                                                                                                                       // 4682
    /* Find the longest match, discarding those <= prev_length.                                                        // 4683
     */                                                                                                                // 4684
    s.prev_length = s.match_length;                                                                                    // 4685
    s.prev_match = s.match_start;                                                                                      // 4686
    s.match_length = MIN_MATCH-1;                                                                                      // 4687
                                                                                                                       // 4688
    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&                                                  // 4689
        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {                                           // 4690
      /* To simplify the code, we prevent matches with the string                                                      // 4691
       * of window index 0 (in particular we have to avoid a match                                                     // 4692
       * of the string with itself at the start of the input file).                                                    // 4693
       */                                                                                                              // 4694
      s.match_length = longest_match(s, hash_head);                                                                    // 4695
      /* longest_match() sets match_start */                                                                           // 4696
                                                                                                                       // 4697
      if (s.match_length <= 5 &&                                                                                       // 4698
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {
                                                                                                                       // 4700
        /* If prev_match is also MIN_MATCH, match_start is garbage                                                     // 4701
         * but we will ignore the current match anyway.                                                                // 4702
         */                                                                                                            // 4703
        s.match_length = MIN_MATCH-1;                                                                                  // 4704
      }                                                                                                                // 4705
    }                                                                                                                  // 4706
    /* If there was a match at the previous step and the current                                                       // 4707
     * match is not better, output the previous match:                                                                 // 4708
     */                                                                                                                // 4709
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {                                               // 4710
      max_insert = s.strstart + s.lookahead - MIN_MATCH;                                                               // 4711
      /* Do not insert strings in hash table beyond this. */                                                           // 4712
                                                                                                                       // 4713
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);                                                     // 4714
                                                                                                                       // 4715
      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,                                                             // 4716
                     s.prev_length - MIN_MATCH, bflush);***/                                                           // 4717
      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);                            // 4718
      /* Insert in hash table all strings up to the end of the match.                                                  // 4719
       * strstart-1 and strstart are already inserted. If there is not                                                 // 4720
       * enough lookahead, the last two strings are not inserted in                                                    // 4721
       * the hash table.                                                                                               // 4722
       */                                                                                                              // 4723
      s.lookahead -= s.prev_length-1;                                                                                  // 4724
      s.prev_length -= 2;                                                                                              // 4725
      do {                                                                                                             // 4726
        if (++s.strstart <= max_insert) {                                                                              // 4727
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/                                                           // 4728
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;                  // 4729
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];                                                 // 4730
          s.head[s.ins_h] = s.strstart;                                                                                // 4731
          /***/                                                                                                        // 4732
        }                                                                                                              // 4733
      } while (--s.prev_length !== 0);                                                                                 // 4734
      s.match_available = 0;                                                                                           // 4735
      s.match_length = MIN_MATCH-1;                                                                                    // 4736
      s.strstart++;                                                                                                    // 4737
                                                                                                                       // 4738
      if (bflush) {                                                                                                    // 4739
        /*** FLUSH_BLOCK(s, 0); ***/                                                                                   // 4740
        flush_block_only(s, false);                                                                                    // 4741
        if (s.strm.avail_out === 0) {                                                                                  // 4742
          return BS_NEED_MORE;                                                                                         // 4743
        }                                                                                                              // 4744
        /***/                                                                                                          // 4745
      }                                                                                                                // 4746
                                                                                                                       // 4747
    } else if (s.match_available) {                                                                                    // 4748
      /* If there was no match at the previous position, output a                                                      // 4749
       * single literal. If there was a match but the current match                                                    // 4750
       * is longer, truncate the previous match to a single literal.                                                   // 4751
       */                                                                                                              // 4752
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));                                                              // 4753
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/                                                      // 4754
      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);                                                          // 4755
                                                                                                                       // 4756
      if (bflush) {                                                                                                    // 4757
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/                                                                               // 4758
        flush_block_only(s, false);                                                                                    // 4759
        /***/                                                                                                          // 4760
      }                                                                                                                // 4761
      s.strstart++;                                                                                                    // 4762
      s.lookahead--;                                                                                                   // 4763
      if (s.strm.avail_out === 0) {                                                                                    // 4764
        return BS_NEED_MORE;                                                                                           // 4765
      }                                                                                                                // 4766
    } else {                                                                                                           // 4767
      /* There is no previous match to compare with, wait for                                                          // 4768
       * the next step to decide.                                                                                      // 4769
       */                                                                                                              // 4770
      s.match_available = 1;                                                                                           // 4771
      s.strstart++;                                                                                                    // 4772
      s.lookahead--;                                                                                                   // 4773
    }                                                                                                                  // 4774
  }                                                                                                                    // 4775
  //Assert (flush != Z_NO_FLUSH, "no flush?");                                                                         // 4776
  if (s.match_available) {                                                                                             // 4777
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));                                                                // 4778
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/                                                        // 4779
    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);                                                            // 4780
                                                                                                                       // 4781
    s.match_available = 0;                                                                                             // 4782
  }                                                                                                                    // 4783
  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;                                                      // 4784
  if (flush === Z_FINISH) {                                                                                            // 4785
    /*** FLUSH_BLOCK(s, 1); ***/                                                                                       // 4786
    flush_block_only(s, true);                                                                                         // 4787
    if (s.strm.avail_out === 0) {                                                                                      // 4788
      return BS_FINISH_STARTED;                                                                                        // 4789
    }                                                                                                                  // 4790
    /***/                                                                                                              // 4791
    return BS_FINISH_DONE;                                                                                             // 4792
  }                                                                                                                    // 4793
  if (s.last_lit) {                                                                                                    // 4794
    /*** FLUSH_BLOCK(s, 0); ***/                                                                                       // 4795
    flush_block_only(s, false);                                                                                        // 4796
    if (s.strm.avail_out === 0) {                                                                                      // 4797
      return BS_NEED_MORE;                                                                                             // 4798
    }                                                                                                                  // 4799
    /***/                                                                                                              // 4800
  }                                                                                                                    // 4801
                                                                                                                       // 4802
  return BS_BLOCK_DONE;                                                                                                // 4803
}                                                                                                                      // 4804
                                                                                                                       // 4805
                                                                                                                       // 4806
/* ===========================================================================                                         // 4807
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance                                         // 4808
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of                                         // 4809
 * deflate switches away from Z_RLE.)                                                                                  // 4810
 */                                                                                                                    // 4811
function deflate_rle(s, flush) {                                                                                       // 4812
  var bflush;            /* set if current block must be flushed */                                                    // 4813
  var prev;              /* byte at distance one to match */                                                           // 4814
  var scan, strend;      /* scan goes up to strend for length of run */                                                // 4815
                                                                                                                       // 4816
  var _win = s.window;                                                                                                 // 4817
                                                                                                                       // 4818
  for (;;) {                                                                                                           // 4819
    /* Make sure that we always have enough lookahead, except                                                          // 4820
     * at the end of the input file. We need MAX_MATCH bytes                                                           // 4821
     * for the longest run, plus one for the unrolled loop.                                                            // 4822
     */                                                                                                                // 4823
    if (s.lookahead <= MAX_MATCH) {                                                                                    // 4824
      fill_window(s);                                                                                                  // 4825
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {                                                          // 4826
        return BS_NEED_MORE;                                                                                           // 4827
      }                                                                                                                // 4828
      if (s.lookahead === 0) { break; } /* flush the current block */                                                  // 4829
    }                                                                                                                  // 4830
                                                                                                                       // 4831
    /* See how many times the previous byte repeats */                                                                 // 4832
    s.match_length = 0;                                                                                                // 4833
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {                                                                  // 4834
      scan = s.strstart - 1;                                                                                           // 4835
      prev = _win[scan];                                                                                               // 4836
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {                                   // 4837
        strend = s.strstart + MAX_MATCH;                                                                               // 4838
        do {                                                                                                           // 4839
          /*jshint noempty:false*/                                                                                     // 4840
        } while (prev === _win[++scan] && prev === _win[++scan] &&                                                     // 4841
                 prev === _win[++scan] && prev === _win[++scan] &&                                                     // 4842
                 prev === _win[++scan] && prev === _win[++scan] &&                                                     // 4843
                 prev === _win[++scan] && prev === _win[++scan] &&                                                     // 4844
                 scan < strend);                                                                                       // 4845
        s.match_length = MAX_MATCH - (strend - scan);                                                                  // 4846
        if (s.match_length > s.lookahead) {                                                                            // 4847
          s.match_length = s.lookahead;                                                                                // 4848
        }                                                                                                              // 4849
      }                                                                                                                // 4850
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");                                               // 4851
    }                                                                                                                  // 4852
                                                                                                                       // 4853
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */                                             // 4854
    if (s.match_length >= MIN_MATCH) {                                                                                 // 4855
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);                                                    // 4856
                                                                                                                       // 4857
      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/                                              // 4858
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);                                                      // 4859
                                                                                                                       // 4860
      s.lookahead -= s.match_length;                                                                                   // 4861
      s.strstart += s.match_length;                                                                                    // 4862
      s.match_length = 0;                                                                                              // 4863
    } else {                                                                                                           // 4864
      /* No match, output a literal byte */                                                                            // 4865
      //Tracevv((stderr,"%c", s->window[s->strstart]));                                                                // 4866
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/                                                        // 4867
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);                                                            // 4868
                                                                                                                       // 4869
      s.lookahead--;                                                                                                   // 4870
      s.strstart++;                                                                                                    // 4871
    }                                                                                                                  // 4872
    if (bflush) {                                                                                                      // 4873
      /*** FLUSH_BLOCK(s, 0); ***/                                                                                     // 4874
      flush_block_only(s, false);                                                                                      // 4875
      if (s.strm.avail_out === 0) {                                                                                    // 4876
        return BS_NEED_MORE;                                                                                           // 4877
      }                                                                                                                // 4878
      /***/                                                                                                            // 4879
    }                                                                                                                  // 4880
  }                                                                                                                    // 4881
  s.insert = 0;                                                                                                        // 4882
  if (flush === Z_FINISH) {                                                                                            // 4883
    /*** FLUSH_BLOCK(s, 1); ***/                                                                                       // 4884
    flush_block_only(s, true);                                                                                         // 4885
    if (s.strm.avail_out === 0) {                                                                                      // 4886
      return BS_FINISH_STARTED;                                                                                        // 4887
    }                                                                                                                  // 4888
    /***/                                                                                                              // 4889
    return BS_FINISH_DONE;                                                                                             // 4890
  }                                                                                                                    // 4891
  if (s.last_lit) {                                                                                                    // 4892
    /*** FLUSH_BLOCK(s, 0); ***/                                                                                       // 4893
    flush_block_only(s, false);                                                                                        // 4894
    if (s.strm.avail_out === 0) {                                                                                      // 4895
      return BS_NEED_MORE;                                                                                             // 4896
    }                                                                                                                  // 4897
    /***/                                                                                                              // 4898
  }                                                                                                                    // 4899
  return BS_BLOCK_DONE;                                                                                                // 4900
}                                                                                                                      // 4901
                                                                                                                       // 4902
/* ===========================================================================                                         // 4903
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.                                         // 4904
 * (It will be regenerated if this run of deflate switches away from Huffman.)                                         // 4905
 */                                                                                                                    // 4906
function deflate_huff(s, flush) {                                                                                      // 4907
  var bflush;             /* set if current block must be flushed */                                                   // 4908
                                                                                                                       // 4909
  for (;;) {                                                                                                           // 4910
    /* Make sure that we have a literal to write. */                                                                   // 4911
    if (s.lookahead === 0) {                                                                                           // 4912
      fill_window(s);                                                                                                  // 4913
      if (s.lookahead === 0) {                                                                                         // 4914
        if (flush === Z_NO_FLUSH) {                                                                                    // 4915
          return BS_NEED_MORE;                                                                                         // 4916
        }                                                                                                              // 4917
        break;      /* flush the current block */                                                                      // 4918
      }                                                                                                                // 4919
    }                                                                                                                  // 4920
                                                                                                                       // 4921
    /* Output a literal byte */                                                                                        // 4922
    s.match_length = 0;                                                                                                // 4923
    //Tracevv((stderr,"%c", s->window[s->strstart]));                                                                  // 4924
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/                                                          // 4925
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);                                                              // 4926
    s.lookahead--;                                                                                                     // 4927
    s.strstart++;                                                                                                      // 4928
    if (bflush) {                                                                                                      // 4929
      /*** FLUSH_BLOCK(s, 0); ***/                                                                                     // 4930
      flush_block_only(s, false);                                                                                      // 4931
      if (s.strm.avail_out === 0) {                                                                                    // 4932
        return BS_NEED_MORE;                                                                                           // 4933
      }                                                                                                                // 4934
      /***/                                                                                                            // 4935
    }                                                                                                                  // 4936
  }                                                                                                                    // 4937
  s.insert = 0;                                                                                                        // 4938
  if (flush === Z_FINISH) {                                                                                            // 4939
    /*** FLUSH_BLOCK(s, 1); ***/                                                                                       // 4940
    flush_block_only(s, true);                                                                                         // 4941
    if (s.strm.avail_out === 0) {                                                                                      // 4942
      return BS_FINISH_STARTED;                                                                                        // 4943
    }                                                                                                                  // 4944
    /***/                                                                                                              // 4945
    return BS_FINISH_DONE;                                                                                             // 4946
  }                                                                                                                    // 4947
  if (s.last_lit) {                                                                                                    // 4948
    /*** FLUSH_BLOCK(s, 0); ***/                                                                                       // 4949
    flush_block_only(s, false);                                                                                        // 4950
    if (s.strm.avail_out === 0) {                                                                                      // 4951
      return BS_NEED_MORE;                                                                                             // 4952
    }                                                                                                                  // 4953
    /***/                                                                                                              // 4954
  }                                                                                                                    // 4955
  return BS_BLOCK_DONE;                                                                                                // 4956
}                                                                                                                      // 4957
                                                                                                                       // 4958
/* Values for max_lazy_match, good_match and max_chain_length, depending on                                            // 4959
 * the desired pack level (0..9). The values given below have been tuned to                                            // 4960
 * exclude worst case performance for pathological files. Better values may be                                         // 4961
 * found for specific files.                                                                                           // 4962
 */                                                                                                                    // 4963
var Config = function (good_length, max_lazy, nice_length, max_chain, func) {                                          // 4964
  this.good_length = good_length;                                                                                      // 4965
  this.max_lazy = max_lazy;                                                                                            // 4966
  this.nice_length = nice_length;                                                                                      // 4967
  this.max_chain = max_chain;                                                                                          // 4968
  this.func = func;                                                                                                    // 4969
};                                                                                                                     // 4970
                                                                                                                       // 4971
var configuration_table;                                                                                               // 4972
                                                                                                                       // 4973
configuration_table = [                                                                                                // 4974
  /*      good lazy nice chain */                                                                                      // 4975
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */                                                  // 4976
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */                                  // 4977
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */                                                             // 4978
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */                                                             // 4979
                                                                                                                       // 4980
  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */                                                // 4981
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */                                                             // 4982
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */                                                             // 4983
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */                                                             // 4984
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */                                                             // 4985
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */                                             // 4986
];                                                                                                                     // 4987
                                                                                                                       // 4988
                                                                                                                       // 4989
/* ===========================================================================                                         // 4990
 * Initialize the "longest match" routines for a new zlib stream                                                       // 4991
 */                                                                                                                    // 4992
function lm_init(s) {                                                                                                  // 4993
  s.window_size = 2 * s.w_size;                                                                                        // 4994
                                                                                                                       // 4995
  /*** CLEAR_HASH(s); ***/                                                                                             // 4996
  zero(s.head); // Fill with NIL (= 0);                                                                                // 4997
                                                                                                                       // 4998
  /* Set the default configuration parameters:                                                                         // 4999
   */                                                                                                                  // 5000
  s.max_lazy_match = configuration_table[s.level].max_lazy;                                                            // 5001
  s.good_match = configuration_table[s.level].good_length;                                                             // 5002
  s.nice_match = configuration_table[s.level].nice_length;                                                             // 5003
  s.max_chain_length = configuration_table[s.level].max_chain;                                                         // 5004
                                                                                                                       // 5005
  s.strstart = 0;                                                                                                      // 5006
  s.block_start = 0;                                                                                                   // 5007
  s.lookahead = 0;                                                                                                     // 5008
  s.insert = 0;                                                                                                        // 5009
  s.match_length = s.prev_length = MIN_MATCH - 1;                                                                      // 5010
  s.match_available = 0;                                                                                               // 5011
  s.ins_h = 0;                                                                                                         // 5012
}                                                                                                                      // 5013
                                                                                                                       // 5014
                                                                                                                       // 5015
function DeflateState() {                                                                                              // 5016
  this.strm = null;            /* pointer back to this zlib stream */                                                  // 5017
  this.status = 0;            /* as the name implies */                                                                // 5018
  this.pending_buf = null;      /* output still pending */                                                             // 5019
  this.pending_buf_size = 0;  /* size of pending_buf */                                                                // 5020
  this.pending_out = 0;       /* next pending byte to output to the stream */                                          // 5021
  this.pending = 0;           /* nb of bytes in the pending buffer */                                                  // 5022
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */                                           // 5023
  this.gzhead = null;         /* gzip header information to write */                                                   // 5024
  this.gzindex = 0;           /* where in extra, name, or comment */                                                   // 5025
  this.method = Z_DEFLATED; /* can only be DEFLATED */                                                                 // 5026
  this.last_flush = -1;   /* value of flush param for previous deflate call */                                         // 5027
                                                                                                                       // 5028
  this.w_size = 0;  /* LZ77 window size (32K by default) */                                                            // 5029
  this.w_bits = 0;  /* log2(w_size)  (8..16) */                                                                        // 5030
  this.w_mask = 0;  /* w_size - 1 */                                                                                   // 5031
                                                                                                                       // 5032
  this.window = null;                                                                                                  // 5033
  /* Sliding window. Input bytes are read into the second half of the window,                                          // 5034
   * and move to the first half later to keep a dictionary of at least wSize                                           // 5035
   * bytes. With this organization, matches are limited to a distance of                                               // 5036
   * wSize-MAX_MATCH bytes, but this ensures that IO is always                                                         // 5037
   * performed with a length multiple of the block size.                                                               // 5038
   */                                                                                                                  // 5039
                                                                                                                       // 5040
  this.window_size = 0;                                                                                                // 5041
  /* Actual size of window: 2*wSize, except when the user input buffer                                                 // 5042
   * is directly used as sliding window.                                                                               // 5043
   */                                                                                                                  // 5044
                                                                                                                       // 5045
  this.prev = null;                                                                                                    // 5046
  /* Link to older string with same hash index. To limit the size of this                                              // 5047
   * array to 64K, this link is maintained only for the last 32K strings.                                              // 5048
   * An index in this array is thus a window index modulo 32K.                                                         // 5049
   */                                                                                                                  // 5050
                                                                                                                       // 5051
  this.head = null;   /* Heads of the hash chains or NIL. */                                                           // 5052
                                                                                                                       // 5053
  this.ins_h = 0;       /* hash index of string to be inserted */                                                      // 5054
  this.hash_size = 0;   /* number of elements in hash table */                                                         // 5055
  this.hash_bits = 0;   /* log2(hash_size) */                                                                          // 5056
  this.hash_mask = 0;   /* hash_size-1 */                                                                              // 5057
                                                                                                                       // 5058
  this.hash_shift = 0;                                                                                                 // 5059
  /* Number of bits by which ins_h must be shifted at each input                                                       // 5060
   * step. It must be such that after MIN_MATCH steps, the oldest                                                      // 5061
   * byte no longer takes part in the hash key, that is:                                                               // 5062
   *   hash_shift * MIN_MATCH >= hash_bits                                                                             // 5063
   */                                                                                                                  // 5064
                                                                                                                       // 5065
  this.block_start = 0;                                                                                                // 5066
  /* Window position at the beginning of the current output block. Gets                                                // 5067
   * negative when the window is moved backwards.                                                                      // 5068
   */                                                                                                                  // 5069
                                                                                                                       // 5070
  this.match_length = 0;      /* length of best match */                                                               // 5071
  this.prev_match = 0;        /* previous match */                                                                     // 5072
  this.match_available = 0;   /* set if previous match exists */                                                       // 5073
  this.strstart = 0;          /* start of string to insert */                                                          // 5074
  this.match_start = 0;       /* start of matching string */                                                           // 5075
  this.lookahead = 0;         /* number of valid bytes ahead in window */                                              // 5076
                                                                                                                       // 5077
  this.prev_length = 0;                                                                                                // 5078
  /* Length of the best match at previous step. Matches not greater than this                                          // 5079
   * are discarded. This is used in the lazy match evaluation.                                                         // 5080
   */                                                                                                                  // 5081
                                                                                                                       // 5082
  this.max_chain_length = 0;                                                                                           // 5083
  /* To speed up deflation, hash chains are never searched beyond this                                                 // 5084
   * length.  A higher limit improves compression ratio but degrades the                                               // 5085
   * speed.                                                                                                            // 5086
   */                                                                                                                  // 5087
                                                                                                                       // 5088
  this.max_lazy_match = 0;                                                                                             // 5089
  /* Attempt to find a better match only when the current match is strictly                                            // 5090
   * smaller than this value. This mechanism is used only for compression                                              // 5091
   * levels >= 4.                                                                                                      // 5092
   */                                                                                                                  // 5093
  // That's alias to max_lazy_match, don't use directly                                                                // 5094
  //this.max_insert_length = 0;                                                                                        // 5095
  /* Insert new strings in the hash table only if the match length is not                                              // 5096
   * greater than this length. This saves time but degrades compression.                                               // 5097
   * max_insert_length is used only for compression levels <= 3.                                                       // 5098
   */                                                                                                                  // 5099
                                                                                                                       // 5100
  this.level = 0;     /* compression level (1..9) */                                                                   // 5101
  this.strategy = 0;  /* favor or force Huffman coding*/                                                               // 5102
                                                                                                                       // 5103
  this.good_match = 0;                                                                                                 // 5104
  /* Use a faster search when the previous match is longer than this */                                                // 5105
                                                                                                                       // 5106
  this.nice_match = 0; /* Stop searching when current match exceeds this */                                            // 5107
                                                                                                                       // 5108
              /* used by trees.c: */                                                                                   // 5109
                                                                                                                       // 5110
  /* Didn't use ct_data typedef below to suppress compiler warning */                                                  // 5111
                                                                                                                       // 5112
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */                                            // 5113
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */                                                      // 5114
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */                                       // 5115
                                                                                                                       // 5116
  // Use flat array of DOUBLE size, with interleaved fata,                                                             // 5117
  // because JS does not support effective                                                                             // 5118
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);                                                                    // 5119
  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);                                                                // 5120
  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);                                                               // 5121
  zero(this.dyn_ltree);                                                                                                // 5122
  zero(this.dyn_dtree);                                                                                                // 5123
  zero(this.bl_tree);                                                                                                  // 5124
                                                                                                                       // 5125
  this.l_desc   = null;         /* desc. for literal tree */                                                           // 5126
  this.d_desc   = null;         /* desc. for distance tree */                                                          // 5127
  this.bl_desc  = null;         /* desc. for bit length tree */                                                        // 5128
                                                                                                                       // 5129
  //ush bl_count[MAX_BITS+1];                                                                                          // 5130
  this.bl_count = new utils.Buf16(MAX_BITS+1);                                                                         // 5131
  /* number of codes at each bit length for an optimal tree */                                                         // 5132
                                                                                                                       // 5133
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */                                             // 5134
  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */                                // 5135
  zero(this.heap);                                                                                                     // 5136
                                                                                                                       // 5137
  this.heap_len = 0;               /* number of elements in the heap */                                                // 5138
  this.heap_max = 0;               /* element of largest frequency */                                                  // 5139
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.                                           // 5140
   * The same heap array is used to build all trees.                                                                   // 5141
   */                                                                                                                  // 5142
                                                                                                                       // 5143
  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];                                                 // 5144
  zero(this.depth);                                                                                                    // 5145
  /* Depth of each subtree used as tie breaker for trees of equal frequency                                            // 5146
   */                                                                                                                  // 5147
                                                                                                                       // 5148
  this.l_buf = 0;          /* buffer index for literals or lengths */                                                  // 5149
                                                                                                                       // 5150
  this.lit_bufsize = 0;                                                                                                // 5151
  /* Size of match buffer for literals/lengths.  There are 4 reasons for                                               // 5152
   * limiting lit_bufsize to 64K:                                                                                      // 5153
   *   - frequencies can be kept in 16 bit counters                                                                    // 5154
   *   - if compression is not successful for the first block, all input                                               // 5155
   *     data is still in the window so we can still emit a stored block even                                          // 5156
   *     when input comes from standard input.  (This can also be done for                                             // 5157
   *     all blocks if lit_bufsize is not greater than 32K.)                                                           // 5158
   *   - if compression is not successful for a file smaller than 64K, we can                                          // 5159
   *     even emit a stored file instead of a stored block (saving 5 bytes).                                           // 5160
   *     This is applicable only for zip (not gzip or zlib).                                                           // 5161
   *   - creating new Huffman trees less frequently may not provide fast                                               // 5162
   *     adaptation to changes in the input data statistics. (Take for                                                 // 5163
   *     example a binary file with poorly compressible code followed by                                               // 5164
   *     a highly compressible string table.) Smaller buffer sizes give                                                // 5165
   *     fast adaptation but have of course the overhead of transmitting                                               // 5166
   *     trees more frequently.                                                                                        // 5167
   *   - I can't count above 4                                                                                         // 5168
   */                                                                                                                  // 5169
                                                                                                                       // 5170
  this.last_lit = 0;      /* running index in l_buf */                                                                 // 5171
                                                                                                                       // 5172
  this.d_buf = 0;                                                                                                      // 5173
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have                                            // 5174
   * the same number of elements. To use different lengths, an extra flag                                              // 5175
   * array would be necessary.                                                                                         // 5176
   */                                                                                                                  // 5177
                                                                                                                       // 5178
  this.opt_len = 0;       /* bit length of current block with optimal trees */                                         // 5179
  this.static_len = 0;    /* bit length of current block with static trees */                                          // 5180
  this.matches = 0;       /* number of string matches in current block */                                              // 5181
  this.insert = 0;        /* bytes at end of window left to insert */                                                  // 5182
                                                                                                                       // 5183
                                                                                                                       // 5184
  this.bi_buf = 0;                                                                                                     // 5185
  /* Output buffer. bits are inserted starting at the bottom (least                                                    // 5186
   * significant bits).                                                                                                // 5187
   */                                                                                                                  // 5188
  this.bi_valid = 0;                                                                                                   // 5189
  /* Number of valid bits in bi_buf.  All bits above the last valid bit                                                // 5190
   * are always zero.                                                                                                  // 5191
   */                                                                                                                  // 5192
                                                                                                                       // 5193
  // Used for window memory init. We safely ignore it for JS. That makes                                               // 5194
  // sense only for pointers and memory check tools.                                                                   // 5195
  //this.high_water = 0;                                                                                               // 5196
  /* High water mark offset in window for initialized bytes -- bytes above                                             // 5197
   * this are set to zero in order to avoid memory check warnings when                                                 // 5198
   * longest match routines access bytes past the input.  This is then                                                 // 5199
   * updated to the new high water mark.                                                                               // 5200
   */                                                                                                                  // 5201
}                                                                                                                      // 5202
                                                                                                                       // 5203
                                                                                                                       // 5204
function deflateResetKeep(strm) {                                                                                      // 5205
  var s;                                                                                                               // 5206
                                                                                                                       // 5207
  if (!strm || !strm.state) {                                                                                          // 5208
    return err(strm, Z_STREAM_ERROR);                                                                                  // 5209
  }                                                                                                                    // 5210
                                                                                                                       // 5211
  strm.total_in = strm.total_out = 0;                                                                                  // 5212
  strm.data_type = Z_UNKNOWN;                                                                                          // 5213
                                                                                                                       // 5214
  s = strm.state;                                                                                                      // 5215
  s.pending = 0;                                                                                                       // 5216
  s.pending_out = 0;                                                                                                   // 5217
                                                                                                                       // 5218
  if (s.wrap < 0) {                                                                                                    // 5219
    s.wrap = -s.wrap;                                                                                                  // 5220
    /* was made negative by deflate(..., Z_FINISH); */                                                                 // 5221
  }                                                                                                                    // 5222
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);                                                                       // 5223
  strm.adler = (s.wrap === 2) ?                                                                                        // 5224
    0  // crc32(0, Z_NULL, 0)                                                                                          // 5225
  :                                                                                                                    // 5226
    1; // adler32(0, Z_NULL, 0)                                                                                        // 5227
  s.last_flush = Z_NO_FLUSH;                                                                                           // 5228
  trees._tr_init(s);                                                                                                   // 5229
  return Z_OK;                                                                                                         // 5230
}                                                                                                                      // 5231
                                                                                                                       // 5232
                                                                                                                       // 5233
function deflateReset(strm) {                                                                                          // 5234
  var ret = deflateResetKeep(strm);                                                                                    // 5235
  if (ret === Z_OK) {                                                                                                  // 5236
    lm_init(strm.state);                                                                                               // 5237
  }                                                                                                                    // 5238
  return ret;                                                                                                          // 5239
}                                                                                                                      // 5240
                                                                                                                       // 5241
                                                                                                                       // 5242
function deflateSetHeader(strm, head) {                                                                                // 5243
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }                                                                 // 5244
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }                                                                // 5245
  strm.state.gzhead = head;                                                                                            // 5246
  return Z_OK;                                                                                                         // 5247
}                                                                                                                      // 5248
                                                                                                                       // 5249
                                                                                                                       // 5250
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {                                           // 5251
  if (!strm) { // === Z_NULL                                                                                           // 5252
    return Z_STREAM_ERROR;                                                                                             // 5253
  }                                                                                                                    // 5254
  var wrap = 1;                                                                                                        // 5255
                                                                                                                       // 5256
  if (level === Z_DEFAULT_COMPRESSION) {                                                                               // 5257
    level = 6;                                                                                                         // 5258
  }                                                                                                                    // 5259
                                                                                                                       // 5260
  if (windowBits < 0) { /* suppress zlib wrapper */                                                                    // 5261
    wrap = 0;                                                                                                          // 5262
    windowBits = -windowBits;                                                                                          // 5263
  }                                                                                                                    // 5264
                                                                                                                       // 5265
  else if (windowBits > 15) {                                                                                          // 5266
    wrap = 2;           /* write gzip wrapper instead */                                                               // 5267
    windowBits -= 16;                                                                                                  // 5268
  }                                                                                                                    // 5269
                                                                                                                       // 5270
                                                                                                                       // 5271
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||                                             // 5272
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||                                                     // 5273
    strategy < 0 || strategy > Z_FIXED) {                                                                              // 5274
    return err(strm, Z_STREAM_ERROR);                                                                                  // 5275
  }                                                                                                                    // 5276
                                                                                                                       // 5277
                                                                                                                       // 5278
  if (windowBits === 8) {                                                                                              // 5279
    windowBits = 9;                                                                                                    // 5280
  }                                                                                                                    // 5281
  /* until 256-byte window bug fixed */                                                                                // 5282
                                                                                                                       // 5283
  var s = new DeflateState();                                                                                          // 5284
                                                                                                                       // 5285
  strm.state = s;                                                                                                      // 5286
  s.strm = strm;                                                                                                       // 5287
                                                                                                                       // 5288
  s.wrap = wrap;                                                                                                       // 5289
  s.gzhead = null;                                                                                                     // 5290
  s.w_bits = windowBits;                                                                                               // 5291
  s.w_size = 1 << s.w_bits;                                                                                            // 5292
  s.w_mask = s.w_size - 1;                                                                                             // 5293
                                                                                                                       // 5294
  s.hash_bits = memLevel + 7;                                                                                          // 5295
  s.hash_size = 1 << s.hash_bits;                                                                                      // 5296
  s.hash_mask = s.hash_size - 1;                                                                                       // 5297
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);                                                        // 5298
                                                                                                                       // 5299
  s.window = new utils.Buf8(s.w_size * 2);                                                                             // 5300
  s.head = new utils.Buf16(s.hash_size);                                                                               // 5301
  s.prev = new utils.Buf16(s.w_size);                                                                                  // 5302
                                                                                                                       // 5303
  // Don't need mem init magic for JS.                                                                                 // 5304
  //s.high_water = 0;  /* nothing written to s->window yet */                                                          // 5305
                                                                                                                       // 5306
  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */                                                   // 5307
                                                                                                                       // 5308
  s.pending_buf_size = s.lit_bufsize * 4;                                                                              // 5309
  s.pending_buf = new utils.Buf8(s.pending_buf_size);                                                                  // 5310
                                                                                                                       // 5311
  s.d_buf = s.lit_bufsize >> 1;                                                                                        // 5312
  s.l_buf = (1 + 2) * s.lit_bufsize;                                                                                   // 5313
                                                                                                                       // 5314
  s.level = level;                                                                                                     // 5315
  s.strategy = strategy;                                                                                               // 5316
  s.method = method;                                                                                                   // 5317
                                                                                                                       // 5318
  return deflateReset(strm);                                                                                           // 5319
}                                                                                                                      // 5320
                                                                                                                       // 5321
function deflateInit(strm, level) {                                                                                    // 5322
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);                          // 5323
}                                                                                                                      // 5324
                                                                                                                       // 5325
                                                                                                                       // 5326
function deflate(strm, flush) {                                                                                        // 5327
  var old_flush, s;                                                                                                    // 5328
  var beg, val; // for gzip header write only                                                                          // 5329
                                                                                                                       // 5330
  if (!strm || !strm.state ||                                                                                          // 5331
    flush > Z_BLOCK || flush < 0) {                                                                                    // 5332
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;                                                          // 5333
  }                                                                                                                    // 5334
                                                                                                                       // 5335
  s = strm.state;                                                                                                      // 5336
                                                                                                                       // 5337
  if (!strm.output ||                                                                                                  // 5338
      (!strm.input && strm.avail_in !== 0) ||                                                                          // 5339
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {                                                             // 5340
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);                                           // 5341
  }                                                                                                                    // 5342
                                                                                                                       // 5343
  s.strm = strm; /* just in case */                                                                                    // 5344
  old_flush = s.last_flush;                                                                                            // 5345
  s.last_flush = flush;                                                                                                // 5346
                                                                                                                       // 5347
  /* Write the header */                                                                                               // 5348
  if (s.status === INIT_STATE) {                                                                                       // 5349
                                                                                                                       // 5350
    if (s.wrap === 2) { // GZIP header                                                                                 // 5351
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);                                                                         // 5352
      put_byte(s, 31);                                                                                                 // 5353
      put_byte(s, 139);                                                                                                // 5354
      put_byte(s, 8);                                                                                                  // 5355
      if (!s.gzhead) { // s->gzhead == Z_NULL                                                                          // 5356
        put_byte(s, 0);                                                                                                // 5357
        put_byte(s, 0);                                                                                                // 5358
        put_byte(s, 0);                                                                                                // 5359
        put_byte(s, 0);                                                                                                // 5360
        put_byte(s, 0);                                                                                                // 5361
        put_byte(s, s.level === 9 ? 2 :                                                                                // 5362
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?                                                     // 5363
                     4 : 0));                                                                                          // 5364
        put_byte(s, OS_CODE);                                                                                          // 5365
        s.status = BUSY_STATE;                                                                                         // 5366
      }                                                                                                                // 5367
      else {                                                                                                           // 5368
        put_byte(s, (s.gzhead.text ? 1 : 0) +                                                                          // 5369
                    (s.gzhead.hcrc ? 2 : 0) +                                                                          // 5370
                    (!s.gzhead.extra ? 0 : 4) +                                                                        // 5371
                    (!s.gzhead.name ? 0 : 8) +                                                                         // 5372
                    (!s.gzhead.comment ? 0 : 16)                                                                       // 5373
                );                                                                                                     // 5374
        put_byte(s, s.gzhead.time & 0xff);                                                                             // 5375
        put_byte(s, (s.gzhead.time >> 8) & 0xff);                                                                      // 5376
        put_byte(s, (s.gzhead.time >> 16) & 0xff);                                                                     // 5377
        put_byte(s, (s.gzhead.time >> 24) & 0xff);                                                                     // 5378
        put_byte(s, s.level === 9 ? 2 :                                                                                // 5379
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?                                                     // 5380
                     4 : 0));                                                                                          // 5381
        put_byte(s, s.gzhead.os & 0xff);                                                                               // 5382
        if (s.gzhead.extra && s.gzhead.extra.length) {                                                                 // 5383
          put_byte(s, s.gzhead.extra.length & 0xff);                                                                   // 5384
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);                                                            // 5385
        }                                                                                                              // 5386
        if (s.gzhead.hcrc) {                                                                                           // 5387
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);                                                 // 5388
        }                                                                                                              // 5389
        s.gzindex = 0;                                                                                                 // 5390
        s.status = EXTRA_STATE;                                                                                        // 5391
      }                                                                                                                // 5392
    }                                                                                                                  // 5393
    else // DEFLATE header                                                                                             // 5394
    {                                                                                                                  // 5395
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;                                                          // 5396
      var level_flags = -1;                                                                                            // 5397
                                                                                                                       // 5398
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {                                                               // 5399
        level_flags = 0;                                                                                               // 5400
      } else if (s.level < 6) {                                                                                        // 5401
        level_flags = 1;                                                                                               // 5402
      } else if (s.level === 6) {                                                                                      // 5403
        level_flags = 2;                                                                                               // 5404
      } else {                                                                                                         // 5405
        level_flags = 3;                                                                                               // 5406
      }                                                                                                                // 5407
      header |= (level_flags << 6);                                                                                    // 5408
      if (s.strstart !== 0) { header |= PRESET_DICT; }                                                                 // 5409
      header += 31 - (header % 31);                                                                                    // 5410
                                                                                                                       // 5411
      s.status = BUSY_STATE;                                                                                           // 5412
      putShortMSB(s, header);                                                                                          // 5413
                                                                                                                       // 5414
      /* Save the adler32 of the preset dictionary: */                                                                 // 5415
      if (s.strstart !== 0) {                                                                                          // 5416
        putShortMSB(s, strm.adler >>> 16);                                                                             // 5417
        putShortMSB(s, strm.adler & 0xffff);                                                                           // 5418
      }                                                                                                                // 5419
      strm.adler = 1; // adler32(0L, Z_NULL, 0);                                                                       // 5420
    }                                                                                                                  // 5421
  }                                                                                                                    // 5422
                                                                                                                       // 5423
//#ifdef GZIP                                                                                                          // 5424
  if (s.status === EXTRA_STATE) {                                                                                      // 5425
    if (s.gzhead.extra/* != Z_NULL*/) {                                                                                // 5426
      beg = s.pending;  /* start of bytes to update crc */                                                             // 5427
                                                                                                                       // 5428
      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {                                                           // 5429
        if (s.pending === s.pending_buf_size) {                                                                        // 5430
          if (s.gzhead.hcrc && s.pending > beg) {                                                                      // 5431
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                       // 5432
          }                                                                                                            // 5433
          flush_pending(strm);                                                                                         // 5434
          beg = s.pending;                                                                                             // 5435
          if (s.pending === s.pending_buf_size) {                                                                      // 5436
            break;                                                                                                     // 5437
          }                                                                                                            // 5438
        }                                                                                                              // 5439
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);                                                                 // 5440
        s.gzindex++;                                                                                                   // 5441
      }                                                                                                                // 5442
      if (s.gzhead.hcrc && s.pending > beg) {                                                                          // 5443
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                           // 5444
      }                                                                                                                // 5445
      if (s.gzindex === s.gzhead.extra.length) {                                                                       // 5446
        s.gzindex = 0;                                                                                                 // 5447
        s.status = NAME_STATE;                                                                                         // 5448
      }                                                                                                                // 5449
    }                                                                                                                  // 5450
    else {                                                                                                             // 5451
      s.status = NAME_STATE;                                                                                           // 5452
    }                                                                                                                  // 5453
  }                                                                                                                    // 5454
  if (s.status === NAME_STATE) {                                                                                       // 5455
    if (s.gzhead.name/* != Z_NULL*/) {                                                                                 // 5456
      beg = s.pending;  /* start of bytes to update crc */                                                             // 5457
      //int val;                                                                                                       // 5458
                                                                                                                       // 5459
      do {                                                                                                             // 5460
        if (s.pending === s.pending_buf_size) {                                                                        // 5461
          if (s.gzhead.hcrc && s.pending > beg) {                                                                      // 5462
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                       // 5463
          }                                                                                                            // 5464
          flush_pending(strm);                                                                                         // 5465
          beg = s.pending;                                                                                             // 5466
          if (s.pending === s.pending_buf_size) {                                                                      // 5467
            val = 1;                                                                                                   // 5468
            break;                                                                                                     // 5469
          }                                                                                                            // 5470
        }                                                                                                              // 5471
        // JS specific: little magic to add zero terminator to end of string                                           // 5472
        if (s.gzindex < s.gzhead.name.length) {                                                                        // 5473
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;                                                          // 5474
        } else {                                                                                                       // 5475
          val = 0;                                                                                                     // 5476
        }                                                                                                              // 5477
        put_byte(s, val);                                                                                              // 5478
      } while (val !== 0);                                                                                             // 5479
                                                                                                                       // 5480
      if (s.gzhead.hcrc && s.pending > beg){                                                                           // 5481
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                           // 5482
      }                                                                                                                // 5483
      if (val === 0) {                                                                                                 // 5484
        s.gzindex = 0;                                                                                                 // 5485
        s.status = COMMENT_STATE;                                                                                      // 5486
      }                                                                                                                // 5487
    }                                                                                                                  // 5488
    else {                                                                                                             // 5489
      s.status = COMMENT_STATE;                                                                                        // 5490
    }                                                                                                                  // 5491
  }                                                                                                                    // 5492
  if (s.status === COMMENT_STATE) {                                                                                    // 5493
    if (s.gzhead.comment/* != Z_NULL*/) {                                                                              // 5494
      beg = s.pending;  /* start of bytes to update crc */                                                             // 5495
      //int val;                                                                                                       // 5496
                                                                                                                       // 5497
      do {                                                                                                             // 5498
        if (s.pending === s.pending_buf_size) {                                                                        // 5499
          if (s.gzhead.hcrc && s.pending > beg) {                                                                      // 5500
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                       // 5501
          }                                                                                                            // 5502
          flush_pending(strm);                                                                                         // 5503
          beg = s.pending;                                                                                             // 5504
          if (s.pending === s.pending_buf_size) {                                                                      // 5505
            val = 1;                                                                                                   // 5506
            break;                                                                                                     // 5507
          }                                                                                                            // 5508
        }                                                                                                              // 5509
        // JS specific: little magic to add zero terminator to end of string                                           // 5510
        if (s.gzindex < s.gzhead.comment.length) {                                                                     // 5511
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;                                                       // 5512
        } else {                                                                                                       // 5513
          val = 0;                                                                                                     // 5514
        }                                                                                                              // 5515
        put_byte(s, val);                                                                                              // 5516
      } while (val !== 0);                                                                                             // 5517
                                                                                                                       // 5518
      if (s.gzhead.hcrc && s.pending > beg) {                                                                          // 5519
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);                                           // 5520
      }                                                                                                                // 5521
      if (val === 0) {                                                                                                 // 5522
        s.status = HCRC_STATE;                                                                                         // 5523
      }                                                                                                                // 5524
    }                                                                                                                  // 5525
    else {                                                                                                             // 5526
      s.status = HCRC_STATE;                                                                                           // 5527
    }                                                                                                                  // 5528
  }                                                                                                                    // 5529
  if (s.status === HCRC_STATE) {                                                                                       // 5530
    if (s.gzhead.hcrc) {                                                                                               // 5531
      if (s.pending + 2 > s.pending_buf_size) {                                                                        // 5532
        flush_pending(strm);                                                                                           // 5533
      }                                                                                                                // 5534
      if (s.pending + 2 <= s.pending_buf_size) {                                                                       // 5535
        put_byte(s, strm.adler & 0xff);                                                                                // 5536
        put_byte(s, (strm.adler >> 8) & 0xff);                                                                         // 5537
        strm.adler = 0; //crc32(0L, Z_NULL, 0);                                                                        // 5538
        s.status = BUSY_STATE;                                                                                         // 5539
      }                                                                                                                // 5540
    }                                                                                                                  // 5541
    else {                                                                                                             // 5542
      s.status = BUSY_STATE;                                                                                           // 5543
    }                                                                                                                  // 5544
  }                                                                                                                    // 5545
//#endif                                                                                                               // 5546
                                                                                                                       // 5547
  /* Flush as much pending output as possible */                                                                       // 5548
  if (s.pending !== 0) {                                                                                               // 5549
    flush_pending(strm);                                                                                               // 5550
    if (strm.avail_out === 0) {                                                                                        // 5551
      /* Since avail_out is 0, deflate will be called again with                                                       // 5552
       * more output space, but possibly with both pending and                                                         // 5553
       * avail_in equal to zero. There won't be anything to do,                                                        // 5554
       * but this is not an error situation so make sure we                                                            // 5555
       * return OK instead of BUF_ERROR at next call of deflate:                                                       // 5556
       */                                                                                                              // 5557
      s.last_flush = -1;                                                                                               // 5558
      return Z_OK;                                                                                                     // 5559
    }                                                                                                                  // 5560
                                                                                                                       // 5561
    /* Make sure there is something to do and avoid duplicate consecutive                                              // 5562
     * flushes. For repeated and useless calls with Z_FINISH, we keep                                                  // 5563
     * returning Z_STREAM_END instead of Z_BUF_ERROR.                                                                  // 5564
     */                                                                                                                // 5565
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&                                                  // 5566
    flush !== Z_FINISH) {                                                                                              // 5567
    return err(strm, Z_BUF_ERROR);                                                                                     // 5568
  }                                                                                                                    // 5569
                                                                                                                       // 5570
  /* User must not provide more input after the first FINISH: */                                                       // 5571
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {                                                              // 5572
    return err(strm, Z_BUF_ERROR);                                                                                     // 5573
  }                                                                                                                    // 5574
                                                                                                                       // 5575
  /* Start a new block or continue the current one.                                                                    // 5576
   */                                                                                                                  // 5577
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||                                                                      // 5578
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {                                                             // 5579
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :                                            // 5580
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :                                                                  // 5581
        configuration_table[s.level].func(s, flush));                                                                  // 5582
                                                                                                                       // 5583
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {                                                   // 5584
      s.status = FINISH_STATE;                                                                                         // 5585
    }                                                                                                                  // 5586
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {                                                     // 5587
      if (strm.avail_out === 0) {                                                                                      // 5588
        s.last_flush = -1;                                                                                             // 5589
        /* avoid BUF_ERROR next call, see above */                                                                     // 5590
      }                                                                                                                // 5591
      return Z_OK;                                                                                                     // 5592
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call                                                       // 5593
       * of deflate should use the same flush parameter to make sure                                                   // 5594
       * that the flush is complete. So we don't have to output an                                                     // 5595
       * empty block here, this will be done at next call. This also                                                   // 5596
       * ensures that for a very small output buffer, we emit at most                                                  // 5597
       * one empty block.                                                                                              // 5598
       */                                                                                                              // 5599
    }                                                                                                                  // 5600
    if (bstate === BS_BLOCK_DONE) {                                                                                    // 5601
      if (flush === Z_PARTIAL_FLUSH) {                                                                                 // 5602
        trees._tr_align(s);                                                                                            // 5603
      }                                                                                                                // 5604
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */                                                     // 5605
                                                                                                                       // 5606
        trees._tr_stored_block(s, 0, 0, false);                                                                        // 5607
        /* For a full flush, this empty block will be recognized                                                       // 5608
         * as a special marker by inflate_sync().                                                                      // 5609
         */                                                                                                            // 5610
        if (flush === Z_FULL_FLUSH) {                                                                                  // 5611
          /*** CLEAR_HASH(s); ***/             /* forget history */                                                    // 5612
          zero(s.head); // Fill with NIL (= 0);                                                                        // 5613
                                                                                                                       // 5614
          if (s.lookahead === 0) {                                                                                     // 5615
            s.strstart = 0;                                                                                            // 5616
            s.block_start = 0;                                                                                         // 5617
            s.insert = 0;                                                                                              // 5618
          }                                                                                                            // 5619
        }                                                                                                              // 5620
      }                                                                                                                // 5621
      flush_pending(strm);                                                                                             // 5622
      if (strm.avail_out === 0) {                                                                                      // 5623
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */                                               // 5624
        return Z_OK;                                                                                                   // 5625
      }                                                                                                                // 5626
    }                                                                                                                  // 5627
  }                                                                                                                    // 5628
  //Assert(strm->avail_out > 0, "bug2");                                                                               // 5629
  //if (strm.avail_out <= 0) { throw new Error("bug2");}                                                               // 5630
                                                                                                                       // 5631
  if (flush !== Z_FINISH) { return Z_OK; }                                                                             // 5632
  if (s.wrap <= 0) { return Z_STREAM_END; }                                                                            // 5633
                                                                                                                       // 5634
  /* Write the trailer */                                                                                              // 5635
  if (s.wrap === 2) {                                                                                                  // 5636
    put_byte(s, strm.adler & 0xff);                                                                                    // 5637
    put_byte(s, (strm.adler >> 8) & 0xff);                                                                             // 5638
    put_byte(s, (strm.adler >> 16) & 0xff);                                                                            // 5639
    put_byte(s, (strm.adler >> 24) & 0xff);                                                                            // 5640
    put_byte(s, strm.total_in & 0xff);                                                                                 // 5641
    put_byte(s, (strm.total_in >> 8) & 0xff);                                                                          // 5642
    put_byte(s, (strm.total_in >> 16) & 0xff);                                                                         // 5643
    put_byte(s, (strm.total_in >> 24) & 0xff);                                                                         // 5644
  }                                                                                                                    // 5645
  else                                                                                                                 // 5646
  {                                                                                                                    // 5647
    putShortMSB(s, strm.adler >>> 16);                                                                                 // 5648
    putShortMSB(s, strm.adler & 0xffff);                                                                               // 5649
  }                                                                                                                    // 5650
                                                                                                                       // 5651
  flush_pending(strm);                                                                                                 // 5652
  /* If avail_out is zero, the application will call deflate again                                                     // 5653
   * to flush the rest.                                                                                                // 5654
   */                                                                                                                  // 5655
  if (s.wrap > 0) { s.wrap = -s.wrap; }                                                                                // 5656
  /* write the trailer only once! */                                                                                   // 5657
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;                                                                        // 5658
}                                                                                                                      // 5659
                                                                                                                       // 5660
function deflateEnd(strm) {                                                                                            // 5661
  var status;                                                                                                          // 5662
                                                                                                                       // 5663
  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {                                                                // 5664
    return Z_STREAM_ERROR;                                                                                             // 5665
  }                                                                                                                    // 5666
                                                                                                                       // 5667
  status = strm.state.status;                                                                                          // 5668
  if (status !== INIT_STATE &&                                                                                         // 5669
    status !== EXTRA_STATE &&                                                                                          // 5670
    status !== NAME_STATE &&                                                                                           // 5671
    status !== COMMENT_STATE &&                                                                                        // 5672
    status !== HCRC_STATE &&                                                                                           // 5673
    status !== BUSY_STATE &&                                                                                           // 5674
    status !== FINISH_STATE                                                                                            // 5675
  ) {                                                                                                                  // 5676
    return err(strm, Z_STREAM_ERROR);                                                                                  // 5677
  }                                                                                                                    // 5678
                                                                                                                       // 5679
  strm.state = null;                                                                                                   // 5680
                                                                                                                       // 5681
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;                                                       // 5682
}                                                                                                                      // 5683
                                                                                                                       // 5684
/* =========================================================================                                           // 5685
 * Copy the source state to the destination state                                                                      // 5686
 */                                                                                                                    // 5687
//function deflateCopy(dest, source) {                                                                                 // 5688
//                                                                                                                     // 5689
//}                                                                                                                    // 5690
                                                                                                                       // 5691
exports.deflateInit = deflateInit;                                                                                     // 5692
exports.deflateInit2 = deflateInit2;                                                                                   // 5693
exports.deflateReset = deflateReset;                                                                                   // 5694
exports.deflateResetKeep = deflateResetKeep;                                                                           // 5695
exports.deflateSetHeader = deflateSetHeader;                                                                           // 5696
exports.deflate = deflate;                                                                                             // 5697
exports.deflateEnd = deflateEnd;                                                                                       // 5698
exports.deflateInfo = 'pako deflate (from Nodeca project)';                                                            // 5699
                                                                                                                       // 5700
/* Not implemented                                                                                                     // 5701
exports.deflateBound = deflateBound;                                                                                   // 5702
exports.deflateCopy = deflateCopy;                                                                                     // 5703
exports.deflateSetDictionary = deflateSetDictionary;                                                                   // 5704
exports.deflateParams = deflateParams;                                                                                 // 5705
exports.deflatePending = deflatePending;                                                                               // 5706
exports.deflatePrime = deflatePrime;                                                                                   // 5707
exports.deflateTune = deflateTune;                                                                                     // 5708
*/                                                                                                                     // 5709
},{"../utils/common":27,"./adler32":29,"./crc32":31,"./messages":37,"./trees":38}],33:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 5711
                                                                                                                       // 5712
                                                                                                                       // 5713
function GZheader() {                                                                                                  // 5714
  /* true if compressed data believed to be text */                                                                    // 5715
  this.text       = 0;                                                                                                 // 5716
  /* modification time */                                                                                              // 5717
  this.time       = 0;                                                                                                 // 5718
  /* extra flags (not used when writing a gzip file) */                                                                // 5719
  this.xflags     = 0;                                                                                                 // 5720
  /* operating system */                                                                                               // 5721
  this.os         = 0;                                                                                                 // 5722
  /* pointer to extra field or Z_NULL if none */                                                                       // 5723
  this.extra      = null;                                                                                              // 5724
  /* extra field length (valid if extra != Z_NULL) */                                                                  // 5725
  this.extra_len  = 0; // Actually, we don't need it in JS,                                                            // 5726
                       // but leave for few code modifications                                                         // 5727
                                                                                                                       // 5728
  //                                                                                                                   // 5729
  // Setup limits is not necessary because in js we should not preallocate memory                                      // 5730
  // for inflate use constant limit in 65536 bytes                                                                     // 5731
  //                                                                                                                   // 5732
                                                                                                                       // 5733
  /* space at extra (only when reading header) */                                                                      // 5734
  // this.extra_max  = 0;                                                                                              // 5735
  /* pointer to zero-terminated file name or Z_NULL */                                                                 // 5736
  this.name       = '';                                                                                                // 5737
  /* space at name (only when reading header) */                                                                       // 5738
  // this.name_max   = 0;                                                                                              // 5739
  /* pointer to zero-terminated comment or Z_NULL */                                                                   // 5740
  this.comment    = '';                                                                                                // 5741
  /* space at comment (only when reading header) */                                                                    // 5742
  // this.comm_max   = 0;                                                                                              // 5743
  /* true if there was or will be a header crc */                                                                      // 5744
  this.hcrc       = 0;                                                                                                 // 5745
  /* true when done reading gzip header (not used when writing a gzip file) */                                         // 5746
  this.done       = false;                                                                                             // 5747
}                                                                                                                      // 5748
                                                                                                                       // 5749
module.exports = GZheader;                                                                                             // 5750
},{}],34:[function(_dereq_,module,exports){                                                                            // 5751
'use strict';                                                                                                          // 5752
                                                                                                                       // 5753
// See state defs from inflate.js                                                                                      // 5754
var BAD = 30;       /* got a data error -- remain here until reset */                                                  // 5755
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */                                            // 5756
                                                                                                                       // 5757
/*                                                                                                                     // 5758
   Decode literal, length, and distance codes and write out the resulting                                              // 5759
   literal and match bytes until either not enough input or output is                                                  // 5760
   available, an end-of-block is encountered, or a data error is encountered.                                          // 5761
   When large enough input and output buffers are supplied to inflate(), for                                           // 5762
   example, a 16K input buffer and a 64K output buffer, more than 95% of the                                           // 5763
   inflate execution time is spent in this routine.                                                                    // 5764
                                                                                                                       // 5765
   Entry assumptions:                                                                                                  // 5766
                                                                                                                       // 5767
        state.mode === LEN                                                                                             // 5768
        strm.avail_in >= 6                                                                                             // 5769
        strm.avail_out >= 258                                                                                          // 5770
        start >= strm.avail_out                                                                                        // 5771
        state.bits < 8                                                                                                 // 5772
                                                                                                                       // 5773
   On return, state.mode is one of:                                                                                    // 5774
                                                                                                                       // 5775
        LEN -- ran out of enough output space or enough available input                                                // 5776
        TYPE -- reached end of block code, inflate() to interpret next block                                           // 5777
        BAD -- error in block data                                                                                     // 5778
                                                                                                                       // 5779
   Notes:                                                                                                              // 5780
                                                                                                                       // 5781
    - The maximum input bits used by a length/distance pair is 15 bits for the                                         // 5782
      length code, 5 bits for the length extra, 15 bits for the distance code,                                         // 5783
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.                                          // 5784
      Therefore if strm.avail_in >= 6, then there is enough input to avoid                                             // 5785
      checking for available input while decoding.                                                                     // 5786
                                                                                                                       // 5787
    - The maximum bytes that a single length/distance pair can output is 258                                           // 5788
      bytes, which is the maximum length that can be coded.  inflate_fast()                                            // 5789
      requires strm.avail_out >= 258 for each loop to avoid checking for                                               // 5790
      output space.                                                                                                    // 5791
 */                                                                                                                    // 5792
module.exports = function inflate_fast(strm, start) {                                                                  // 5793
  var state;                                                                                                           // 5794
  var _in;                    /* local strm.input */                                                                   // 5795
  var last;                   /* have enough input while in < last */                                                  // 5796
  var _out;                   /* local strm.output */                                                                  // 5797
  var beg;                    /* inflate()'s initial strm.output */                                                    // 5798
  var end;                    /* while out < end, enough space available */                                            // 5799
//#ifdef INFLATE_STRICT                                                                                                // 5800
  var dmax;                   /* maximum distance from zlib header */                                                  // 5801
//#endif                                                                                                               // 5802
  var wsize;                  /* window size or zero if not using window */                                            // 5803
  var whave;                  /* valid bytes in the window */                                                          // 5804
  var wnext;                  /* window write index */                                                                 // 5805
  var window;                 /* allocated sliding window, if wsize != 0 */                                            // 5806
  var hold;                   /* local strm.hold */                                                                    // 5807
  var bits;                   /* local strm.bits */                                                                    // 5808
  var lcode;                  /* local strm.lencode */                                                                 // 5809
  var dcode;                  /* local strm.distcode */                                                                // 5810
  var lmask;                  /* mask for first level of length codes */                                               // 5811
  var dmask;                  /* mask for first level of distance codes */                                             // 5812
  var here;                   /* retrieved table entry */                                                              // 5813
  var op;                     /* code bits, operation, extra bits, or */                                               // 5814
                              /*  window position, window bytes to copy */                                             // 5815
  var len;                    /* match length, unused bytes */                                                         // 5816
  var dist;                   /* match distance */                                                                     // 5817
  var from;                   /* where to copy match from */                                                           // 5818
  var from_source;                                                                                                     // 5819
                                                                                                                       // 5820
                                                                                                                       // 5821
  var input, output; // JS specific, because we have no pointers                                                       // 5822
                                                                                                                       // 5823
  /* copy state to local variables */                                                                                  // 5824
  state = strm.state;                                                                                                  // 5825
  //here = state.here;                                                                                                 // 5826
  _in = strm.next_in;                                                                                                  // 5827
  input = strm.input;                                                                                                  // 5828
  last = _in + (strm.avail_in - 5);                                                                                    // 5829
  _out = strm.next_out;                                                                                                // 5830
  output = strm.output;                                                                                                // 5831
  beg = _out - (start - strm.avail_out);                                                                               // 5832
  end = _out + (strm.avail_out - 257);                                                                                 // 5833
//#ifdef INFLATE_STRICT                                                                                                // 5834
  dmax = state.dmax;                                                                                                   // 5835
//#endif                                                                                                               // 5836
  wsize = state.wsize;                                                                                                 // 5837
  whave = state.whave;                                                                                                 // 5838
  wnext = state.wnext;                                                                                                 // 5839
  window = state.window;                                                                                               // 5840
  hold = state.hold;                                                                                                   // 5841
  bits = state.bits;                                                                                                   // 5842
  lcode = state.lencode;                                                                                               // 5843
  dcode = state.distcode;                                                                                              // 5844
  lmask = (1 << state.lenbits) - 1;                                                                                    // 5845
  dmask = (1 << state.distbits) - 1;                                                                                   // 5846
                                                                                                                       // 5847
                                                                                                                       // 5848
  /* decode literals and length/distances until end-of-block or not enough                                             // 5849
     input data or output space */                                                                                     // 5850
                                                                                                                       // 5851
  top:                                                                                                                 // 5852
  do {                                                                                                                 // 5853
    if (bits < 15) {                                                                                                   // 5854
      hold += input[_in++] << bits;                                                                                    // 5855
      bits += 8;                                                                                                       // 5856
      hold += input[_in++] << bits;                                                                                    // 5857
      bits += 8;                                                                                                       // 5858
    }                                                                                                                  // 5859
                                                                                                                       // 5860
    here = lcode[hold & lmask];                                                                                        // 5861
                                                                                                                       // 5862
    dolen:                                                                                                             // 5863
    for (;;) { // Goto emulation                                                                                       // 5864
      op = here >>> 24/*here.bits*/;                                                                                   // 5865
      hold >>>= op;                                                                                                    // 5866
      bits -= op;                                                                                                      // 5867
      op = (here >>> 16) & 0xff/*here.op*/;                                                                            // 5868
      if (op === 0) {                          /* literal */                                                           // 5869
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?                                                       // 5870
        //        "inflate:         literal '%c'\n" :                                                                  // 5871
        //        "inflate:         literal 0x%02x\n", here.val));                                                     // 5872
        output[_out++] = here & 0xffff/*here.val*/;                                                                    // 5873
      }                                                                                                                // 5874
      else if (op & 16) {                     /* length base */                                                        // 5875
        len = here & 0xffff/*here.val*/;                                                                               // 5876
        op &= 15;                           /* number of extra bits */                                                 // 5877
        if (op) {                                                                                                      // 5878
          if (bits < op) {                                                                                             // 5879
            hold += input[_in++] << bits;                                                                              // 5880
            bits += 8;                                                                                                 // 5881
          }                                                                                                            // 5882
          len += hold & ((1 << op) - 1);                                                                               // 5883
          hold >>>= op;                                                                                                // 5884
          bits -= op;                                                                                                  // 5885
        }                                                                                                              // 5886
        //Tracevv((stderr, "inflate:         length %u\n", len));                                                      // 5887
        if (bits < 15) {                                                                                               // 5888
          hold += input[_in++] << bits;                                                                                // 5889
          bits += 8;                                                                                                   // 5890
          hold += input[_in++] << bits;                                                                                // 5891
          bits += 8;                                                                                                   // 5892
        }                                                                                                              // 5893
        here = dcode[hold & dmask];                                                                                    // 5894
                                                                                                                       // 5895
        dodist:                                                                                                        // 5896
        for (;;) { // goto emulation                                                                                   // 5897
          op = here >>> 24/*here.bits*/;                                                                               // 5898
          hold >>>= op;                                                                                                // 5899
          bits -= op;                                                                                                  // 5900
          op = (here >>> 16) & 0xff/*here.op*/;                                                                        // 5901
                                                                                                                       // 5902
          if (op & 16) {                      /* distance base */                                                      // 5903
            dist = here & 0xffff/*here.val*/;                                                                          // 5904
            op &= 15;                       /* number of extra bits */                                                 // 5905
            if (bits < op) {                                                                                           // 5906
              hold += input[_in++] << bits;                                                                            // 5907
              bits += 8;                                                                                               // 5908
              if (bits < op) {                                                                                         // 5909
                hold += input[_in++] << bits;                                                                          // 5910
                bits += 8;                                                                                             // 5911
              }                                                                                                        // 5912
            }                                                                                                          // 5913
            dist += hold & ((1 << op) - 1);                                                                            // 5914
//#ifdef INFLATE_STRICT                                                                                                // 5915
            if (dist > dmax) {                                                                                         // 5916
              strm.msg = 'invalid distance too far back';                                                              // 5917
              state.mode = BAD;                                                                                        // 5918
              break top;                                                                                               // 5919
            }                                                                                                          // 5920
//#endif                                                                                                               // 5921
            hold >>>= op;                                                                                              // 5922
            bits -= op;                                                                                                // 5923
            //Tracevv((stderr, "inflate:         distance %u\n", dist));                                               // 5924
            op = _out - beg;                /* max distance in output */                                               // 5925
            if (dist > op) {                /* see if copy from window */                                              // 5926
              op = dist - op;               /* distance back in window */                                              // 5927
              if (op > whave) {                                                                                        // 5928
                if (state.sane) {                                                                                      // 5929
                  strm.msg = 'invalid distance too far back';                                                          // 5930
                  state.mode = BAD;                                                                                    // 5931
                  break top;                                                                                           // 5932
                }                                                                                                      // 5933
                                                                                                                       // 5934
// (!) This block is disabled in zlib defailts,                                                                        // 5935
// don't enable it for binary compatibility                                                                            // 5936
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR                                                                    // 5937
//                if (len <= op - whave) {                                                                             // 5938
//                  do {                                                                                               // 5939
//                    output[_out++] = 0;                                                                              // 5940
//                  } while (--len);                                                                                   // 5941
//                  continue top;                                                                                      // 5942
//                }                                                                                                    // 5943
//                len -= op - whave;                                                                                   // 5944
//                do {                                                                                                 // 5945
//                  output[_out++] = 0;                                                                                // 5946
//                } while (--op > whave);                                                                              // 5947
//                if (op === 0) {                                                                                      // 5948
//                  from = _out - dist;                                                                                // 5949
//                  do {                                                                                               // 5950
//                    output[_out++] = output[from++];                                                                 // 5951
//                  } while (--len);                                                                                   // 5952
//                  continue top;                                                                                      // 5953
//                }                                                                                                    // 5954
//#endif                                                                                                               // 5955
              }                                                                                                        // 5956
              from = 0; // window index                                                                                // 5957
              from_source = window;                                                                                    // 5958
              if (wnext === 0) {           /* very common case */                                                      // 5959
                from += wsize - op;                                                                                    // 5960
                if (op < len) {         /* some from window */                                                         // 5961
                  len -= op;                                                                                           // 5962
                  do {                                                                                                 // 5963
                    output[_out++] = window[from++];                                                                   // 5964
                  } while (--op);                                                                                      // 5965
                  from = _out - dist;  /* rest from output */                                                          // 5966
                  from_source = output;                                                                                // 5967
                }                                                                                                      // 5968
              }                                                                                                        // 5969
              else if (wnext < op) {      /* wrap around window */                                                     // 5970
                from += wsize + wnext - op;                                                                            // 5971
                op -= wnext;                                                                                           // 5972
                if (op < len) {         /* some from end of window */                                                  // 5973
                  len -= op;                                                                                           // 5974
                  do {                                                                                                 // 5975
                    output[_out++] = window[from++];                                                                   // 5976
                  } while (--op);                                                                                      // 5977
                  from = 0;                                                                                            // 5978
                  if (wnext < len) {  /* some from start of window */                                                  // 5979
                    op = wnext;                                                                                        // 5980
                    len -= op;                                                                                         // 5981
                    do {                                                                                               // 5982
                      output[_out++] = window[from++];                                                                 // 5983
                    } while (--op);                                                                                    // 5984
                    from = _out - dist;      /* rest from output */                                                    // 5985
                    from_source = output;                                                                              // 5986
                  }                                                                                                    // 5987
                }                                                                                                      // 5988
              }                                                                                                        // 5989
              else {                      /* contiguous in window */                                                   // 5990
                from += wnext - op;                                                                                    // 5991
                if (op < len) {         /* some from window */                                                         // 5992
                  len -= op;                                                                                           // 5993
                  do {                                                                                                 // 5994
                    output[_out++] = window[from++];                                                                   // 5995
                  } while (--op);                                                                                      // 5996
                  from = _out - dist;  /* rest from output */                                                          // 5997
                  from_source = output;                                                                                // 5998
                }                                                                                                      // 5999
              }                                                                                                        // 6000
              while (len > 2) {                                                                                        // 6001
                output[_out++] = from_source[from++];                                                                  // 6002
                output[_out++] = from_source[from++];                                                                  // 6003
                output[_out++] = from_source[from++];                                                                  // 6004
                len -= 3;                                                                                              // 6005
              }                                                                                                        // 6006
              if (len) {                                                                                               // 6007
                output[_out++] = from_source[from++];                                                                  // 6008
                if (len > 1) {                                                                                         // 6009
                  output[_out++] = from_source[from++];                                                                // 6010
                }                                                                                                      // 6011
              }                                                                                                        // 6012
            }                                                                                                          // 6013
            else {                                                                                                     // 6014
              from = _out - dist;          /* copy direct from output */                                               // 6015
              do {                        /* minimum length is three */                                                // 6016
                output[_out++] = output[from++];                                                                       // 6017
                output[_out++] = output[from++];                                                                       // 6018
                output[_out++] = output[from++];                                                                       // 6019
                len -= 3;                                                                                              // 6020
              } while (len > 2);                                                                                       // 6021
              if (len) {                                                                                               // 6022
                output[_out++] = output[from++];                                                                       // 6023
                if (len > 1) {                                                                                         // 6024
                  output[_out++] = output[from++];                                                                     // 6025
                }                                                                                                      // 6026
              }                                                                                                        // 6027
            }                                                                                                          // 6028
          }                                                                                                            // 6029
          else if ((op & 64) === 0) {          /* 2nd level distance code */                                           // 6030
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];                                      // 6031
            continue dodist;                                                                                           // 6032
          }                                                                                                            // 6033
          else {                                                                                                       // 6034
            strm.msg = 'invalid distance code';                                                                        // 6035
            state.mode = BAD;                                                                                          // 6036
            break top;                                                                                                 // 6037
          }                                                                                                            // 6038
                                                                                                                       // 6039
          break; // need to emulate goto via "continue"                                                                // 6040
        }                                                                                                              // 6041
      }                                                                                                                // 6042
      else if ((op & 64) === 0) {              /* 2nd level length code */                                             // 6043
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];                                          // 6044
        continue dolen;                                                                                                // 6045
      }                                                                                                                // 6046
      else if (op & 32) {                     /* end-of-block */                                                       // 6047
        //Tracevv((stderr, "inflate:         end of block\n"));                                                        // 6048
        state.mode = TYPE;                                                                                             // 6049
        break top;                                                                                                     // 6050
      }                                                                                                                // 6051
      else {                                                                                                           // 6052
        strm.msg = 'invalid literal/length code';                                                                      // 6053
        state.mode = BAD;                                                                                              // 6054
        break top;                                                                                                     // 6055
      }                                                                                                                // 6056
                                                                                                                       // 6057
      break; // need to emulate goto via "continue"                                                                    // 6058
    }                                                                                                                  // 6059
  } while (_in < last && _out < end);                                                                                  // 6060
                                                                                                                       // 6061
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */                                          // 6062
  len = bits >> 3;                                                                                                     // 6063
  _in -= len;                                                                                                          // 6064
  bits -= len << 3;                                                                                                    // 6065
  hold &= (1 << bits) - 1;                                                                                             // 6066
                                                                                                                       // 6067
  /* update state and return */                                                                                        // 6068
  strm.next_in = _in;                                                                                                  // 6069
  strm.next_out = _out;                                                                                                // 6070
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));                                                  // 6071
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));                                             // 6072
  state.hold = hold;                                                                                                   // 6073
  state.bits = bits;                                                                                                   // 6074
  return;                                                                                                              // 6075
};                                                                                                                     // 6076
                                                                                                                       // 6077
},{}],35:[function(_dereq_,module,exports){                                                                            // 6078
'use strict';                                                                                                          // 6079
                                                                                                                       // 6080
                                                                                                                       // 6081
var utils = _dereq_('../utils/common');                                                                                // 6082
var adler32 = _dereq_('./adler32');                                                                                    // 6083
var crc32   = _dereq_('./crc32');                                                                                      // 6084
var inflate_fast = _dereq_('./inffast');                                                                               // 6085
var inflate_table = _dereq_('./inftrees');                                                                             // 6086
                                                                                                                       // 6087
var CODES = 0;                                                                                                         // 6088
var LENS = 1;                                                                                                          // 6089
var DISTS = 2;                                                                                                         // 6090
                                                                                                                       // 6091
/* Public constants ==========================================================*/                                       // 6092
/* ===========================================================================*/                                       // 6093
                                                                                                                       // 6094
                                                                                                                       // 6095
/* Allowed flush values; see deflate() and inflate() below for details */                                              // 6096
//var Z_NO_FLUSH      = 0;                                                                                             // 6097
//var Z_PARTIAL_FLUSH = 1;                                                                                             // 6098
//var Z_SYNC_FLUSH    = 2;                                                                                             // 6099
//var Z_FULL_FLUSH    = 3;                                                                                             // 6100
var Z_FINISH        = 4;                                                                                               // 6101
var Z_BLOCK         = 5;                                                                                               // 6102
var Z_TREES         = 6;                                                                                               // 6103
                                                                                                                       // 6104
                                                                                                                       // 6105
/* Return codes for the compression/decompression functions. Negative values                                           // 6106
 * are errors, positive values are used for special but normal events.                                                 // 6107
 */                                                                                                                    // 6108
var Z_OK            = 0;                                                                                               // 6109
var Z_STREAM_END    = 1;                                                                                               // 6110
var Z_NEED_DICT     = 2;                                                                                               // 6111
//var Z_ERRNO         = -1;                                                                                            // 6112
var Z_STREAM_ERROR  = -2;                                                                                              // 6113
var Z_DATA_ERROR    = -3;                                                                                              // 6114
var Z_MEM_ERROR     = -4;                                                                                              // 6115
var Z_BUF_ERROR     = -5;                                                                                              // 6116
//var Z_VERSION_ERROR = -6;                                                                                            // 6117
                                                                                                                       // 6118
/* The deflate compression method */                                                                                   // 6119
var Z_DEFLATED  = 8;                                                                                                   // 6120
                                                                                                                       // 6121
                                                                                                                       // 6122
/* STATES ====================================================================*/                                       // 6123
/* ===========================================================================*/                                       // 6124
                                                                                                                       // 6125
                                                                                                                       // 6126
var    HEAD = 1;       /* i: waiting for magic header */                                                               // 6127
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */                                                    // 6128
var    TIME = 3;       /* i: waiting for modification time (gzip) */                                                   // 6129
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */                                    // 6130
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */                                                        // 6131
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */                                                         // 6132
var    NAME = 7;       /* i: waiting for end of file name (gzip) */                                                    // 6133
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */                                                      // 6134
var    HCRC = 9;       /* i: waiting for header crc (gzip) */                                                          // 6135
var    DICTID = 10;    /* i: waiting for dictionary check value */                                                     // 6136
var    DICT = 11;      /* waiting for inflateSetDictionary() call */                                                   // 6137
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */                                     // 6138
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */                                  // 6139
var        STORED = 14;    /* i: waiting for stored size (length and complement) */                                    // 6140
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */                                       // 6141
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */                                 // 6142
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */                                            // 6143
var        LENLENS = 18;   /* i: waiting for code length code lengths */                                               // 6144
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */                                   // 6145
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */                                      // 6146
var            LEN = 21;       /* i: waiting for length/lit/eob code */                                                // 6147
var            LENEXT = 22;    /* i: waiting for length extra bits */                                                  // 6148
var            DIST = 23;      /* i: waiting for distance code */                                                      // 6149
var            DISTEXT = 24;   /* i: waiting for distance extra bits */                                                // 6150
var            MATCH = 25;     /* o: waiting for output space to copy string */                                        // 6151
var            LIT = 26;       /* o: waiting for output space to write literal */                                      // 6152
var    CHECK = 27;     /* i: waiting for 32-bit check value */                                                         // 6153
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */                                                       // 6154
var    DONE = 29;      /* finished check, done -- remain here until reset */                                           // 6155
var    BAD = 30;       /* got a data error -- remain here until reset */                                               // 6156
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */                                  // 6157
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */                                    // 6158
                                                                                                                       // 6159
/* ===========================================================================*/                                       // 6160
                                                                                                                       // 6161
                                                                                                                       // 6162
                                                                                                                       // 6163
var ENOUGH_LENS = 852;                                                                                                 // 6164
var ENOUGH_DISTS = 592;                                                                                                // 6165
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);                                                                            // 6166
                                                                                                                       // 6167
var MAX_WBITS = 15;                                                                                                    // 6168
/* 32K LZ77 window */                                                                                                  // 6169
var DEF_WBITS = MAX_WBITS;                                                                                             // 6170
                                                                                                                       // 6171
                                                                                                                       // 6172
function ZSWAP32(q) {                                                                                                  // 6173
  return  (((q >>> 24) & 0xff) +                                                                                       // 6174
          ((q >>> 8) & 0xff00) +                                                                                       // 6175
          ((q & 0xff00) << 8) +                                                                                        // 6176
          ((q & 0xff) << 24));                                                                                         // 6177
}                                                                                                                      // 6178
                                                                                                                       // 6179
                                                                                                                       // 6180
function InflateState() {                                                                                              // 6181
  this.mode = 0;             /* current inflate mode */                                                                // 6182
  this.last = false;          /* true if processing last block */                                                      // 6183
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */                                           // 6184
  this.havedict = false;      /* true if dictionary provided */                                                        // 6185
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */                                           // 6186
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */                                          // 6187
  this.check = 0;             /* protected copy of check value */                                                      // 6188
  this.total = 0;             /* protected copy of output count */                                                     // 6189
  // TODO: may be {}                                                                                                   // 6190
  this.head = null;           /* where to save gzip header information */                                              // 6191
                                                                                                                       // 6192
  /* sliding window */                                                                                                 // 6193
  this.wbits = 0;             /* log base 2 of requested window size */                                                // 6194
  this.wsize = 0;             /* window size or zero if not using window */                                            // 6195
  this.whave = 0;             /* valid bytes in the window */                                                          // 6196
  this.wnext = 0;             /* window write index */                                                                 // 6197
  this.window = null;         /* allocated sliding window, if needed */                                                // 6198
                                                                                                                       // 6199
  /* bit accumulator */                                                                                                // 6200
  this.hold = 0;              /* input bit accumulator */                                                              // 6201
  this.bits = 0;              /* number of bits in "in" */                                                             // 6202
                                                                                                                       // 6203
  /* for string and stored block copying */                                                                            // 6204
  this.length = 0;            /* literal or length of data to copy */                                                  // 6205
  this.offset = 0;            /* distance back to copy string from */                                                  // 6206
                                                                                                                       // 6207
  /* for table and code decoding */                                                                                    // 6208
  this.extra = 0;             /* extra bits needed */                                                                  // 6209
                                                                                                                       // 6210
  /* fixed and dynamic code tables */                                                                                  // 6211
  this.lencode = null;          /* starting table for length/literal codes */                                          // 6212
  this.distcode = null;         /* starting table for distance codes */                                                // 6213
  this.lenbits = 0;           /* index bits for lencode */                                                             // 6214
  this.distbits = 0;          /* index bits for distcode */                                                            // 6215
                                                                                                                       // 6216
  /* dynamic table building */                                                                                         // 6217
  this.ncode = 0;             /* number of code length code lengths */                                                 // 6218
  this.nlen = 0;              /* number of length code lengths */                                                      // 6219
  this.ndist = 0;             /* number of distance code lengths */                                                    // 6220
  this.have = 0;              /* number of code lengths in lens[] */                                                   // 6221
  this.next = null;              /* next available space in codes[] */                                                 // 6222
                                                                                                                       // 6223
  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */                                           // 6224
  this.work = new utils.Buf16(288); /* work area for code table building */                                            // 6225
                                                                                                                       // 6226
  /*                                                                                                                   // 6227
   because we don't have pointers in js, we use lencode and distcode directly                                          // 6228
   as buffers so we don't need codes                                                                                   // 6229
  */                                                                                                                   // 6230
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */                                            // 6231
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */                          // 6232
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */                                // 6233
  this.sane = 0;                   /* if false, allow invalid distance too far */                                      // 6234
  this.back = 0;                   /* bits back of last unprocessed length/lit */                                      // 6235
  this.was = 0;                    /* initial length of match */                                                       // 6236
}                                                                                                                      // 6237
                                                                                                                       // 6238
function inflateResetKeep(strm) {                                                                                      // 6239
  var state;                                                                                                           // 6240
                                                                                                                       // 6241
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }                                                                 // 6242
  state = strm.state;                                                                                                  // 6243
  strm.total_in = strm.total_out = state.total = 0;                                                                    // 6244
  strm.msg = ''; /*Z_NULL*/                                                                                            // 6245
  if (state.wrap) {       /* to support ill-conceived Java test suite */                                               // 6246
    strm.adler = state.wrap & 1;                                                                                       // 6247
  }                                                                                                                    // 6248
  state.mode = HEAD;                                                                                                   // 6249
  state.last = 0;                                                                                                      // 6250
  state.havedict = 0;                                                                                                  // 6251
  state.dmax = 32768;                                                                                                  // 6252
  state.head = null/*Z_NULL*/;                                                                                         // 6253
  state.hold = 0;                                                                                                      // 6254
  state.bits = 0;                                                                                                      // 6255
  //state.lencode = state.distcode = state.next = state.codes;                                                         // 6256
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);                                                         // 6257
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);                                                      // 6258
                                                                                                                       // 6259
  state.sane = 1;                                                                                                      // 6260
  state.back = -1;                                                                                                     // 6261
  //Tracev((stderr, "inflate: reset\n"));                                                                              // 6262
  return Z_OK;                                                                                                         // 6263
}                                                                                                                      // 6264
                                                                                                                       // 6265
function inflateReset(strm) {                                                                                          // 6266
  var state;                                                                                                           // 6267
                                                                                                                       // 6268
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }                                                                 // 6269
  state = strm.state;                                                                                                  // 6270
  state.wsize = 0;                                                                                                     // 6271
  state.whave = 0;                                                                                                     // 6272
  state.wnext = 0;                                                                                                     // 6273
  return inflateResetKeep(strm);                                                                                       // 6274
                                                                                                                       // 6275
}                                                                                                                      // 6276
                                                                                                                       // 6277
function inflateReset2(strm, windowBits) {                                                                             // 6278
  var wrap;                                                                                                            // 6279
  var state;                                                                                                           // 6280
                                                                                                                       // 6281
  /* get the state */                                                                                                  // 6282
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }                                                                 // 6283
  state = strm.state;                                                                                                  // 6284
                                                                                                                       // 6285
  /* extract wrap request from windowBits parameter */                                                                 // 6286
  if (windowBits < 0) {                                                                                                // 6287
    wrap = 0;                                                                                                          // 6288
    windowBits = -windowBits;                                                                                          // 6289
  }                                                                                                                    // 6290
  else {                                                                                                               // 6291
    wrap = (windowBits >> 4) + 1;                                                                                      // 6292
    if (windowBits < 48) {                                                                                             // 6293
      windowBits &= 15;                                                                                                // 6294
    }                                                                                                                  // 6295
  }                                                                                                                    // 6296
                                                                                                                       // 6297
  /* set number of window bits, free window if different */                                                            // 6298
  if (windowBits && (windowBits < 8 || windowBits > 15)) {                                                             // 6299
    return Z_STREAM_ERROR;                                                                                             // 6300
  }                                                                                                                    // 6301
  if (state.window !== null && state.wbits !== windowBits) {                                                           // 6302
    state.window = null;                                                                                               // 6303
  }                                                                                                                    // 6304
                                                                                                                       // 6305
  /* update state and reset the rest of it */                                                                          // 6306
  state.wrap = wrap;                                                                                                   // 6307
  state.wbits = windowBits;                                                                                            // 6308
  return inflateReset(strm);                                                                                           // 6309
}                                                                                                                      // 6310
                                                                                                                       // 6311
function inflateInit2(strm, windowBits) {                                                                              // 6312
  var ret;                                                                                                             // 6313
  var state;                                                                                                           // 6314
                                                                                                                       // 6315
  if (!strm) { return Z_STREAM_ERROR; }                                                                                // 6316
  //strm.msg = Z_NULL;                 /* in case we return an error */                                                // 6317
                                                                                                                       // 6318
  state = new InflateState();                                                                                          // 6319
                                                                                                                       // 6320
  //if (state === Z_NULL) return Z_MEM_ERROR;                                                                          // 6321
  //Tracev((stderr, "inflate: allocated\n"));                                                                          // 6322
  strm.state = state;                                                                                                  // 6323
  state.window = null/*Z_NULL*/;                                                                                       // 6324
  ret = inflateReset2(strm, windowBits);                                                                               // 6325
  if (ret !== Z_OK) {                                                                                                  // 6326
    strm.state = null/*Z_NULL*/;                                                                                       // 6327
  }                                                                                                                    // 6328
  return ret;                                                                                                          // 6329
}                                                                                                                      // 6330
                                                                                                                       // 6331
function inflateInit(strm) {                                                                                           // 6332
  return inflateInit2(strm, DEF_WBITS);                                                                                // 6333
}                                                                                                                      // 6334
                                                                                                                       // 6335
                                                                                                                       // 6336
/*                                                                                                                     // 6337
 Return state with length and distance decoding tables and index sizes set to                                          // 6338
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.                                             // 6339
 If BUILDFIXED is defined, then instead this routine builds the tables the                                             // 6340
 first time it's called, and returns those tables the first time and                                                   // 6341
 thereafter.  This reduces the size of the code by about 2K bytes, in                                                  // 6342
 exchange for a little execution time.  However, BUILDFIXED should not be                                              // 6343
 used for threaded applications, since the rewriting of the tables and virgin                                          // 6344
 may not be thread-safe.                                                                                               // 6345
 */                                                                                                                    // 6346
var virgin = true;                                                                                                     // 6347
                                                                                                                       // 6348
var lenfix, distfix; // We have no pointers in JS, so keep tables separate                                             // 6349
                                                                                                                       // 6350
function fixedtables(state) {                                                                                          // 6351
  /* build fixed huffman tables if first call (may not be thread safe) */                                              // 6352
  if (virgin) {                                                                                                        // 6353
    var sym;                                                                                                           // 6354
                                                                                                                       // 6355
    lenfix = new utils.Buf32(512);                                                                                     // 6356
    distfix = new utils.Buf32(32);                                                                                     // 6357
                                                                                                                       // 6358
    /* literal/length table */                                                                                         // 6359
    sym = 0;                                                                                                           // 6360
    while (sym < 144) { state.lens[sym++] = 8; }                                                                       // 6361
    while (sym < 256) { state.lens[sym++] = 9; }                                                                       // 6362
    while (sym < 280) { state.lens[sym++] = 7; }                                                                       // 6363
    while (sym < 288) { state.lens[sym++] = 8; }                                                                       // 6364
                                                                                                                       // 6365
    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});                                      // 6366
                                                                                                                       // 6367
    /* distance table */                                                                                               // 6368
    sym = 0;                                                                                                           // 6369
    while (sym < 32) { state.lens[sym++] = 5; }                                                                        // 6370
                                                                                                                       // 6371
    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});                                      // 6372
                                                                                                                       // 6373
    /* do this just once */                                                                                            // 6374
    virgin = false;                                                                                                    // 6375
  }                                                                                                                    // 6376
                                                                                                                       // 6377
  state.lencode = lenfix;                                                                                              // 6378
  state.lenbits = 9;                                                                                                   // 6379
  state.distcode = distfix;                                                                                            // 6380
  state.distbits = 5;                                                                                                  // 6381
}                                                                                                                      // 6382
                                                                                                                       // 6383
                                                                                                                       // 6384
/*                                                                                                                     // 6385
 Update the window with the last wsize (normally 32K) bytes written before                                             // 6386
 returning.  If window does not exist yet, create it.  This is only called                                             // 6387
 when a window is already in use, or when output has been written during this                                          // 6388
 inflate call, but the end of the deflate stream has not been reached yet.                                             // 6389
 It is also called to create a window for dictionary data when a dictionary                                            // 6390
 is loaded.                                                                                                            // 6391
                                                                                                                       // 6392
 Providing output buffers larger than 32K to inflate() should provide a speed                                          // 6393
 advantage, since only the last 32K of output is copied to the sliding window                                          // 6394
 upon return from inflate(), and since all distances after the first 32K of                                            // 6395
 output will fall in the output data, making match copies simpler and faster.                                          // 6396
 The advantage may be dependent on the size of the processor's data caches.                                            // 6397
 */                                                                                                                    // 6398
function updatewindow(strm, src, end, copy) {                                                                          // 6399
  var dist;                                                                                                            // 6400
  var state = strm.state;                                                                                              // 6401
                                                                                                                       // 6402
  /* if it hasn't been done already, allocate space for the window */                                                  // 6403
  if (state.window === null) {                                                                                         // 6404
    state.wsize = 1 << state.wbits;                                                                                    // 6405
    state.wnext = 0;                                                                                                   // 6406
    state.whave = 0;                                                                                                   // 6407
                                                                                                                       // 6408
    state.window = new utils.Buf8(state.wsize);                                                                        // 6409
  }                                                                                                                    // 6410
                                                                                                                       // 6411
  /* copy state->wsize or less output bytes into the circular window */                                                // 6412
  if (copy >= state.wsize) {                                                                                           // 6413
    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);                                               // 6414
    state.wnext = 0;                                                                                                   // 6415
    state.whave = state.wsize;                                                                                         // 6416
  }                                                                                                                    // 6417
  else {                                                                                                               // 6418
    dist = state.wsize - state.wnext;                                                                                  // 6419
    if (dist > copy) {                                                                                                 // 6420
      dist = copy;                                                                                                     // 6421
    }                                                                                                                  // 6422
    //zmemcpy(state->window + state->wnext, end - copy, dist);                                                         // 6423
    utils.arraySet(state.window,src, end - copy, dist, state.wnext);                                                   // 6424
    copy -= dist;                                                                                                      // 6425
    if (copy) {                                                                                                        // 6426
      //zmemcpy(state->window, end - copy, copy);                                                                      // 6427
      utils.arraySet(state.window,src, end - copy, copy, 0);                                                           // 6428
      state.wnext = copy;                                                                                              // 6429
      state.whave = state.wsize;                                                                                       // 6430
    }                                                                                                                  // 6431
    else {                                                                                                             // 6432
      state.wnext += dist;                                                                                             // 6433
      if (state.wnext === state.wsize) { state.wnext = 0; }                                                            // 6434
      if (state.whave < state.wsize) { state.whave += dist; }                                                          // 6435
    }                                                                                                                  // 6436
  }                                                                                                                    // 6437
  return 0;                                                                                                            // 6438
}                                                                                                                      // 6439
                                                                                                                       // 6440
function inflate(strm, flush) {                                                                                        // 6441
  var state;                                                                                                           // 6442
  var input, output;          // input/output buffers                                                                  // 6443
  var next;                   /* next input INDEX */                                                                   // 6444
  var put;                    /* next output INDEX */                                                                  // 6445
  var have, left;             /* available input and output */                                                         // 6446
  var hold;                   /* bit buffer */                                                                         // 6447
  var bits;                   /* bits in bit buffer */                                                                 // 6448
  var _in, _out;              /* save starting available input and output */                                           // 6449
  var copy;                   /* number of stored or match bytes to copy */                                            // 6450
  var from;                   /* where to copy match bytes from */                                                     // 6451
  var from_source;                                                                                                     // 6452
  var here = 0;               /* current decoding table entry */                                                       // 6453
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)                                         // 6454
  //var last;                   /* parent table entry */                                                               // 6455
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)                                         // 6456
  var len;                    /* length to copy for repeats, bits to drop */                                           // 6457
  var ret;                    /* return code */                                                                        // 6458
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */                                        // 6459
  var opts;                                                                                                            // 6460
                                                                                                                       // 6461
  var n; // temporary var for NEED_BITS                                                                                // 6462
                                                                                                                       // 6463
  var order = /* permutation of code lengths */                                                                        // 6464
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];                                                // 6465
                                                                                                                       // 6466
                                                                                                                       // 6467
  if (!strm || !strm.state || !strm.output ||                                                                          // 6468
      (!strm.input && strm.avail_in !== 0)) {                                                                          // 6469
    return Z_STREAM_ERROR;                                                                                             // 6470
  }                                                                                                                    // 6471
                                                                                                                       // 6472
  state = strm.state;                                                                                                  // 6473
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */                                                // 6474
                                                                                                                       // 6475
                                                                                                                       // 6476
  //--- LOAD() ---                                                                                                     // 6477
  put = strm.next_out;                                                                                                 // 6478
  output = strm.output;                                                                                                // 6479
  left = strm.avail_out;                                                                                               // 6480
  next = strm.next_in;                                                                                                 // 6481
  input = strm.input;                                                                                                  // 6482
  have = strm.avail_in;                                                                                                // 6483
  hold = state.hold;                                                                                                   // 6484
  bits = state.bits;                                                                                                   // 6485
  //---                                                                                                                // 6486
                                                                                                                       // 6487
  _in = have;                                                                                                          // 6488
  _out = left;                                                                                                         // 6489
  ret = Z_OK;                                                                                                          // 6490
                                                                                                                       // 6491
  inf_leave: // goto emulation                                                                                         // 6492
  for (;;) {                                                                                                           // 6493
    switch (state.mode) {                                                                                              // 6494
    case HEAD:                                                                                                         // 6495
      if (state.wrap === 0) {                                                                                          // 6496
        state.mode = TYPEDO;                                                                                           // 6497
        break;                                                                                                         // 6498
      }                                                                                                                // 6499
      //=== NEEDBITS(16);                                                                                              // 6500
      while (bits < 16) {                                                                                              // 6501
        if (have === 0) { break inf_leave; }                                                                           // 6502
        have--;                                                                                                        // 6503
        hold += input[next++] << bits;                                                                                 // 6504
        bits += 8;                                                                                                     // 6505
      }                                                                                                                // 6506
      //===//                                                                                                          // 6507
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */                                                    // 6508
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;                                                                       // 6509
        //=== CRC2(state.check, hold);                                                                                 // 6510
        hbuf[0] = hold & 0xff;                                                                                         // 6511
        hbuf[1] = (hold >>> 8) & 0xff;                                                                                 // 6512
        state.check = crc32(state.check, hbuf, 2, 0);                                                                  // 6513
        //===//                                                                                                        // 6514
                                                                                                                       // 6515
        //=== INITBITS();                                                                                              // 6516
        hold = 0;                                                                                                      // 6517
        bits = 0;                                                                                                      // 6518
        //===//                                                                                                        // 6519
        state.mode = FLAGS;                                                                                            // 6520
        break;                                                                                                         // 6521
      }                                                                                                                // 6522
      state.flags = 0;           /* expect zlib header */                                                              // 6523
      if (state.head) {                                                                                                // 6524
        state.head.done = false;                                                                                       // 6525
      }                                                                                                                // 6526
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */                                                    // 6527
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {                                                        // 6528
        strm.msg = 'incorrect header check';                                                                           // 6529
        state.mode = BAD;                                                                                              // 6530
        break;                                                                                                         // 6531
      }                                                                                                                // 6532
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {                                                                   // 6533
        strm.msg = 'unknown compression method';                                                                       // 6534
        state.mode = BAD;                                                                                              // 6535
        break;                                                                                                         // 6536
      }                                                                                                                // 6537
      //--- DROPBITS(4) ---//                                                                                          // 6538
      hold >>>= 4;                                                                                                     // 6539
      bits -= 4;                                                                                                       // 6540
      //---//                                                                                                          // 6541
      len = (hold & 0x0f)/*BITS(4)*/ + 8;                                                                              // 6542
      if (state.wbits === 0) {                                                                                         // 6543
        state.wbits = len;                                                                                             // 6544
      }                                                                                                                // 6545
      else if (len > state.wbits) {                                                                                    // 6546
        strm.msg = 'invalid window size';                                                                              // 6547
        state.mode = BAD;                                                                                              // 6548
        break;                                                                                                         // 6549
      }                                                                                                                // 6550
      state.dmax = 1 << len;                                                                                           // 6551
      //Tracev((stderr, "inflate:   zlib header ok\n"));                                                               // 6552
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;                                                          // 6553
      state.mode = hold & 0x200 ? DICTID : TYPE;                                                                       // 6554
      //=== INITBITS();                                                                                                // 6555
      hold = 0;                                                                                                        // 6556
      bits = 0;                                                                                                        // 6557
      //===//                                                                                                          // 6558
      break;                                                                                                           // 6559
    case FLAGS:                                                                                                        // 6560
      //=== NEEDBITS(16); */                                                                                           // 6561
      while (bits < 16) {                                                                                              // 6562
        if (have === 0) { break inf_leave; }                                                                           // 6563
        have--;                                                                                                        // 6564
        hold += input[next++] << bits;                                                                                 // 6565
        bits += 8;                                                                                                     // 6566
      }                                                                                                                // 6567
      //===//                                                                                                          // 6568
      state.flags = hold;                                                                                              // 6569
      if ((state.flags & 0xff) !== Z_DEFLATED) {                                                                       // 6570
        strm.msg = 'unknown compression method';                                                                       // 6571
        state.mode = BAD;                                                                                              // 6572
        break;                                                                                                         // 6573
      }                                                                                                                // 6574
      if (state.flags & 0xe000) {                                                                                      // 6575
        strm.msg = 'unknown header flags set';                                                                         // 6576
        state.mode = BAD;                                                                                              // 6577
        break;                                                                                                         // 6578
      }                                                                                                                // 6579
      if (state.head) {                                                                                                // 6580
        state.head.text = ((hold >> 8) & 1);                                                                           // 6581
      }                                                                                                                // 6582
      if (state.flags & 0x0200) {                                                                                      // 6583
        //=== CRC2(state.check, hold);                                                                                 // 6584
        hbuf[0] = hold & 0xff;                                                                                         // 6585
        hbuf[1] = (hold >>> 8) & 0xff;                                                                                 // 6586
        state.check = crc32(state.check, hbuf, 2, 0);                                                                  // 6587
        //===//                                                                                                        // 6588
      }                                                                                                                // 6589
      //=== INITBITS();                                                                                                // 6590
      hold = 0;                                                                                                        // 6591
      bits = 0;                                                                                                        // 6592
      //===//                                                                                                          // 6593
      state.mode = TIME;                                                                                               // 6594
      /* falls through */                                                                                              // 6595
    case TIME:                                                                                                         // 6596
      //=== NEEDBITS(32); */                                                                                           // 6597
      while (bits < 32) {                                                                                              // 6598
        if (have === 0) { break inf_leave; }                                                                           // 6599
        have--;                                                                                                        // 6600
        hold += input[next++] << bits;                                                                                 // 6601
        bits += 8;                                                                                                     // 6602
      }                                                                                                                // 6603
      //===//                                                                                                          // 6604
      if (state.head) {                                                                                                // 6605
        state.head.time = hold;                                                                                        // 6606
      }                                                                                                                // 6607
      if (state.flags & 0x0200) {                                                                                      // 6608
        //=== CRC4(state.check, hold)                                                                                  // 6609
        hbuf[0] = hold & 0xff;                                                                                         // 6610
        hbuf[1] = (hold >>> 8) & 0xff;                                                                                 // 6611
        hbuf[2] = (hold >>> 16) & 0xff;                                                                                // 6612
        hbuf[3] = (hold >>> 24) & 0xff;                                                                                // 6613
        state.check = crc32(state.check, hbuf, 4, 0);                                                                  // 6614
        //===                                                                                                          // 6615
      }                                                                                                                // 6616
      //=== INITBITS();                                                                                                // 6617
      hold = 0;                                                                                                        // 6618
      bits = 0;                                                                                                        // 6619
      //===//                                                                                                          // 6620
      state.mode = OS;                                                                                                 // 6621
      /* falls through */                                                                                              // 6622
    case OS:                                                                                                           // 6623
      //=== NEEDBITS(16); */                                                                                           // 6624
      while (bits < 16) {                                                                                              // 6625
        if (have === 0) { break inf_leave; }                                                                           // 6626
        have--;                                                                                                        // 6627
        hold += input[next++] << bits;                                                                                 // 6628
        bits += 8;                                                                                                     // 6629
      }                                                                                                                // 6630
      //===//                                                                                                          // 6631
      if (state.head) {                                                                                                // 6632
        state.head.xflags = (hold & 0xff);                                                                             // 6633
        state.head.os = (hold >> 8);                                                                                   // 6634
      }                                                                                                                // 6635
      if (state.flags & 0x0200) {                                                                                      // 6636
        //=== CRC2(state.check, hold);                                                                                 // 6637
        hbuf[0] = hold & 0xff;                                                                                         // 6638
        hbuf[1] = (hold >>> 8) & 0xff;                                                                                 // 6639
        state.check = crc32(state.check, hbuf, 2, 0);                                                                  // 6640
        //===//                                                                                                        // 6641
      }                                                                                                                // 6642
      //=== INITBITS();                                                                                                // 6643
      hold = 0;                                                                                                        // 6644
      bits = 0;                                                                                                        // 6645
      //===//                                                                                                          // 6646
      state.mode = EXLEN;                                                                                              // 6647
      /* falls through */                                                                                              // 6648
    case EXLEN:                                                                                                        // 6649
      if (state.flags & 0x0400) {                                                                                      // 6650
        //=== NEEDBITS(16); */                                                                                         // 6651
        while (bits < 16) {                                                                                            // 6652
          if (have === 0) { break inf_leave; }                                                                         // 6653
          have--;                                                                                                      // 6654
          hold += input[next++] << bits;                                                                               // 6655
          bits += 8;                                                                                                   // 6656
        }                                                                                                              // 6657
        //===//                                                                                                        // 6658
        state.length = hold;                                                                                           // 6659
        if (state.head) {                                                                                              // 6660
          state.head.extra_len = hold;                                                                                 // 6661
        }                                                                                                              // 6662
        if (state.flags & 0x0200) {                                                                                    // 6663
          //=== CRC2(state.check, hold);                                                                               // 6664
          hbuf[0] = hold & 0xff;                                                                                       // 6665
          hbuf[1] = (hold >>> 8) & 0xff;                                                                               // 6666
          state.check = crc32(state.check, hbuf, 2, 0);                                                                // 6667
          //===//                                                                                                      // 6668
        }                                                                                                              // 6669
        //=== INITBITS();                                                                                              // 6670
        hold = 0;                                                                                                      // 6671
        bits = 0;                                                                                                      // 6672
        //===//                                                                                                        // 6673
      }                                                                                                                // 6674
      else if (state.head) {                                                                                           // 6675
        state.head.extra = null/*Z_NULL*/;                                                                             // 6676
      }                                                                                                                // 6677
      state.mode = EXTRA;                                                                                              // 6678
      /* falls through */                                                                                              // 6679
    case EXTRA:                                                                                                        // 6680
      if (state.flags & 0x0400) {                                                                                      // 6681
        copy = state.length;                                                                                           // 6682
        if (copy > have) { copy = have; }                                                                              // 6683
        if (copy) {                                                                                                    // 6684
          if (state.head) {                                                                                            // 6685
            len = state.head.extra_len - state.length;                                                                 // 6686
            if (!state.head.extra) {                                                                                   // 6687
              // Use untyped array for more conveniend processing later                                                // 6688
              state.head.extra = new Array(state.head.extra_len);                                                      // 6689
            }                                                                                                          // 6690
            utils.arraySet(                                                                                            // 6691
              state.head.extra,                                                                                        // 6692
              input,                                                                                                   // 6693
              next,                                                                                                    // 6694
              // extra field is limited to 65536 bytes                                                                 // 6695
              // - no need for additional size check                                                                   // 6696
              copy,                                                                                                    // 6697
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/                               // 6698
              len                                                                                                      // 6699
            );                                                                                                         // 6700
            //zmemcpy(state.head.extra + len, next,                                                                    // 6701
            //        len + copy > state.head.extra_max ?                                                              // 6702
            //        state.head.extra_max - len : copy);                                                              // 6703
          }                                                                                                            // 6704
          if (state.flags & 0x0200) {                                                                                  // 6705
            state.check = crc32(state.check, input, copy, next);                                                       // 6706
          }                                                                                                            // 6707
          have -= copy;                                                                                                // 6708
          next += copy;                                                                                                // 6709
          state.length -= copy;                                                                                        // 6710
        }                                                                                                              // 6711
        if (state.length) { break inf_leave; }                                                                         // 6712
      }                                                                                                                // 6713
      state.length = 0;                                                                                                // 6714
      state.mode = NAME;                                                                                               // 6715
      /* falls through */                                                                                              // 6716
    case NAME:                                                                                                         // 6717
      if (state.flags & 0x0800) {                                                                                      // 6718
        if (have === 0) { break inf_leave; }                                                                           // 6719
        copy = 0;                                                                                                      // 6720
        do {                                                                                                           // 6721
          // TODO: 2 or 1 bytes?                                                                                       // 6722
          len = input[next + copy++];                                                                                  // 6723
          /* use constant limit because in js we should not preallocate memory */                                      // 6724
          if (state.head && len &&                                                                                     // 6725
              (state.length < 65536 /*state.head.name_max*/)) {                                                        // 6726
            state.head.name += String.fromCharCode(len);                                                               // 6727
          }                                                                                                            // 6728
        } while (len && copy < have);                                                                                  // 6729
                                                                                                                       // 6730
        if (state.flags & 0x0200) {                                                                                    // 6731
          state.check = crc32(state.check, input, copy, next);                                                         // 6732
        }                                                                                                              // 6733
        have -= copy;                                                                                                  // 6734
        next += copy;                                                                                                  // 6735
        if (len) { break inf_leave; }                                                                                  // 6736
      }                                                                                                                // 6737
      else if (state.head) {                                                                                           // 6738
        state.head.name = null;                                                                                        // 6739
      }                                                                                                                // 6740
      state.length = 0;                                                                                                // 6741
      state.mode = COMMENT;                                                                                            // 6742
      /* falls through */                                                                                              // 6743
    case COMMENT:                                                                                                      // 6744
      if (state.flags & 0x1000) {                                                                                      // 6745
        if (have === 0) { break inf_leave; }                                                                           // 6746
        copy = 0;                                                                                                      // 6747
        do {                                                                                                           // 6748
          len = input[next + copy++];                                                                                  // 6749
          /* use constant limit because in js we should not preallocate memory */                                      // 6750
          if (state.head && len &&                                                                                     // 6751
              (state.length < 65536 /*state.head.comm_max*/)) {                                                        // 6752
            state.head.comment += String.fromCharCode(len);                                                            // 6753
          }                                                                                                            // 6754
        } while (len && copy < have);                                                                                  // 6755
        if (state.flags & 0x0200) {                                                                                    // 6756
          state.check = crc32(state.check, input, copy, next);                                                         // 6757
        }                                                                                                              // 6758
        have -= copy;                                                                                                  // 6759
        next += copy;                                                                                                  // 6760
        if (len) { break inf_leave; }                                                                                  // 6761
      }                                                                                                                // 6762
      else if (state.head) {                                                                                           // 6763
        state.head.comment = null;                                                                                     // 6764
      }                                                                                                                // 6765
      state.mode = HCRC;                                                                                               // 6766
      /* falls through */                                                                                              // 6767
    case HCRC:                                                                                                         // 6768
      if (state.flags & 0x0200) {                                                                                      // 6769
        //=== NEEDBITS(16); */                                                                                         // 6770
        while (bits < 16) {                                                                                            // 6771
          if (have === 0) { break inf_leave; }                                                                         // 6772
          have--;                                                                                                      // 6773
          hold += input[next++] << bits;                                                                               // 6774
          bits += 8;                                                                                                   // 6775
        }                                                                                                              // 6776
        //===//                                                                                                        // 6777
        if (hold !== (state.check & 0xffff)) {                                                                         // 6778
          strm.msg = 'header crc mismatch';                                                                            // 6779
          state.mode = BAD;                                                                                            // 6780
          break;                                                                                                       // 6781
        }                                                                                                              // 6782
        //=== INITBITS();                                                                                              // 6783
        hold = 0;                                                                                                      // 6784
        bits = 0;                                                                                                      // 6785
        //===//                                                                                                        // 6786
      }                                                                                                                // 6787
      if (state.head) {                                                                                                // 6788
        state.head.hcrc = ((state.flags >> 9) & 1);                                                                    // 6789
        state.head.done = true;                                                                                        // 6790
      }                                                                                                                // 6791
      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;                                                           // 6792
      state.mode = TYPE;                                                                                               // 6793
      break;                                                                                                           // 6794
    case DICTID:                                                                                                       // 6795
      //=== NEEDBITS(32); */                                                                                           // 6796
      while (bits < 32) {                                                                                              // 6797
        if (have === 0) { break inf_leave; }                                                                           // 6798
        have--;                                                                                                        // 6799
        hold += input[next++] << bits;                                                                                 // 6800
        bits += 8;                                                                                                     // 6801
      }                                                                                                                // 6802
      //===//                                                                                                          // 6803
      strm.adler = state.check = ZSWAP32(hold);                                                                        // 6804
      //=== INITBITS();                                                                                                // 6805
      hold = 0;                                                                                                        // 6806
      bits = 0;                                                                                                        // 6807
      //===//                                                                                                          // 6808
      state.mode = DICT;                                                                                               // 6809
      /* falls through */                                                                                              // 6810
    case DICT:                                                                                                         // 6811
      if (state.havedict === 0) {                                                                                      // 6812
        //--- RESTORE() ---                                                                                            // 6813
        strm.next_out = put;                                                                                           // 6814
        strm.avail_out = left;                                                                                         // 6815
        strm.next_in = next;                                                                                           // 6816
        strm.avail_in = have;                                                                                          // 6817
        state.hold = hold;                                                                                             // 6818
        state.bits = bits;                                                                                             // 6819
        //---                                                                                                          // 6820
        return Z_NEED_DICT;                                                                                            // 6821
      }                                                                                                                // 6822
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;                                                          // 6823
      state.mode = TYPE;                                                                                               // 6824
      /* falls through */                                                                                              // 6825
    case TYPE:                                                                                                         // 6826
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }                                                 // 6827
      /* falls through */                                                                                              // 6828
    case TYPEDO:                                                                                                       // 6829
      if (state.last) {                                                                                                // 6830
        //--- BYTEBITS() ---//                                                                                         // 6831
        hold >>>= bits & 7;                                                                                            // 6832
        bits -= bits & 7;                                                                                              // 6833
        //---//                                                                                                        // 6834
        state.mode = CHECK;                                                                                            // 6835
        break;                                                                                                         // 6836
      }                                                                                                                // 6837
      //=== NEEDBITS(3); */                                                                                            // 6838
      while (bits < 3) {                                                                                               // 6839
        if (have === 0) { break inf_leave; }                                                                           // 6840
        have--;                                                                                                        // 6841
        hold += input[next++] << bits;                                                                                 // 6842
        bits += 8;                                                                                                     // 6843
      }                                                                                                                // 6844
      //===//                                                                                                          // 6845
      state.last = (hold & 0x01)/*BITS(1)*/;                                                                           // 6846
      //--- DROPBITS(1) ---//                                                                                          // 6847
      hold >>>= 1;                                                                                                     // 6848
      bits -= 1;                                                                                                       // 6849
      //---//                                                                                                          // 6850
                                                                                                                       // 6851
      switch ((hold & 0x03)/*BITS(2)*/) {                                                                              // 6852
      case 0:                             /* stored block */                                                           // 6853
        //Tracev((stderr, "inflate:     stored block%s\n",                                                             // 6854
        //        state.last ? " (last)" : ""));                                                                       // 6855
        state.mode = STORED;                                                                                           // 6856
        break;                                                                                                         // 6857
      case 1:                             /* fixed block */                                                            // 6858
        fixedtables(state);                                                                                            // 6859
        //Tracev((stderr, "inflate:     fixed codes block%s\n",                                                        // 6860
        //        state.last ? " (last)" : ""));                                                                       // 6861
        state.mode = LEN_;             /* decode codes */                                                              // 6862
        if (flush === Z_TREES) {                                                                                       // 6863
          //--- DROPBITS(2) ---//                                                                                      // 6864
          hold >>>= 2;                                                                                                 // 6865
          bits -= 2;                                                                                                   // 6866
          //---//                                                                                                      // 6867
          break inf_leave;                                                                                             // 6868
        }                                                                                                              // 6869
        break;                                                                                                         // 6870
      case 2:                             /* dynamic block */                                                          // 6871
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",                                                      // 6872
        //        state.last ? " (last)" : ""));                                                                       // 6873
        state.mode = TABLE;                                                                                            // 6874
        break;                                                                                                         // 6875
      case 3:                                                                                                          // 6876
        strm.msg = 'invalid block type';                                                                               // 6877
        state.mode = BAD;                                                                                              // 6878
      }                                                                                                                // 6879
      //--- DROPBITS(2) ---//                                                                                          // 6880
      hold >>>= 2;                                                                                                     // 6881
      bits -= 2;                                                                                                       // 6882
      //---//                                                                                                          // 6883
      break;                                                                                                           // 6884
    case STORED:                                                                                                       // 6885
      //--- BYTEBITS() ---// /* go to byte boundary */                                                                 // 6886
      hold >>>= bits & 7;                                                                                              // 6887
      bits -= bits & 7;                                                                                                // 6888
      //---//                                                                                                          // 6889
      //=== NEEDBITS(32); */                                                                                           // 6890
      while (bits < 32) {                                                                                              // 6891
        if (have === 0) { break inf_leave; }                                                                           // 6892
        have--;                                                                                                        // 6893
        hold += input[next++] << bits;                                                                                 // 6894
        bits += 8;                                                                                                     // 6895
      }                                                                                                                // 6896
      //===//                                                                                                          // 6897
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {                                                              // 6898
        strm.msg = 'invalid stored block lengths';                                                                     // 6899
        state.mode = BAD;                                                                                              // 6900
        break;                                                                                                         // 6901
      }                                                                                                                // 6902
      state.length = hold & 0xffff;                                                                                    // 6903
      //Tracev((stderr, "inflate:       stored length %u\n",                                                           // 6904
      //        state.length));                                                                                        // 6905
      //=== INITBITS();                                                                                                // 6906
      hold = 0;                                                                                                        // 6907
      bits = 0;                                                                                                        // 6908
      //===//                                                                                                          // 6909
      state.mode = COPY_;                                                                                              // 6910
      if (flush === Z_TREES) { break inf_leave; }                                                                      // 6911
      /* falls through */                                                                                              // 6912
    case COPY_:                                                                                                        // 6913
      state.mode = COPY;                                                                                               // 6914
      /* falls through */                                                                                              // 6915
    case COPY:                                                                                                         // 6916
      copy = state.length;                                                                                             // 6917
      if (copy) {                                                                                                      // 6918
        if (copy > have) { copy = have; }                                                                              // 6919
        if (copy > left) { copy = left; }                                                                              // 6920
        if (copy === 0) { break inf_leave; }                                                                           // 6921
        //--- zmemcpy(put, next, copy); ---                                                                            // 6922
        utils.arraySet(output, input, next, copy, put);                                                                // 6923
        //---//                                                                                                        // 6924
        have -= copy;                                                                                                  // 6925
        next += copy;                                                                                                  // 6926
        left -= copy;                                                                                                  // 6927
        put += copy;                                                                                                   // 6928
        state.length -= copy;                                                                                          // 6929
        break;                                                                                                         // 6930
      }                                                                                                                // 6931
      //Tracev((stderr, "inflate:       stored end\n"));                                                               // 6932
      state.mode = TYPE;                                                                                               // 6933
      break;                                                                                                           // 6934
    case TABLE:                                                                                                        // 6935
      //=== NEEDBITS(14); */                                                                                           // 6936
      while (bits < 14) {                                                                                              // 6937
        if (have === 0) { break inf_leave; }                                                                           // 6938
        have--;                                                                                                        // 6939
        hold += input[next++] << bits;                                                                                 // 6940
        bits += 8;                                                                                                     // 6941
      }                                                                                                                // 6942
      //===//                                                                                                          // 6943
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;                                                                     // 6944
      //--- DROPBITS(5) ---//                                                                                          // 6945
      hold >>>= 5;                                                                                                     // 6946
      bits -= 5;                                                                                                       // 6947
      //---//                                                                                                          // 6948
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;                                                                      // 6949
      //--- DROPBITS(5) ---//                                                                                          // 6950
      hold >>>= 5;                                                                                                     // 6951
      bits -= 5;                                                                                                       // 6952
      //---//                                                                                                          // 6953
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;                                                                      // 6954
      //--- DROPBITS(4) ---//                                                                                          // 6955
      hold >>>= 4;                                                                                                     // 6956
      bits -= 4;                                                                                                       // 6957
      //---//                                                                                                          // 6958
//#ifndef PKZIP_BUG_WORKAROUND                                                                                         // 6959
      if (state.nlen > 286 || state.ndist > 30) {                                                                      // 6960
        strm.msg = 'too many length or distance symbols';                                                              // 6961
        state.mode = BAD;                                                                                              // 6962
        break;                                                                                                         // 6963
      }                                                                                                                // 6964
//#endif                                                                                                               // 6965
      //Tracev((stderr, "inflate:       table sizes ok\n"));                                                           // 6966
      state.have = 0;                                                                                                  // 6967
      state.mode = LENLENS;                                                                                            // 6968
      /* falls through */                                                                                              // 6969
    case LENLENS:                                                                                                      // 6970
      while (state.have < state.ncode) {                                                                               // 6971
        //=== NEEDBITS(3);                                                                                             // 6972
        while (bits < 3) {                                                                                             // 6973
          if (have === 0) { break inf_leave; }                                                                         // 6974
          have--;                                                                                                      // 6975
          hold += input[next++] << bits;                                                                               // 6976
          bits += 8;                                                                                                   // 6977
        }                                                                                                              // 6978
        //===//                                                                                                        // 6979
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);                                                     // 6980
        //--- DROPBITS(3) ---//                                                                                        // 6981
        hold >>>= 3;                                                                                                   // 6982
        bits -= 3;                                                                                                     // 6983
        //---//                                                                                                        // 6984
      }                                                                                                                // 6985
      while (state.have < 19) {                                                                                        // 6986
        state.lens[order[state.have++]] = 0;                                                                           // 6987
      }                                                                                                                // 6988
      // We have separate tables & no pointers. 2 commented lines below not needed.                                    // 6989
      //state.next = state.codes;                                                                                      // 6990
      //state.lencode = state.next;                                                                                    // 6991
      // Switch to use dynamic table                                                                                   // 6992
      state.lencode = state.lendyn;                                                                                    // 6993
      state.lenbits = 7;                                                                                               // 6994
                                                                                                                       // 6995
      opts = {bits: state.lenbits};                                                                                    // 6996
      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);                               // 6997
      state.lenbits = opts.bits;                                                                                       // 6998
                                                                                                                       // 6999
      if (ret) {                                                                                                       // 7000
        strm.msg = 'invalid code lengths set';                                                                         // 7001
        state.mode = BAD;                                                                                              // 7002
        break;                                                                                                         // 7003
      }                                                                                                                // 7004
      //Tracev((stderr, "inflate:       code lengths ok\n"));                                                          // 7005
      state.have = 0;                                                                                                  // 7006
      state.mode = CODELENS;                                                                                           // 7007
      /* falls through */                                                                                              // 7008
    case CODELENS:                                                                                                     // 7009
      while (state.have < state.nlen + state.ndist) {                                                                  // 7010
        for (;;) {                                                                                                     // 7011
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/                              // 7012
          here_bits = here >>> 24;                                                                                     // 7013
          here_op = (here >>> 16) & 0xff;                                                                              // 7014
          here_val = here & 0xffff;                                                                                    // 7015
                                                                                                                       // 7016
          if ((here_bits) <= bits) { break; }                                                                          // 7017
          //--- PULLBYTE() ---//                                                                                       // 7018
          if (have === 0) { break inf_leave; }                                                                         // 7019
          have--;                                                                                                      // 7020
          hold += input[next++] << bits;                                                                               // 7021
          bits += 8;                                                                                                   // 7022
          //---//                                                                                                      // 7023
        }                                                                                                              // 7024
        if (here_val < 16) {                                                                                           // 7025
          //--- DROPBITS(here.bits) ---//                                                                              // 7026
          hold >>>= here_bits;                                                                                         // 7027
          bits -= here_bits;                                                                                           // 7028
          //---//                                                                                                      // 7029
          state.lens[state.have++] = here_val;                                                                         // 7030
        }                                                                                                              // 7031
        else {                                                                                                         // 7032
          if (here_val === 16) {                                                                                       // 7033
            //=== NEEDBITS(here.bits + 2);                                                                             // 7034
            n = here_bits + 2;                                                                                         // 7035
            while (bits < n) {                                                                                         // 7036
              if (have === 0) { break inf_leave; }                                                                     // 7037
              have--;                                                                                                  // 7038
              hold += input[next++] << bits;                                                                           // 7039
              bits += 8;                                                                                               // 7040
            }                                                                                                          // 7041
            //===//                                                                                                    // 7042
            //--- DROPBITS(here.bits) ---//                                                                            // 7043
            hold >>>= here_bits;                                                                                       // 7044
            bits -= here_bits;                                                                                         // 7045
            //---//                                                                                                    // 7046
            if (state.have === 0) {                                                                                    // 7047
              strm.msg = 'invalid bit length repeat';                                                                  // 7048
              state.mode = BAD;                                                                                        // 7049
              break;                                                                                                   // 7050
            }                                                                                                          // 7051
            len = state.lens[state.have - 1];                                                                          // 7052
            copy = 3 + (hold & 0x03);//BITS(2);                                                                        // 7053
            //--- DROPBITS(2) ---//                                                                                    // 7054
            hold >>>= 2;                                                                                               // 7055
            bits -= 2;                                                                                                 // 7056
            //---//                                                                                                    // 7057
          }                                                                                                            // 7058
          else if (here_val === 17) {                                                                                  // 7059
            //=== NEEDBITS(here.bits + 3);                                                                             // 7060
            n = here_bits + 3;                                                                                         // 7061
            while (bits < n) {                                                                                         // 7062
              if (have === 0) { break inf_leave; }                                                                     // 7063
              have--;                                                                                                  // 7064
              hold += input[next++] << bits;                                                                           // 7065
              bits += 8;                                                                                               // 7066
            }                                                                                                          // 7067
            //===//                                                                                                    // 7068
            //--- DROPBITS(here.bits) ---//                                                                            // 7069
            hold >>>= here_bits;                                                                                       // 7070
            bits -= here_bits;                                                                                         // 7071
            //---//                                                                                                    // 7072
            len = 0;                                                                                                   // 7073
            copy = 3 + (hold & 0x07);//BITS(3);                                                                        // 7074
            //--- DROPBITS(3) ---//                                                                                    // 7075
            hold >>>= 3;                                                                                               // 7076
            bits -= 3;                                                                                                 // 7077
            //---//                                                                                                    // 7078
          }                                                                                                            // 7079
          else {                                                                                                       // 7080
            //=== NEEDBITS(here.bits + 7);                                                                             // 7081
            n = here_bits + 7;                                                                                         // 7082
            while (bits < n) {                                                                                         // 7083
              if (have === 0) { break inf_leave; }                                                                     // 7084
              have--;                                                                                                  // 7085
              hold += input[next++] << bits;                                                                           // 7086
              bits += 8;                                                                                               // 7087
            }                                                                                                          // 7088
            //===//                                                                                                    // 7089
            //--- DROPBITS(here.bits) ---//                                                                            // 7090
            hold >>>= here_bits;                                                                                       // 7091
            bits -= here_bits;                                                                                         // 7092
            //---//                                                                                                    // 7093
            len = 0;                                                                                                   // 7094
            copy = 11 + (hold & 0x7f);//BITS(7);                                                                       // 7095
            //--- DROPBITS(7) ---//                                                                                    // 7096
            hold >>>= 7;                                                                                               // 7097
            bits -= 7;                                                                                                 // 7098
            //---//                                                                                                    // 7099
          }                                                                                                            // 7100
          if (state.have + copy > state.nlen + state.ndist) {                                                          // 7101
            strm.msg = 'invalid bit length repeat';                                                                    // 7102
            state.mode = BAD;                                                                                          // 7103
            break;                                                                                                     // 7104
          }                                                                                                            // 7105
          while (copy--) {                                                                                             // 7106
            state.lens[state.have++] = len;                                                                            // 7107
          }                                                                                                            // 7108
        }                                                                                                              // 7109
      }                                                                                                                // 7110
                                                                                                                       // 7111
      /* handle error breaks in while */                                                                               // 7112
      if (state.mode === BAD) { break; }                                                                               // 7113
                                                                                                                       // 7114
      /* check for end-of-block code (better have one) */                                                              // 7115
      if (state.lens[256] === 0) {                                                                                     // 7116
        strm.msg = 'invalid code -- missing end-of-block';                                                             // 7117
        state.mode = BAD;                                                                                              // 7118
        break;                                                                                                         // 7119
      }                                                                                                                // 7120
                                                                                                                       // 7121
      /* build code tables -- note: do not change the lenbits or distbits                                              // 7122
         values here (9 and 6) without reading the comments in inftrees.h                                              // 7123
         concerning the ENOUGH constants, which depend on those values */                                              // 7124
      state.lenbits = 9;                                                                                               // 7125
                                                                                                                       // 7126
      opts = {bits: state.lenbits};                                                                                    // 7127
      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);                        // 7128
      // We have separate tables & no pointers. 2 commented lines below not needed.                                    // 7129
      // state.next_index = opts.table_index;                                                                          // 7130
      state.lenbits = opts.bits;                                                                                       // 7131
      // state.lencode = state.next;                                                                                   // 7132
                                                                                                                       // 7133
      if (ret) {                                                                                                       // 7134
        strm.msg = 'invalid literal/lengths set';                                                                      // 7135
        state.mode = BAD;                                                                                              // 7136
        break;                                                                                                         // 7137
      }                                                                                                                // 7138
                                                                                                                       // 7139
      state.distbits = 6;                                                                                              // 7140
      //state.distcode.copy(state.codes);                                                                              // 7141
      // Switch to use dynamic table                                                                                   // 7142
      state.distcode = state.distdyn;                                                                                  // 7143
      opts = {bits: state.distbits};                                                                                   // 7144
      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);            // 7145
      // We have separate tables & no pointers. 2 commented lines below not needed.                                    // 7146
      // state.next_index = opts.table_index;                                                                          // 7147
      state.distbits = opts.bits;                                                                                      // 7148
      // state.distcode = state.next;                                                                                  // 7149
                                                                                                                       // 7150
      if (ret) {                                                                                                       // 7151
        strm.msg = 'invalid distances set';                                                                            // 7152
        state.mode = BAD;                                                                                              // 7153
        break;                                                                                                         // 7154
      }                                                                                                                // 7155
      //Tracev((stderr, 'inflate:       codes ok\n'));                                                                 // 7156
      state.mode = LEN_;                                                                                               // 7157
      if (flush === Z_TREES) { break inf_leave; }                                                                      // 7158
      /* falls through */                                                                                              // 7159
    case LEN_:                                                                                                         // 7160
      state.mode = LEN;                                                                                                // 7161
      /* falls through */                                                                                              // 7162
    case LEN:                                                                                                          // 7163
      if (have >= 6 && left >= 258) {                                                                                  // 7164
        //--- RESTORE() ---                                                                                            // 7165
        strm.next_out = put;                                                                                           // 7166
        strm.avail_out = left;                                                                                         // 7167
        strm.next_in = next;                                                                                           // 7168
        strm.avail_in = have;                                                                                          // 7169
        state.hold = hold;                                                                                             // 7170
        state.bits = bits;                                                                                             // 7171
        //---                                                                                                          // 7172
        inflate_fast(strm, _out);                                                                                      // 7173
        //--- LOAD() ---                                                                                               // 7174
        put = strm.next_out;                                                                                           // 7175
        output = strm.output;                                                                                          // 7176
        left = strm.avail_out;                                                                                         // 7177
        next = strm.next_in;                                                                                           // 7178
        input = strm.input;                                                                                            // 7179
        have = strm.avail_in;                                                                                          // 7180
        hold = state.hold;                                                                                             // 7181
        bits = state.bits;                                                                                             // 7182
        //---                                                                                                          // 7183
                                                                                                                       // 7184
        if (state.mode === TYPE) {                                                                                     // 7185
          state.back = -1;                                                                                             // 7186
        }                                                                                                              // 7187
        break;                                                                                                         // 7188
      }                                                                                                                // 7189
      state.back = 0;                                                                                                  // 7190
      for (;;) {                                                                                                       // 7191
        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/                               // 7192
        here_bits = here >>> 24;                                                                                       // 7193
        here_op = (here >>> 16) & 0xff;                                                                                // 7194
        here_val = here & 0xffff;                                                                                      // 7195
                                                                                                                       // 7196
        if (here_bits <= bits) { break; }                                                                              // 7197
        //--- PULLBYTE() ---//                                                                                         // 7198
        if (have === 0) { break inf_leave; }                                                                           // 7199
        have--;                                                                                                        // 7200
        hold += input[next++] << bits;                                                                                 // 7201
        bits += 8;                                                                                                     // 7202
        //---//                                                                                                        // 7203
      }                                                                                                                // 7204
      if (here_op && (here_op & 0xf0) === 0) {                                                                         // 7205
        last_bits = here_bits;                                                                                         // 7206
        last_op = here_op;                                                                                             // 7207
        last_val = here_val;                                                                                           // 7208
        for (;;) {                                                                                                     // 7209
          here = state.lencode[last_val +                                                                              // 7210
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];             // 7211
          here_bits = here >>> 24;                                                                                     // 7212
          here_op = (here >>> 16) & 0xff;                                                                              // 7213
          here_val = here & 0xffff;                                                                                    // 7214
                                                                                                                       // 7215
          if ((last_bits + here_bits) <= bits) { break; }                                                              // 7216
          //--- PULLBYTE() ---//                                                                                       // 7217
          if (have === 0) { break inf_leave; }                                                                         // 7218
          have--;                                                                                                      // 7219
          hold += input[next++] << bits;                                                                               // 7220
          bits += 8;                                                                                                   // 7221
          //---//                                                                                                      // 7222
        }                                                                                                              // 7223
        //--- DROPBITS(last.bits) ---//                                                                                // 7224
        hold >>>= last_bits;                                                                                           // 7225
        bits -= last_bits;                                                                                             // 7226
        //---//                                                                                                        // 7227
        state.back += last_bits;                                                                                       // 7228
      }                                                                                                                // 7229
      //--- DROPBITS(here.bits) ---//                                                                                  // 7230
      hold >>>= here_bits;                                                                                             // 7231
      bits -= here_bits;                                                                                               // 7232
      //---//                                                                                                          // 7233
      state.back += here_bits;                                                                                         // 7234
      state.length = here_val;                                                                                         // 7235
      if (here_op === 0) {                                                                                             // 7236
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?                                                       // 7237
        //        "inflate:         literal '%c'\n" :                                                                  // 7238
        //        "inflate:         literal 0x%02x\n", here.val));                                                     // 7239
        state.mode = LIT;                                                                                              // 7240
        break;                                                                                                         // 7241
      }                                                                                                                // 7242
      if (here_op & 32) {                                                                                              // 7243
        //Tracevv((stderr, "inflate:         end of block\n"));                                                        // 7244
        state.back = -1;                                                                                               // 7245
        state.mode = TYPE;                                                                                             // 7246
        break;                                                                                                         // 7247
      }                                                                                                                // 7248
      if (here_op & 64) {                                                                                              // 7249
        strm.msg = 'invalid literal/length code';                                                                      // 7250
        state.mode = BAD;                                                                                              // 7251
        break;                                                                                                         // 7252
      }                                                                                                                // 7253
      state.extra = here_op & 15;                                                                                      // 7254
      state.mode = LENEXT;                                                                                             // 7255
      /* falls through */                                                                                              // 7256
    case LENEXT:                                                                                                       // 7257
      if (state.extra) {                                                                                               // 7258
        //=== NEEDBITS(state.extra);                                                                                   // 7259
        n = state.extra;                                                                                               // 7260
        while (bits < n) {                                                                                             // 7261
          if (have === 0) { break inf_leave; }                                                                         // 7262
          have--;                                                                                                      // 7263
          hold += input[next++] << bits;                                                                               // 7264
          bits += 8;                                                                                                   // 7265
        }                                                                                                              // 7266
        //===//                                                                                                        // 7267
        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;                                           // 7268
        //--- DROPBITS(state.extra) ---//                                                                              // 7269
        hold >>>= state.extra;                                                                                         // 7270
        bits -= state.extra;                                                                                           // 7271
        //---//                                                                                                        // 7272
        state.back += state.extra;                                                                                     // 7273
      }                                                                                                                // 7274
      //Tracevv((stderr, "inflate:         length %u\n", state.length));                                               // 7275
      state.was = state.length;                                                                                        // 7276
      state.mode = DIST;                                                                                               // 7277
      /* falls through */                                                                                              // 7278
    case DIST:                                                                                                         // 7279
      for (;;) {                                                                                                       // 7280
        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/                              // 7281
        here_bits = here >>> 24;                                                                                       // 7282
        here_op = (here >>> 16) & 0xff;                                                                                // 7283
        here_val = here & 0xffff;                                                                                      // 7284
                                                                                                                       // 7285
        if ((here_bits) <= bits) { break; }                                                                            // 7286
        //--- PULLBYTE() ---//                                                                                         // 7287
        if (have === 0) { break inf_leave; }                                                                           // 7288
        have--;                                                                                                        // 7289
        hold += input[next++] << bits;                                                                                 // 7290
        bits += 8;                                                                                                     // 7291
        //---//                                                                                                        // 7292
      }                                                                                                                // 7293
      if ((here_op & 0xf0) === 0) {                                                                                    // 7294
        last_bits = here_bits;                                                                                         // 7295
        last_op = here_op;                                                                                             // 7296
        last_val = here_val;                                                                                           // 7297
        for (;;) {                                                                                                     // 7298
          here = state.distcode[last_val +                                                                             // 7299
                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];             // 7300
          here_bits = here >>> 24;                                                                                     // 7301
          here_op = (here >>> 16) & 0xff;                                                                              // 7302
          here_val = here & 0xffff;                                                                                    // 7303
                                                                                                                       // 7304
          if ((last_bits + here_bits) <= bits) { break; }                                                              // 7305
          //--- PULLBYTE() ---//                                                                                       // 7306
          if (have === 0) { break inf_leave; }                                                                         // 7307
          have--;                                                                                                      // 7308
          hold += input[next++] << bits;                                                                               // 7309
          bits += 8;                                                                                                   // 7310
          //---//                                                                                                      // 7311
        }                                                                                                              // 7312
        //--- DROPBITS(last.bits) ---//                                                                                // 7313
        hold >>>= last_bits;                                                                                           // 7314
        bits -= last_bits;                                                                                             // 7315
        //---//                                                                                                        // 7316
        state.back += last_bits;                                                                                       // 7317
      }                                                                                                                // 7318
      //--- DROPBITS(here.bits) ---//                                                                                  // 7319
      hold >>>= here_bits;                                                                                             // 7320
      bits -= here_bits;                                                                                               // 7321
      //---//                                                                                                          // 7322
      state.back += here_bits;                                                                                         // 7323
      if (here_op & 64) {                                                                                              // 7324
        strm.msg = 'invalid distance code';                                                                            // 7325
        state.mode = BAD;                                                                                              // 7326
        break;                                                                                                         // 7327
      }                                                                                                                // 7328
      state.offset = here_val;                                                                                         // 7329
      state.extra = (here_op) & 15;                                                                                    // 7330
      state.mode = DISTEXT;                                                                                            // 7331
      /* falls through */                                                                                              // 7332
    case DISTEXT:                                                                                                      // 7333
      if (state.extra) {                                                                                               // 7334
        //=== NEEDBITS(state.extra);                                                                                   // 7335
        n = state.extra;                                                                                               // 7336
        while (bits < n) {                                                                                             // 7337
          if (have === 0) { break inf_leave; }                                                                         // 7338
          have--;                                                                                                      // 7339
          hold += input[next++] << bits;                                                                               // 7340
          bits += 8;                                                                                                   // 7341
        }                                                                                                              // 7342
        //===//                                                                                                        // 7343
        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;                                           // 7344
        //--- DROPBITS(state.extra) ---//                                                                              // 7345
        hold >>>= state.extra;                                                                                         // 7346
        bits -= state.extra;                                                                                           // 7347
        //---//                                                                                                        // 7348
        state.back += state.extra;                                                                                     // 7349
      }                                                                                                                // 7350
//#ifdef INFLATE_STRICT                                                                                                // 7351
      if (state.offset > state.dmax) {                                                                                 // 7352
        strm.msg = 'invalid distance too far back';                                                                    // 7353
        state.mode = BAD;                                                                                              // 7354
        break;                                                                                                         // 7355
      }                                                                                                                // 7356
//#endif                                                                                                               // 7357
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));                                             // 7358
      state.mode = MATCH;                                                                                              // 7359
      /* falls through */                                                                                              // 7360
    case MATCH:                                                                                                        // 7361
      if (left === 0) { break inf_leave; }                                                                             // 7362
      copy = _out - left;                                                                                              // 7363
      if (state.offset > copy) {         /* copy from window */                                                        // 7364
        copy = state.offset - copy;                                                                                    // 7365
        if (copy > state.whave) {                                                                                      // 7366
          if (state.sane) {                                                                                            // 7367
            strm.msg = 'invalid distance too far back';                                                                // 7368
            state.mode = BAD;                                                                                          // 7369
            break;                                                                                                     // 7370
          }                                                                                                            // 7371
// (!) This block is disabled in zlib defailts,                                                                        // 7372
// don't enable it for binary compatibility                                                                            // 7373
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR                                                                    // 7374
//          Trace((stderr, "inflate.c too far\n"));                                                                    // 7375
//          copy -= state.whave;                                                                                       // 7376
//          if (copy > state.length) { copy = state.length; }                                                          // 7377
//          if (copy > left) { copy = left; }                                                                          // 7378
//          left -= copy;                                                                                              // 7379
//          state.length -= copy;                                                                                      // 7380
//          do {                                                                                                       // 7381
//            output[put++] = 0;                                                                                       // 7382
//          } while (--copy);                                                                                          // 7383
//          if (state.length === 0) { state.mode = LEN; }                                                              // 7384
//          break;                                                                                                     // 7385
//#endif                                                                                                               // 7386
        }                                                                                                              // 7387
        if (copy > state.wnext) {                                                                                      // 7388
          copy -= state.wnext;                                                                                         // 7389
          from = state.wsize - copy;                                                                                   // 7390
        }                                                                                                              // 7391
        else {                                                                                                         // 7392
          from = state.wnext - copy;                                                                                   // 7393
        }                                                                                                              // 7394
        if (copy > state.length) { copy = state.length; }                                                              // 7395
        from_source = state.window;                                                                                    // 7396
      }                                                                                                                // 7397
      else {                              /* copy from output */                                                       // 7398
        from_source = output;                                                                                          // 7399
        from = put - state.offset;                                                                                     // 7400
        copy = state.length;                                                                                           // 7401
      }                                                                                                                // 7402
      if (copy > left) { copy = left; }                                                                                // 7403
      left -= copy;                                                                                                    // 7404
      state.length -= copy;                                                                                            // 7405
      do {                                                                                                             // 7406
        output[put++] = from_source[from++];                                                                           // 7407
      } while (--copy);                                                                                                // 7408
      if (state.length === 0) { state.mode = LEN; }                                                                    // 7409
      break;                                                                                                           // 7410
    case LIT:                                                                                                          // 7411
      if (left === 0) { break inf_leave; }                                                                             // 7412
      output[put++] = state.length;                                                                                    // 7413
      left--;                                                                                                          // 7414
      state.mode = LEN;                                                                                                // 7415
      break;                                                                                                           // 7416
    case CHECK:                                                                                                        // 7417
      if (state.wrap) {                                                                                                // 7418
        //=== NEEDBITS(32);                                                                                            // 7419
        while (bits < 32) {                                                                                            // 7420
          if (have === 0) { break inf_leave; }                                                                         // 7421
          have--;                                                                                                      // 7422
          // Use '|' insdead of '+' to make sure that result is signed                                                 // 7423
          hold |= input[next++] << bits;                                                                               // 7424
          bits += 8;                                                                                                   // 7425
        }                                                                                                              // 7426
        //===//                                                                                                        // 7427
        _out -= left;                                                                                                  // 7428
        strm.total_out += _out;                                                                                        // 7429
        state.total += _out;                                                                                           // 7430
        if (_out) {                                                                                                    // 7431
          strm.adler = state.check =                                                                                   // 7432
              /*UPDATE(state.check, put - _out, _out);*/                                                               // 7433
              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));
                                                                                                                       // 7435
        }                                                                                                              // 7436
        _out = left;                                                                                                   // 7437
        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too                                           // 7438
        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {                                                    // 7439
          strm.msg = 'incorrect data check';                                                                           // 7440
          state.mode = BAD;                                                                                            // 7441
          break;                                                                                                       // 7442
        }                                                                                                              // 7443
        //=== INITBITS();                                                                                              // 7444
        hold = 0;                                                                                                      // 7445
        bits = 0;                                                                                                      // 7446
        //===//                                                                                                        // 7447
        //Tracev((stderr, "inflate:   check matches trailer\n"));                                                      // 7448
      }                                                                                                                // 7449
      state.mode = LENGTH;                                                                                             // 7450
      /* falls through */                                                                                              // 7451
    case LENGTH:                                                                                                       // 7452
      if (state.wrap && state.flags) {                                                                                 // 7453
        //=== NEEDBITS(32);                                                                                            // 7454
        while (bits < 32) {                                                                                            // 7455
          if (have === 0) { break inf_leave; }                                                                         // 7456
          have--;                                                                                                      // 7457
          hold += input[next++] << bits;                                                                               // 7458
          bits += 8;                                                                                                   // 7459
        }                                                                                                              // 7460
        //===//                                                                                                        // 7461
        if (hold !== (state.total & 0xffffffff)) {                                                                     // 7462
          strm.msg = 'incorrect length check';                                                                         // 7463
          state.mode = BAD;                                                                                            // 7464
          break;                                                                                                       // 7465
        }                                                                                                              // 7466
        //=== INITBITS();                                                                                              // 7467
        hold = 0;                                                                                                      // 7468
        bits = 0;                                                                                                      // 7469
        //===//                                                                                                        // 7470
        //Tracev((stderr, "inflate:   length matches trailer\n"));                                                     // 7471
      }                                                                                                                // 7472
      state.mode = DONE;                                                                                               // 7473
      /* falls through */                                                                                              // 7474
    case DONE:                                                                                                         // 7475
      ret = Z_STREAM_END;                                                                                              // 7476
      break inf_leave;                                                                                                 // 7477
    case BAD:                                                                                                          // 7478
      ret = Z_DATA_ERROR;                                                                                              // 7479
      break inf_leave;                                                                                                 // 7480
    case MEM:                                                                                                          // 7481
      return Z_MEM_ERROR;                                                                                              // 7482
    case SYNC:                                                                                                         // 7483
      /* falls through */                                                                                              // 7484
    default:                                                                                                           // 7485
      return Z_STREAM_ERROR;                                                                                           // 7486
    }                                                                                                                  // 7487
  }                                                                                                                    // 7488
                                                                                                                       // 7489
  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"                              // 7490
                                                                                                                       // 7491
  /*                                                                                                                   // 7492
     Return from inflate(), updating the total counts and the check value.                                             // 7493
     If there was no progress during the inflate() call, return a buffer                                               // 7494
     error.  Call updatewindow() to create and/or update the window state.                                             // 7495
     Note: a memory error from inflate() is non-recoverable.                                                           // 7496
   */                                                                                                                  // 7497
                                                                                                                       // 7498
  //--- RESTORE() ---                                                                                                  // 7499
  strm.next_out = put;                                                                                                 // 7500
  strm.avail_out = left;                                                                                               // 7501
  strm.next_in = next;                                                                                                 // 7502
  strm.avail_in = have;                                                                                                // 7503
  state.hold = hold;                                                                                                   // 7504
  state.bits = bits;                                                                                                   // 7505
  //---                                                                                                                // 7506
                                                                                                                       // 7507
  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&                                                   // 7508
                      (state.mode < CHECK || flush !== Z_FINISH))) {                                                   // 7509
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {                                       // 7510
      state.mode = MEM;                                                                                                // 7511
      return Z_MEM_ERROR;                                                                                              // 7512
    }                                                                                                                  // 7513
  }                                                                                                                    // 7514
  _in -= strm.avail_in;                                                                                                // 7515
  _out -= strm.avail_out;                                                                                              // 7516
  strm.total_in += _in;                                                                                                // 7517
  strm.total_out += _out;                                                                                              // 7518
  state.total += _out;                                                                                                 // 7519
  if (state.wrap && _out) {                                                                                            // 7520
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/                                    // 7521
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }                                                                                                                    // 7523
  strm.data_type = state.bits + (state.last ? 64 : 0) +                                                                // 7524
                    (state.mode === TYPE ? 128 : 0) +                                                                  // 7525
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);                                           // 7526
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {                                             // 7527
    ret = Z_BUF_ERROR;                                                                                                 // 7528
  }                                                                                                                    // 7529
  return ret;                                                                                                          // 7530
}                                                                                                                      // 7531
                                                                                                                       // 7532
function inflateEnd(strm) {                                                                                            // 7533
                                                                                                                       // 7534
  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {                                                       // 7535
    return Z_STREAM_ERROR;                                                                                             // 7536
  }                                                                                                                    // 7537
                                                                                                                       // 7538
  var state = strm.state;                                                                                              // 7539
  if (state.window) {                                                                                                  // 7540
    state.window = null;                                                                                               // 7541
  }                                                                                                                    // 7542
  strm.state = null;                                                                                                   // 7543
  return Z_OK;                                                                                                         // 7544
}                                                                                                                      // 7545
                                                                                                                       // 7546
function inflateGetHeader(strm, head) {                                                                                // 7547
  var state;                                                                                                           // 7548
                                                                                                                       // 7549
  /* check state */                                                                                                    // 7550
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }                                                                 // 7551
  state = strm.state;                                                                                                  // 7552
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }                                                               // 7553
                                                                                                                       // 7554
  /* save header structure */                                                                                          // 7555
  state.head = head;                                                                                                   // 7556
  head.done = false;                                                                                                   // 7557
  return Z_OK;                                                                                                         // 7558
}                                                                                                                      // 7559
                                                                                                                       // 7560
                                                                                                                       // 7561
exports.inflateReset = inflateReset;                                                                                   // 7562
exports.inflateReset2 = inflateReset2;                                                                                 // 7563
exports.inflateResetKeep = inflateResetKeep;                                                                           // 7564
exports.inflateInit = inflateInit;                                                                                     // 7565
exports.inflateInit2 = inflateInit2;                                                                                   // 7566
exports.inflate = inflate;                                                                                             // 7567
exports.inflateEnd = inflateEnd;                                                                                       // 7568
exports.inflateGetHeader = inflateGetHeader;                                                                           // 7569
exports.inflateInfo = 'pako inflate (from Nodeca project)';                                                            // 7570
                                                                                                                       // 7571
/* Not implemented                                                                                                     // 7572
exports.inflateCopy = inflateCopy;                                                                                     // 7573
exports.inflateGetDictionary = inflateGetDictionary;                                                                   // 7574
exports.inflateMark = inflateMark;                                                                                     // 7575
exports.inflatePrime = inflatePrime;                                                                                   // 7576
exports.inflateSetDictionary = inflateSetDictionary;                                                                   // 7577
exports.inflateSync = inflateSync;                                                                                     // 7578
exports.inflateSyncPoint = inflateSyncPoint;                                                                           // 7579
exports.inflateUndermine = inflateUndermine;                                                                           // 7580
*/                                                                                                                     // 7581
},{"../utils/common":27,"./adler32":29,"./crc32":31,"./inffast":34,"./inftrees":36}],36:[function(_dereq_,module,exports){
'use strict';                                                                                                          // 7583
                                                                                                                       // 7584
                                                                                                                       // 7585
var utils = _dereq_('../utils/common');                                                                                // 7586
                                                                                                                       // 7587
var MAXBITS = 15;                                                                                                      // 7588
var ENOUGH_LENS = 852;                                                                                                 // 7589
var ENOUGH_DISTS = 592;                                                                                                // 7590
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);                                                                             // 7591
                                                                                                                       // 7592
var CODES = 0;                                                                                                         // 7593
var LENS = 1;                                                                                                          // 7594
var DISTS = 2;                                                                                                         // 7595
                                                                                                                       // 7596
var lbase = [ /* Length codes 257..285 base */                                                                         // 7597
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,                                                             // 7598
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0                                                       // 7599
];                                                                                                                     // 7600
                                                                                                                       // 7601
var lext = [ /* Length codes 257..285 extra */                                                                         // 7602
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,                                                      // 7603
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78                                                           // 7604
];                                                                                                                     // 7605
                                                                                                                       // 7606
var dbase = [ /* Distance codes 0..29 base */                                                                          // 7607
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,                                                           // 7608
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,                                                              // 7609
  8193, 12289, 16385, 24577, 0, 0                                                                                      // 7610
];                                                                                                                     // 7611
                                                                                                                       // 7612
var dext = [ /* Distance codes 0..29 extra */                                                                          // 7613
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,                                                      // 7614
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,                                                                              // 7615
  28, 28, 29, 29, 64, 64                                                                                               // 7616
];                                                                                                                     // 7617
                                                                                                                       // 7618
module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)                 // 7619
{                                                                                                                      // 7620
  var bits = opts.bits;                                                                                                // 7621
      //here = opts.here; /* table entry for duplication */                                                            // 7622
                                                                                                                       // 7623
  var len = 0;               /* a code's length in bits */                                                             // 7624
  var sym = 0;               /* index of code symbols */                                                               // 7625
  var min = 0, max = 0;          /* minimum and maximum code lengths */                                                // 7626
  var root = 0;              /* number of index bits for root table */                                                 // 7627
  var curr = 0;              /* number of index bits for current table */                                              // 7628
  var drop = 0;              /* code bits to drop for sub-table */                                                     // 7629
  var left = 0;                   /* number of prefix codes available */                                               // 7630
  var used = 0;              /* code entries in table used */                                                          // 7631
  var huff = 0;              /* Huffman code */                                                                        // 7632
  var incr;              /* for incrementing code, index */                                                            // 7633
  var fill;              /* index for replicating entries */                                                           // 7634
  var low;               /* low bits for current root entry */                                                         // 7635
  var mask;              /* mask for low root bits */                                                                  // 7636
  var next;             /* next available space in table */                                                            // 7637
  var base = null;     /* base value table to use */                                                                   // 7638
  var base_index = 0;                                                                                                  // 7639
//  var shoextra;    /* extra bits table to use */                                                                     // 7640
  var end;                    /* use base and extra for symbol > end */                                                // 7641
  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */                       // 7642
  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */                     // 7643
  var extra = null;                                                                                                    // 7644
  var extra_index = 0;                                                                                                 // 7645
                                                                                                                       // 7646
  var here_bits, here_op, here_val;                                                                                    // 7647
                                                                                                                       // 7648
  /*                                                                                                                   // 7649
   Process a set of code lengths to create a canonical Huffman code.  The                                              // 7650
   code lengths are lens[0..codes-1].  Each length corresponds to the                                                  // 7651
   symbols 0..codes-1.  The Huffman code is generated by first sorting the                                             // 7652
   symbols by length from short to long, and retaining the symbol order                                                // 7653
   for codes with equal lengths.  Then the code starts with all zero bits                                              // 7654
   for the first code of the shortest length, and the codes are integer                                                // 7655
   increments for the same length, and zeros are appended as the length                                                // 7656
   increases.  For the deflate format, these bits are stored backwards                                                 // 7657
   from their more natural integer increment ordering, and so when the                                                 // 7658
   decoding tables are built in the large loop below, the integer codes                                                // 7659
   are incremented backwards.                                                                                          // 7660
                                                                                                                       // 7661
   This routine assumes, but does not check, that all of the entries in                                                // 7662
   lens[] are in the range 0..MAXBITS.  The caller must assure this.                                                   // 7663
   1..MAXBITS is interpreted as that code length.  zero means that that                                                // 7664
   symbol does not occur in this code.                                                                                 // 7665
                                                                                                                       // 7666
   The codes are sorted by computing a count of codes for each length,                                                 // 7667
   creating from that a table of starting indices for each length in the                                               // 7668
   sorted table, and then entering the symbols in order in the sorted                                                  // 7669
   table.  The sorted table is work[], with that space being provided by                                               // 7670
   the caller.                                                                                                         // 7671
                                                                                                                       // 7672
   The length counts are used for other purposes as well, i.e. finding                                                 // 7673
   the minimum and maximum length codes, determining if there are any                                                  // 7674
   codes at all, checking for a valid set of lengths, and looking ahead                                                // 7675
   at length counts to determine sub-table sizes when building the                                                     // 7676
   decoding tables.                                                                                                    // 7677
   */                                                                                                                  // 7678
                                                                                                                       // 7679
  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */                                                // 7680
  for (len = 0; len <= MAXBITS; len++) {                                                                               // 7681
    count[len] = 0;                                                                                                    // 7682
  }                                                                                                                    // 7683
  for (sym = 0; sym < codes; sym++) {                                                                                  // 7684
    count[lens[lens_index + sym]]++;                                                                                   // 7685
  }                                                                                                                    // 7686
                                                                                                                       // 7687
  /* bound code lengths, force root to be within code lengths */                                                       // 7688
  root = bits;                                                                                                         // 7689
  for (max = MAXBITS; max >= 1; max--) {                                                                               // 7690
    if (count[max] !== 0) { break; }                                                                                   // 7691
  }                                                                                                                    // 7692
  if (root > max) {                                                                                                    // 7693
    root = max;                                                                                                        // 7694
  }                                                                                                                    // 7695
  if (max === 0) {                     /* no symbols to code at all */                                                 // 7696
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */                         // 7697
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;                                                   // 7698
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;                                                  // 7699
    table[table_index++] = (1 << 24) | (64 << 16) | 0;                                                                 // 7700
                                                                                                                       // 7701
                                                                                                                       // 7702
    //table.op[opts.table_index] = 64;                                                                                 // 7703
    //table.bits[opts.table_index] = 1;                                                                                // 7704
    //table.val[opts.table_index++] = 0;                                                                               // 7705
    table[table_index++] = (1 << 24) | (64 << 16) | 0;                                                                 // 7706
                                                                                                                       // 7707
    opts.bits = 1;                                                                                                     // 7708
    return 0;     /* no symbols, but wait for decoding to report error */                                              // 7709
  }                                                                                                                    // 7710
  for (min = 1; min < max; min++) {                                                                                    // 7711
    if (count[min] !== 0) { break; }                                                                                   // 7712
  }                                                                                                                    // 7713
  if (root < min) {                                                                                                    // 7714
    root = min;                                                                                                        // 7715
  }                                                                                                                    // 7716
                                                                                                                       // 7717
  /* check for an over-subscribed or incomplete set of lengths */                                                      // 7718
  left = 1;                                                                                                            // 7719
  for (len = 1; len <= MAXBITS; len++) {                                                                               // 7720
    left <<= 1;                                                                                                        // 7721
    left -= count[len];                                                                                                // 7722
    if (left < 0) {                                                                                                    // 7723
      return -1;                                                                                                       // 7724
    }        /* over-subscribed */                                                                                     // 7725
  }                                                                                                                    // 7726
  if (left > 0 && (type === CODES || max !== 1)) {                                                                     // 7727
    return -1;                      /* incomplete set */                                                               // 7728
  }                                                                                                                    // 7729
                                                                                                                       // 7730
  /* generate offsets into symbol table for each length for sorting */                                                 // 7731
  offs[1] = 0;                                                                                                         // 7732
  for (len = 1; len < MAXBITS; len++) {                                                                                // 7733
    offs[len + 1] = offs[len] + count[len];                                                                            // 7734
  }                                                                                                                    // 7735
                                                                                                                       // 7736
  /* sort symbols by length, by symbol order within each length */                                                     // 7737
  for (sym = 0; sym < codes; sym++) {                                                                                  // 7738
    if (lens[lens_index + sym] !== 0) {                                                                                // 7739
      work[offs[lens[lens_index + sym]]++] = sym;                                                                      // 7740
    }                                                                                                                  // 7741
  }                                                                                                                    // 7742
                                                                                                                       // 7743
  /*                                                                                                                   // 7744
   Create and fill in decoding tables.  In this loop, the table being                                                  // 7745
   filled is at next and has curr index bits.  The code being used is huff                                             // 7746
   with length len.  That code is converted to an index by dropping drop                                               // 7747
   bits off of the bottom.  For codes where len is less than drop + curr,                                              // 7748
   those top drop + curr - len bits are incremented through all values to                                              // 7749
   fill the table with replicated entries.                                                                             // 7750
                                                                                                                       // 7751
   root is the number of index bits for the root table.  When len exceeds                                              // 7752
   root, sub-tables are created pointed to by the root entry with an index                                             // 7753
   of the low root bits of huff.  This is saved in low to check for when a                                             // 7754
   new sub-table should be started.  drop is zero when the root table is                                               // 7755
   being filled, and drop is root when sub-tables are being filled.                                                    // 7756
                                                                                                                       // 7757
   When a new sub-table is needed, it is necessary to look ahead in the                                                // 7758
   code lengths to determine what size sub-table is needed.  The length                                                // 7759
   counts are used for this, and so count[] is decremented as codes are                                                // 7760
   entered in the tables.                                                                                              // 7761
                                                                                                                       // 7762
   used keeps track of how many table entries have been allocated from the                                             // 7763
   provided *table space.  It is checked for LENS and DIST tables against                                              // 7764
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in                                              // 7765
   the initial root table size constants.  See the comments in inftrees.h                                              // 7766
   for more information.                                                                                               // 7767
                                                                                                                       // 7768
   sym increments through all symbols, and the loop terminates when                                                    // 7769
   all codes of length max, i.e. all codes, have been processed.  This                                                 // 7770
   routine permits incomplete codes, so another loop after this one fills                                              // 7771
   in the rest of the decoding tables with invalid code markers.                                                       // 7772
   */                                                                                                                  // 7773
                                                                                                                       // 7774
  /* set up for code type */                                                                                           // 7775
  // poor man optimization - use if-else instead of switch,                                                            // 7776
  // to avoid deopts in old v8                                                                                         // 7777
  if (type === CODES) {                                                                                                // 7778
      base = extra = work;    /* dummy value--not used */                                                              // 7779
      end = 19;                                                                                                        // 7780
  } else if (type === LENS) {                                                                                          // 7781
      base = lbase;                                                                                                    // 7782
      base_index -= 257;                                                                                               // 7783
      extra = lext;                                                                                                    // 7784
      extra_index -= 257;                                                                                              // 7785
      end = 256;                                                                                                       // 7786
  } else {                    /* DISTS */                                                                              // 7787
      base = dbase;                                                                                                    // 7788
      extra = dext;                                                                                                    // 7789
      end = -1;                                                                                                        // 7790
  }                                                                                                                    // 7791
                                                                                                                       // 7792
  /* initialize opts for loop */                                                                                       // 7793
  huff = 0;                   /* starting code */                                                                      // 7794
  sym = 0;                    /* starting code symbol */                                                               // 7795
  len = min;                  /* starting code length */                                                               // 7796
  next = table_index;              /* current table to fill in */                                                      // 7797
  curr = root;                /* current table index bits */                                                           // 7798
  drop = 0;                   /* current bits to drop from code for index */                                           // 7799
  low = -1;                   /* trigger new sub-table when len > root */                                              // 7800
  used = 1 << root;          /* use root table entries */                                                              // 7801
  mask = used - 1;            /* mask for comparing low */                                                             // 7802
                                                                                                                       // 7803
  /* check available table space */                                                                                    // 7804
  if ((type === LENS && used > ENOUGH_LENS) ||                                                                         // 7805
    (type === DISTS && used > ENOUGH_DISTS)) {                                                                         // 7806
    return 1;                                                                                                          // 7807
  }                                                                                                                    // 7808
                                                                                                                       // 7809
  var i=0;                                                                                                             // 7810
  /* process all codes and make table entries */                                                                       // 7811
  for (;;) {                                                                                                           // 7812
    i++;                                                                                                               // 7813
    /* create table entry */                                                                                           // 7814
    here_bits = len - drop;                                                                                            // 7815
    if (work[sym] < end) {                                                                                             // 7816
      here_op = 0;                                                                                                     // 7817
      here_val = work[sym];                                                                                            // 7818
    }                                                                                                                  // 7819
    else if (work[sym] > end) {                                                                                        // 7820
      here_op = extra[extra_index + work[sym]];                                                                        // 7821
      here_val = base[base_index + work[sym]];                                                                         // 7822
    }                                                                                                                  // 7823
    else {                                                                                                             // 7824
      here_op = 32 + 64;         /* end of block */                                                                    // 7825
      here_val = 0;                                                                                                    // 7826
    }                                                                                                                  // 7827
                                                                                                                       // 7828
    /* replicate for those indices with low len bits equal to huff */                                                  // 7829
    incr = 1 << (len - drop);                                                                                          // 7830
    fill = 1 << curr;                                                                                                  // 7831
    min = fill;                 /* save offset to next table */                                                        // 7832
    do {                                                                                                               // 7833
      fill -= incr;                                                                                                    // 7834
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;                         // 7835
    } while (fill !== 0);                                                                                              // 7836
                                                                                                                       // 7837
    /* backwards increment the len-bit code huff */                                                                    // 7838
    incr = 1 << (len - 1);                                                                                             // 7839
    while (huff & incr) {                                                                                              // 7840
      incr >>= 1;                                                                                                      // 7841
    }                                                                                                                  // 7842
    if (incr !== 0) {                                                                                                  // 7843
      huff &= incr - 1;                                                                                                // 7844
      huff += incr;                                                                                                    // 7845
    } else {                                                                                                           // 7846
      huff = 0;                                                                                                        // 7847
    }                                                                                                                  // 7848
                                                                                                                       // 7849
    /* go to next symbol, update count, len */                                                                         // 7850
    sym++;                                                                                                             // 7851
    if (--count[len] === 0) {                                                                                          // 7852
      if (len === max) { break; }                                                                                      // 7853
      len = lens[lens_index + work[sym]];                                                                              // 7854
    }                                                                                                                  // 7855
                                                                                                                       // 7856
    /* create new sub-table if needed */                                                                               // 7857
    if (len > root && (huff & mask) !== low) {                                                                         // 7858
      /* if first time, transition to sub-tables */                                                                    // 7859
      if (drop === 0) {                                                                                                // 7860
        drop = root;                                                                                                   // 7861
      }                                                                                                                // 7862
                                                                                                                       // 7863
      /* increment past last table */                                                                                  // 7864
      next += min;            /* here min is 1 << curr */                                                              // 7865
                                                                                                                       // 7866
      /* determine length of next table */                                                                             // 7867
      curr = len - drop;                                                                                               // 7868
      left = 1 << curr;                                                                                                // 7869
      while (curr + drop < max) {                                                                                      // 7870
        left -= count[curr + drop];                                                                                    // 7871
        if (left <= 0) { break; }                                                                                      // 7872
        curr++;                                                                                                        // 7873
        left <<= 1;                                                                                                    // 7874
      }                                                                                                                // 7875
                                                                                                                       // 7876
      /* check for enough space */                                                                                     // 7877
      used += 1 << curr;                                                                                               // 7878
      if ((type === LENS && used > ENOUGH_LENS) ||                                                                     // 7879
        (type === DISTS && used > ENOUGH_DISTS)) {                                                                     // 7880
        return 1;                                                                                                      // 7881
      }                                                                                                                // 7882
                                                                                                                       // 7883
      /* point entry in root table to sub-table */                                                                     // 7884
      low = huff & mask;                                                                                               // 7885
      /*table.op[low] = curr;                                                                                          // 7886
      table.bits[low] = root;                                                                                          // 7887
      table.val[low] = next - opts.table_index;*/                                                                      // 7888
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;                                              // 7889
    }                                                                                                                  // 7890
  }                                                                                                                    // 7891
                                                                                                                       // 7892
  /* fill in remaining table entry if code is incomplete (guaranteed to have                                           // 7893
   at most one remaining entry, since if the code is incomplete, the                                                   // 7894
   maximum code length that was allowed to get this far is one bit) */                                                 // 7895
  if (huff !== 0) {                                                                                                    // 7896
    //table.op[next + huff] = 64;            /* invalid code marker */                                                 // 7897
    //table.bits[next + huff] = len - drop;                                                                            // 7898
    //table.val[next + huff] = 0;                                                                                      // 7899
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;                                                         // 7900
  }                                                                                                                    // 7901
                                                                                                                       // 7902
  /* set return parameters */                                                                                          // 7903
  //opts.table_index += used;                                                                                          // 7904
  opts.bits = root;                                                                                                    // 7905
  return 0;                                                                                                            // 7906
};                                                                                                                     // 7907
                                                                                                                       // 7908
},{"../utils/common":27}],37:[function(_dereq_,module,exports){                                                        // 7909
'use strict';                                                                                                          // 7910
                                                                                                                       // 7911
module.exports = {                                                                                                     // 7912
  '2':    'need dictionary',     /* Z_NEED_DICT       2  */                                                            // 7913
  '1':    'stream end',          /* Z_STREAM_END      1  */                                                            // 7914
  '0':    '',                    /* Z_OK              0  */                                                            // 7915
  '-1':   'file error',          /* Z_ERRNO         (-1) */                                                            // 7916
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */                                                            // 7917
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */                                                            // 7918
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */                                                            // 7919
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */                                                            // 7920
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */                                                            // 7921
};                                                                                                                     // 7922
},{}],38:[function(_dereq_,module,exports){                                                                            // 7923
'use strict';                                                                                                          // 7924
                                                                                                                       // 7925
                                                                                                                       // 7926
var utils = _dereq_('../utils/common');                                                                                // 7927
                                                                                                                       // 7928
/* Public constants ==========================================================*/                                       // 7929
/* ===========================================================================*/                                       // 7930
                                                                                                                       // 7931
                                                                                                                       // 7932
//var Z_FILTERED          = 1;                                                                                         // 7933
//var Z_HUFFMAN_ONLY      = 2;                                                                                         // 7934
//var Z_RLE               = 3;                                                                                         // 7935
var Z_FIXED               = 4;                                                                                         // 7936
//var Z_DEFAULT_STRATEGY  = 0;                                                                                         // 7937
                                                                                                                       // 7938
/* Possible values of the data_type field (though see inflate()) */                                                    // 7939
var Z_BINARY              = 0;                                                                                         // 7940
var Z_TEXT                = 1;                                                                                         // 7941
//var Z_ASCII             = 1; // = Z_TEXT                                                                             // 7942
var Z_UNKNOWN             = 2;                                                                                         // 7943
                                                                                                                       // 7944
/*============================================================================*/                                       // 7945
                                                                                                                       // 7946
                                                                                                                       // 7947
function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }                                      // 7948
                                                                                                                       // 7949
// From zutil.h                                                                                                        // 7950
                                                                                                                       // 7951
var STORED_BLOCK = 0;                                                                                                  // 7952
var STATIC_TREES = 1;                                                                                                  // 7953
var DYN_TREES    = 2;                                                                                                  // 7954
/* The three kinds of block type */                                                                                    // 7955
                                                                                                                       // 7956
var MIN_MATCH    = 3;                                                                                                  // 7957
var MAX_MATCH    = 258;                                                                                                // 7958
/* The minimum and maximum match lengths */                                                                            // 7959
                                                                                                                       // 7960
// From deflate.h                                                                                                      // 7961
/* ===========================================================================                                         // 7962
 * Internal compression state.                                                                                         // 7963
 */                                                                                                                    // 7964
                                                                                                                       // 7965
var LENGTH_CODES  = 29;                                                                                                // 7966
/* number of length codes, not counting the special END_BLOCK code */                                                  // 7967
                                                                                                                       // 7968
var LITERALS      = 256;                                                                                               // 7969
/* number of literal bytes 0..255 */                                                                                   // 7970
                                                                                                                       // 7971
var L_CODES       = LITERALS + 1 + LENGTH_CODES;                                                                       // 7972
/* number of Literal or Length codes, including the END_BLOCK code */                                                  // 7973
                                                                                                                       // 7974
var D_CODES       = 30;                                                                                                // 7975
/* number of distance codes */                                                                                         // 7976
                                                                                                                       // 7977
var BL_CODES      = 19;                                                                                                // 7978
/* number of codes used to transfer the bit lengths */                                                                 // 7979
                                                                                                                       // 7980
var HEAP_SIZE     = 2*L_CODES + 1;                                                                                     // 7981
/* maximum heap size */                                                                                                // 7982
                                                                                                                       // 7983
var MAX_BITS      = 15;                                                                                                // 7984
/* All codes must not exceed MAX_BITS bits */                                                                          // 7985
                                                                                                                       // 7986
var Buf_size      = 16;                                                                                                // 7987
/* size of bit buffer in bi_buf */                                                                                     // 7988
                                                                                                                       // 7989
                                                                                                                       // 7990
/* ===========================================================================                                         // 7991
 * Constants                                                                                                           // 7992
 */                                                                                                                    // 7993
                                                                                                                       // 7994
var MAX_BL_BITS = 7;                                                                                                   // 7995
/* Bit length codes must not exceed MAX_BL_BITS bits */                                                                // 7996
                                                                                                                       // 7997
var END_BLOCK   = 256;                                                                                                 // 7998
/* end of block literal code */                                                                                        // 7999
                                                                                                                       // 8000
var REP_3_6     = 16;                                                                                                  // 8001
/* repeat previous bit length 3-6 times (2 bits of repeat count) */                                                    // 8002
                                                                                                                       // 8003
var REPZ_3_10   = 17;                                                                                                  // 8004
/* repeat a zero length 3-10 times  (3 bits of repeat count) */                                                        // 8005
                                                                                                                       // 8006
var REPZ_11_138 = 18;                                                                                                  // 8007
/* repeat a zero length 11-138 times  (7 bits of repeat count) */                                                      // 8008
                                                                                                                       // 8009
var extra_lbits =   /* extra bits for each length code */                                                              // 8010
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];                                                         // 8011
                                                                                                                       // 8012
var extra_dbits =   /* extra bits for each distance code */                                                            // 8013
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];                                               // 8014
                                                                                                                       // 8015
var extra_blbits =  /* extra bits for each bit length code */                                                          // 8016
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];                                                                             // 8017
                                                                                                                       // 8018
var bl_order =                                                                                                         // 8019
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];                                                                    // 8020
/* The lengths of the bit length codes are sent in order of decreasing                                                 // 8021
 * probability, to avoid transmitting the lengths for unused bit length codes.                                         // 8022
 */                                                                                                                    // 8023
                                                                                                                       // 8024
/* ===========================================================================                                         // 8025
 * Local data. These are initialized only once.                                                                        // 8026
 */                                                                                                                    // 8027
                                                                                                                       // 8028
// We pre-fill arrays with 0 to avoid uninitialized gaps                                                               // 8029
                                                                                                                       // 8030
var DIST_CODE_LEN = 512; /* see definition of array dist_code below */                                                 // 8031
                                                                                                                       // 8032
// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1                                                   // 8033
var static_ltree  = new Array((L_CODES+2) * 2);                                                                        // 8034
zero(static_ltree);                                                                                                    // 8035
/* The static literal tree. Since the bit lengths are imposed, there is no                                             // 8036
 * need for the L_CODES extra codes used during heap construction. However                                             // 8037
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init                                            // 8038
 * below).                                                                                                             // 8039
 */                                                                                                                    // 8040
                                                                                                                       // 8041
var static_dtree  = new Array(D_CODES * 2);                                                                            // 8042
zero(static_dtree);                                                                                                    // 8043
/* The static distance tree. (Actually a trivial tree since all codes use                                              // 8044
 * 5 bits.)                                                                                                            // 8045
 */                                                                                                                    // 8046
                                                                                                                       // 8047
var _dist_code    = new Array(DIST_CODE_LEN);                                                                          // 8048
zero(_dist_code);                                                                                                      // 8049
/* Distance codes. The first 256 values correspond to the distances                                                    // 8050
 * 3 .. 258, the last 256 values correspond to the top 8 bits of                                                       // 8051
 * the 15 bit distances.                                                                                               // 8052
 */                                                                                                                    // 8053
                                                                                                                       // 8054
var _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);                                                                  // 8055
zero(_length_code);                                                                                                    // 8056
/* length code for each normalized match length (0 == MIN_MATCH) */                                                    // 8057
                                                                                                                       // 8058
var base_length   = new Array(LENGTH_CODES);                                                                           // 8059
zero(base_length);                                                                                                     // 8060
/* First normalized length for each code (0 = MIN_MATCH) */                                                            // 8061
                                                                                                                       // 8062
var base_dist     = new Array(D_CODES);                                                                                // 8063
zero(base_dist);                                                                                                       // 8064
/* First normalized distance for each code (0 = distance of 1) */                                                      // 8065
                                                                                                                       // 8066
                                                                                                                       // 8067
var StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {                               // 8068
                                                                                                                       // 8069
  this.static_tree  = static_tree;  /* static tree or NULL */                                                          // 8070
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */                                             // 8071
  this.extra_base   = extra_base;   /* base index for extra_bits */                                                    // 8072
  this.elems        = elems;        /* max number of elements in the tree */                                           // 8073
  this.max_length   = max_length;   /* max bit length for the codes */                                                 // 8074
                                                                                                                       // 8075
  // show if `static_tree` has data or dummy - needed for monomorphic objects                                          // 8076
  this.has_stree    = static_tree && static_tree.length;                                                               // 8077
};                                                                                                                     // 8078
                                                                                                                       // 8079
                                                                                                                       // 8080
var static_l_desc;                                                                                                     // 8081
var static_d_desc;                                                                                                     // 8082
var static_bl_desc;                                                                                                    // 8083
                                                                                                                       // 8084
                                                                                                                       // 8085
var TreeDesc = function(dyn_tree, stat_desc) {                                                                         // 8086
  this.dyn_tree = dyn_tree;     /* the dynamic tree */                                                                 // 8087
  this.max_code = 0;            /* largest code with non zero frequency */                                             // 8088
  this.stat_desc = stat_desc;   /* the corresponding static tree */                                                    // 8089
};                                                                                                                     // 8090
                                                                                                                       // 8091
                                                                                                                       // 8092
                                                                                                                       // 8093
function d_code(dist) {                                                                                                // 8094
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];                                               // 8095
}                                                                                                                      // 8096
                                                                                                                       // 8097
                                                                                                                       // 8098
/* ===========================================================================                                         // 8099
 * Output a short LSB first on the stream.                                                                             // 8100
 * IN assertion: there is enough room in pendingBuf.                                                                   // 8101
 */                                                                                                                    // 8102
function put_short (s, w) {                                                                                            // 8103
//    put_byte(s, (uch)((w) & 0xff));                                                                                  // 8104
//    put_byte(s, (uch)((ush)(w) >> 8));                                                                               // 8105
  s.pending_buf[s.pending++] = (w) & 0xff;                                                                             // 8106
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;                                                                       // 8107
}                                                                                                                      // 8108
                                                                                                                       // 8109
                                                                                                                       // 8110
/* ===========================================================================                                         // 8111
 * Send a value on a given number of bits.                                                                             // 8112
 * IN assertion: length <= 16 and value fits in length bits.                                                           // 8113
 */                                                                                                                    // 8114
function send_bits(s, value, length) {                                                                                 // 8115
  if (s.bi_valid > (Buf_size - length)) {                                                                              // 8116
    s.bi_buf |= (value << s.bi_valid) & 0xffff;                                                                        // 8117
    put_short(s, s.bi_buf);                                                                                            // 8118
    s.bi_buf = value >> (Buf_size - s.bi_valid);                                                                       // 8119
    s.bi_valid += length - Buf_size;                                                                                   // 8120
  } else {                                                                                                             // 8121
    s.bi_buf |= (value << s.bi_valid) & 0xffff;                                                                        // 8122
    s.bi_valid += length;                                                                                              // 8123
  }                                                                                                                    // 8124
}                                                                                                                      // 8125
                                                                                                                       // 8126
                                                                                                                       // 8127
function send_code(s, c, tree) {                                                                                       // 8128
  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);                                                             // 8129
}                                                                                                                      // 8130
                                                                                                                       // 8131
                                                                                                                       // 8132
/* ===========================================================================                                         // 8133
 * Reverse the first len bits of a code, using straightforward code (a faster                                          // 8134
 * method would use a table)                                                                                           // 8135
 * IN assertion: 1 <= len <= 15                                                                                        // 8136
 */                                                                                                                    // 8137
function bi_reverse(code, len) {                                                                                       // 8138
  var res = 0;                                                                                                         // 8139
  do {                                                                                                                 // 8140
    res |= code & 1;                                                                                                   // 8141
    code >>>= 1;                                                                                                       // 8142
    res <<= 1;                                                                                                         // 8143
  } while (--len > 0);                                                                                                 // 8144
  return res >>> 1;                                                                                                    // 8145
}                                                                                                                      // 8146
                                                                                                                       // 8147
                                                                                                                       // 8148
/* ===========================================================================                                         // 8149
 * Flush the bit buffer, keeping at most 7 bits in it.                                                                 // 8150
 */                                                                                                                    // 8151
function bi_flush(s) {                                                                                                 // 8152
  if (s.bi_valid === 16) {                                                                                             // 8153
    put_short(s, s.bi_buf);                                                                                            // 8154
    s.bi_buf = 0;                                                                                                      // 8155
    s.bi_valid = 0;                                                                                                    // 8156
                                                                                                                       // 8157
  } else if (s.bi_valid >= 8) {                                                                                        // 8158
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;                                                                      // 8159
    s.bi_buf >>= 8;                                                                                                    // 8160
    s.bi_valid -= 8;                                                                                                   // 8161
  }                                                                                                                    // 8162
}                                                                                                                      // 8163
                                                                                                                       // 8164
                                                                                                                       // 8165
/* ===========================================================================                                         // 8166
 * Compute the optimal bit lengths for a tree and update the total bit length                                          // 8167
 * for the current block.                                                                                              // 8168
 * IN assertion: the fields freq and dad are set, heap[heap_max] and                                                   // 8169
 *    above are the tree nodes sorted by increasing frequency.                                                         // 8170
 * OUT assertions: the field len is set to the optimal bit length, the                                                 // 8171
 *     array bl_count contains the frequencies for each bit length.                                                    // 8172
 *     The length opt_len is updated; static_len is also updated if stree is                                           // 8173
 *     not null.                                                                                                       // 8174
 */                                                                                                                    // 8175
function gen_bitlen(s, desc)                                                                                           // 8176
//    deflate_state *s;                                                                                                // 8177
//    tree_desc *desc;    /* the tree descriptor */                                                                    // 8178
{                                                                                                                      // 8179
  var tree            = desc.dyn_tree;                                                                                 // 8180
  var max_code        = desc.max_code;                                                                                 // 8181
  var stree           = desc.stat_desc.static_tree;                                                                    // 8182
  var has_stree       = desc.stat_desc.has_stree;                                                                      // 8183
  var extra           = desc.stat_desc.extra_bits;                                                                     // 8184
  var base            = desc.stat_desc.extra_base;                                                                     // 8185
  var max_length      = desc.stat_desc.max_length;                                                                     // 8186
  var h;              /* heap index */                                                                                 // 8187
  var n, m;           /* iterate over the tree elements */                                                             // 8188
  var bits;           /* bit length */                                                                                 // 8189
  var xbits;          /* extra bits */                                                                                 // 8190
  var f;              /* frequency */                                                                                  // 8191
  var overflow = 0;   /* number of elements with bit length too large */                                               // 8192
                                                                                                                       // 8193
  for (bits = 0; bits <= MAX_BITS; bits++) {                                                                           // 8194
    s.bl_count[bits] = 0;                                                                                              // 8195
  }                                                                                                                    // 8196
                                                                                                                       // 8197
  /* In a first pass, compute the optimal bit lengths (which may                                                       // 8198
   * overflow in the case of the bit length tree).                                                                     // 8199
   */                                                                                                                  // 8200
  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */                                                   // 8201
                                                                                                                       // 8202
  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {                                                                         // 8203
    n = s.heap[h];                                                                                                     // 8204
    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;                                                             // 8205
    if (bits > max_length) {                                                                                           // 8206
      bits = max_length;                                                                                               // 8207
      overflow++;                                                                                                      // 8208
    }                                                                                                                  // 8209
    tree[n*2 + 1]/*.Len*/ = bits;                                                                                      // 8210
    /* We overwrite tree[n].Dad which is no longer needed */                                                           // 8211
                                                                                                                       // 8212
    if (n > max_code) { continue; } /* not a leaf node */                                                              // 8213
                                                                                                                       // 8214
    s.bl_count[bits]++;                                                                                                // 8215
    xbits = 0;                                                                                                         // 8216
    if (n >= base) {                                                                                                   // 8217
      xbits = extra[n-base];                                                                                           // 8218
    }                                                                                                                  // 8219
    f = tree[n * 2]/*.Freq*/;                                                                                          // 8220
    s.opt_len += f * (bits + xbits);                                                                                   // 8221
    if (has_stree) {                                                                                                   // 8222
      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);                                                            // 8223
    }                                                                                                                  // 8224
  }                                                                                                                    // 8225
  if (overflow === 0) { return; }                                                                                      // 8226
                                                                                                                       // 8227
  // Trace((stderr,"\nbit length overflow\n"));                                                                        // 8228
  /* This happens for example on obj2 and pic of the Calgary corpus */                                                 // 8229
                                                                                                                       // 8230
  /* Find the first bit length which could increase: */                                                                // 8231
  do {                                                                                                                 // 8232
    bits = max_length-1;                                                                                               // 8233
    while (s.bl_count[bits] === 0) { bits--; }                                                                         // 8234
    s.bl_count[bits]--;      /* move one leaf down the tree */                                                         // 8235
    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */                                               // 8236
    s.bl_count[max_length]--;                                                                                          // 8237
    /* The brother of the overflow item also moves one step up,                                                        // 8238
     * but this does not affect bl_count[max_length]                                                                   // 8239
     */                                                                                                                // 8240
    overflow -= 2;                                                                                                     // 8241
  } while (overflow > 0);                                                                                              // 8242
                                                                                                                       // 8243
  /* Now recompute all bit lengths, scanning in increasing frequency.                                                  // 8244
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all                                                  // 8245
   * lengths instead of fixing only the wrong ones. This idea is taken                                                 // 8246
   * from 'ar' written by Haruhiko Okumura.)                                                                           // 8247
   */                                                                                                                  // 8248
  for (bits = max_length; bits !== 0; bits--) {                                                                        // 8249
    n = s.bl_count[bits];                                                                                              // 8250
    while (n !== 0) {                                                                                                  // 8251
      m = s.heap[--h];                                                                                                 // 8252
      if (m > max_code) { continue; }                                                                                  // 8253
      if (tree[m*2 + 1]/*.Len*/ !== bits) {                                                                            // 8254
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));                                              // 8255
        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;                                                // 8256
        tree[m*2 + 1]/*.Len*/ = bits;                                                                                  // 8257
      }                                                                                                                // 8258
      n--;                                                                                                             // 8259
    }                                                                                                                  // 8260
  }                                                                                                                    // 8261
}                                                                                                                      // 8262
                                                                                                                       // 8263
                                                                                                                       // 8264
/* ===========================================================================                                         // 8265
 * Generate the codes for a given tree and bit counts (which need not be                                               // 8266
 * optimal).                                                                                                           // 8267
 * IN assertion: the array bl_count contains the bit length statistics for                                             // 8268
 * the given tree and the field len is set for all tree elements.                                                      // 8269
 * OUT assertion: the field code is set for all tree elements of non                                                   // 8270
 *     zero code length.                                                                                               // 8271
 */                                                                                                                    // 8272
function gen_codes(tree, max_code, bl_count)                                                                           // 8273
//    ct_data *tree;             /* the tree to decorate */                                                            // 8274
//    int max_code;              /* largest code with non zero frequency */                                            // 8275
//    ushf *bl_count;            /* number of codes at each bit length */                                              // 8276
{                                                                                                                      // 8277
  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */                                     // 8278
  var code = 0;              /* running code value */                                                                  // 8279
  var bits;                  /* bit index */                                                                           // 8280
  var n;                     /* code index */                                                                          // 8281
                                                                                                                       // 8282
  /* The distribution counts are first used to generate the code values                                                // 8283
   * without bit reversal.                                                                                             // 8284
   */                                                                                                                  // 8285
  for (bits = 1; bits <= MAX_BITS; bits++) {                                                                           // 8286
    next_code[bits] = code = (code + bl_count[bits-1]) << 1;                                                           // 8287
  }                                                                                                                    // 8288
  /* Check that the bit counts in bl_count are consistent. The last code                                               // 8289
   * must be all ones.                                                                                                 // 8290
   */                                                                                                                  // 8291
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,                                                            // 8292
  //        "inconsistent bit counts");                                                                                // 8293
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));                                                            // 8294
                                                                                                                       // 8295
  for (n = 0;  n <= max_code; n++) {                                                                                   // 8296
    var len = tree[n*2 + 1]/*.Len*/;                                                                                   // 8297
    if (len === 0) { continue; }                                                                                       // 8298
    /* Now reverse the bits */                                                                                         // 8299
    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);                                                            // 8300
                                                                                                                       // 8301
    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",                                            // 8302
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));                                           // 8303
  }                                                                                                                    // 8304
}                                                                                                                      // 8305
                                                                                                                       // 8306
                                                                                                                       // 8307
/* ===========================================================================                                         // 8308
 * Initialize the various 'constant' tables.                                                                           // 8309
 */                                                                                                                    // 8310
function tr_static_init() {                                                                                            // 8311
  var n;        /* iterates over tree elements */                                                                      // 8312
  var bits;     /* bit counter */                                                                                      // 8313
  var length;   /* length value */                                                                                     // 8314
  var code;     /* code value */                                                                                       // 8315
  var dist;     /* distance index */                                                                                   // 8316
  var bl_count = new Array(MAX_BITS+1);                                                                                // 8317
  /* number of codes at each bit length for an optimal tree */                                                         // 8318
                                                                                                                       // 8319
  // do check in _tr_init()                                                                                            // 8320
  //if (static_init_done) return;                                                                                      // 8321
                                                                                                                       // 8322
  /* For some embedded targets, global variables are not initialized: */                                               // 8323
/*#ifdef NO_INIT_GLOBAL_POINTERS                                                                                       // 8324
  static_l_desc.static_tree = static_ltree;                                                                            // 8325
  static_l_desc.extra_bits = extra_lbits;                                                                              // 8326
  static_d_desc.static_tree = static_dtree;                                                                            // 8327
  static_d_desc.extra_bits = extra_dbits;                                                                              // 8328
  static_bl_desc.extra_bits = extra_blbits;                                                                            // 8329
#endif*/                                                                                                               // 8330
                                                                                                                       // 8331
  /* Initialize the mapping length (0..255) -> length code (0..28) */                                                  // 8332
  length = 0;                                                                                                          // 8333
  for (code = 0; code < LENGTH_CODES-1; code++) {                                                                      // 8334
    base_length[code] = length;                                                                                        // 8335
    for (n = 0; n < (1<<extra_lbits[code]); n++) {                                                                     // 8336
      _length_code[length++] = code;                                                                                   // 8337
    }                                                                                                                  // 8338
  }                                                                                                                    // 8339
  //Assert (length == 256, "tr_static_init: length != 256");                                                           // 8340
  /* Note that the length 255 (match length 258) can be represented                                                    // 8341
   * in two different ways: code 284 + 5 bits or code 285, so we                                                       // 8342
   * overwrite length_code[255] to use the best encoding:                                                              // 8343
   */                                                                                                                  // 8344
  _length_code[length-1] = code;                                                                                       // 8345
                                                                                                                       // 8346
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */                                                      // 8347
  dist = 0;                                                                                                            // 8348
  for (code = 0 ; code < 16; code++) {                                                                                 // 8349
    base_dist[code] = dist;                                                                                            // 8350
    for (n = 0; n < (1<<extra_dbits[code]); n++) {                                                                     // 8351
      _dist_code[dist++] = code;                                                                                       // 8352
    }                                                                                                                  // 8353
  }                                                                                                                    // 8354
  //Assert (dist == 256, "tr_static_init: dist != 256");                                                               // 8355
  dist >>= 7; /* from now on, all distances are divided by 128 */                                                      // 8356
  for ( ; code < D_CODES; code++) {                                                                                    // 8357
    base_dist[code] = dist << 7;                                                                                       // 8358
    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {                                                                 // 8359
      _dist_code[256 + dist++] = code;                                                                                 // 8360
    }                                                                                                                  // 8361
  }                                                                                                                    // 8362
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");                                                           // 8363
                                                                                                                       // 8364
  /* Construct the codes of the static literal tree */                                                                 // 8365
  for (bits = 0; bits <= MAX_BITS; bits++) {                                                                           // 8366
    bl_count[bits] = 0;                                                                                                // 8367
  }                                                                                                                    // 8368
                                                                                                                       // 8369
  n = 0;                                                                                                               // 8370
  while (n <= 143) {                                                                                                   // 8371
    static_ltree[n*2 + 1]/*.Len*/ = 8;                                                                                 // 8372
    n++;                                                                                                               // 8373
    bl_count[8]++;                                                                                                     // 8374
  }                                                                                                                    // 8375
  while (n <= 255) {                                                                                                   // 8376
    static_ltree[n*2 + 1]/*.Len*/ = 9;                                                                                 // 8377
    n++;                                                                                                               // 8378
    bl_count[9]++;                                                                                                     // 8379
  }                                                                                                                    // 8380
  while (n <= 279) {                                                                                                   // 8381
    static_ltree[n*2 + 1]/*.Len*/ = 7;                                                                                 // 8382
    n++;                                                                                                               // 8383
    bl_count[7]++;                                                                                                     // 8384
  }                                                                                                                    // 8385
  while (n <= 287) {                                                                                                   // 8386
    static_ltree[n*2 + 1]/*.Len*/ = 8;                                                                                 // 8387
    n++;                                                                                                               // 8388
    bl_count[8]++;                                                                                                     // 8389
  }                                                                                                                    // 8390
  /* Codes 286 and 287 do not exist, but we must include them in the                                                   // 8391
   * tree construction to get a canonical Huffman tree (longest code                                                   // 8392
   * all ones)                                                                                                         // 8393
   */                                                                                                                  // 8394
  gen_codes(static_ltree, L_CODES+1, bl_count);                                                                        // 8395
                                                                                                                       // 8396
  /* The static distance tree is trivial: */                                                                           // 8397
  for (n = 0; n < D_CODES; n++) {                                                                                      // 8398
    static_dtree[n*2 + 1]/*.Len*/ = 5;                                                                                 // 8399
    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);                                                                     // 8400
  }                                                                                                                    // 8401
                                                                                                                       // 8402
  // Now data ready and we can init static trees                                                                       // 8403
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);                        // 8404
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);                        // 8405
  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);                    // 8406
                                                                                                                       // 8407
  //static_init_done = true;                                                                                           // 8408
}                                                                                                                      // 8409
                                                                                                                       // 8410
                                                                                                                       // 8411
/* ===========================================================================                                         // 8412
 * Initialize a new block.                                                                                             // 8413
 */                                                                                                                    // 8414
function init_block(s) {                                                                                               // 8415
  var n; /* iterates over tree elements */                                                                             // 8416
                                                                                                                       // 8417
  /* Initialize the trees. */                                                                                          // 8418
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }                                                    // 8419
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }                                                    // 8420
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }                                                      // 8421
                                                                                                                       // 8422
  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;                                                                               // 8423
  s.opt_len = s.static_len = 0;                                                                                        // 8424
  s.last_lit = s.matches = 0;                                                                                          // 8425
}                                                                                                                      // 8426
                                                                                                                       // 8427
                                                                                                                       // 8428
/* ===========================================================================                                         // 8429
 * Flush the bit buffer and align the output on a byte boundary                                                        // 8430
 */                                                                                                                    // 8431
function bi_windup(s)                                                                                                  // 8432
{                                                                                                                      // 8433
  if (s.bi_valid > 8) {                                                                                                // 8434
    put_short(s, s.bi_buf);                                                                                            // 8435
  } else if (s.bi_valid > 0) {                                                                                         // 8436
    //put_byte(s, (Byte)s->bi_buf);                                                                                    // 8437
    s.pending_buf[s.pending++] = s.bi_buf;                                                                             // 8438
  }                                                                                                                    // 8439
  s.bi_buf = 0;                                                                                                        // 8440
  s.bi_valid = 0;                                                                                                      // 8441
}                                                                                                                      // 8442
                                                                                                                       // 8443
/* ===========================================================================                                         // 8444
 * Copy a stored block, storing first the length and its                                                               // 8445
 * one's complement if requested.                                                                                      // 8446
 */                                                                                                                    // 8447
function copy_block(s, buf, len, header)                                                                               // 8448
//DeflateState *s;                                                                                                     // 8449
//charf    *buf;    /* the input data */                                                                               // 8450
//unsigned len;     /* its length */                                                                                   // 8451
//int      header;  /* true if block header must be written */                                                         // 8452
{                                                                                                                      // 8453
  bi_windup(s);        /* align on byte boundary */                                                                    // 8454
                                                                                                                       // 8455
  if (header) {                                                                                                        // 8456
    put_short(s, len);                                                                                                 // 8457
    put_short(s, ~len);                                                                                                // 8458
  }                                                                                                                    // 8459
//  while (len--) {                                                                                                    // 8460
//    put_byte(s, *buf++);                                                                                             // 8461
//  }                                                                                                                  // 8462
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);                                                        // 8463
  s.pending += len;                                                                                                    // 8464
}                                                                                                                      // 8465
                                                                                                                       // 8466
/* ===========================================================================                                         // 8467
 * Compares to subtrees, using the tree depth as tie breaker when                                                      // 8468
 * the subtrees have equal frequency. This minimizes the worst case length.                                            // 8469
 */                                                                                                                    // 8470
function smaller(tree, n, m, depth) {                                                                                  // 8471
  var _n2 = n*2;                                                                                                       // 8472
  var _m2 = m*2;                                                                                                       // 8473
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||                                                                   // 8474
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));                                         // 8475
}                                                                                                                      // 8476
                                                                                                                       // 8477
/* ===========================================================================                                         // 8478
 * Restore the heap property by moving down the tree starting at node k,                                               // 8479
 * exchanging a node with the smallest of its two sons if necessary, stopping                                          // 8480
 * when the heap property is re-established (each father smaller than its                                              // 8481
 * two sons).                                                                                                          // 8482
 */                                                                                                                    // 8483
function pqdownheap(s, tree, k)                                                                                        // 8484
//    deflate_state *s;                                                                                                // 8485
//    ct_data *tree;  /* the tree to restore */                                                                        // 8486
//    int k;               /* node to move down */                                                                     // 8487
{                                                                                                                      // 8488
  var v = s.heap[k];                                                                                                   // 8489
  var j = k << 1;  /* left son of k */                                                                                 // 8490
  while (j <= s.heap_len) {                                                                                            // 8491
    /* Set j to the smallest of the two sons: */                                                                       // 8492
    if (j < s.heap_len &&                                                                                              // 8493
      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {                                                                // 8494
      j++;                                                                                                             // 8495
    }                                                                                                                  // 8496
    /* Exit if v is smaller than both sons */                                                                          // 8497
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }                                                               // 8498
                                                                                                                       // 8499
    /* Exchange v with the smallest son */                                                                             // 8500
    s.heap[k] = s.heap[j];                                                                                             // 8501
    k = j;                                                                                                             // 8502
                                                                                                                       // 8503
    /* And continue down the tree, setting j to the left son of k */                                                   // 8504
    j <<= 1;                                                                                                           // 8505
  }                                                                                                                    // 8506
  s.heap[k] = v;                                                                                                       // 8507
}                                                                                                                      // 8508
                                                                                                                       // 8509
                                                                                                                       // 8510
// inlined manually                                                                                                    // 8511
// var SMALLEST = 1;                                                                                                   // 8512
                                                                                                                       // 8513
/* ===========================================================================                                         // 8514
 * Send the block data compressed using the given Huffman trees                                                        // 8515
 */                                                                                                                    // 8516
function compress_block(s, ltree, dtree)                                                                               // 8517
//    deflate_state *s;                                                                                                // 8518
//    const ct_data *ltree; /* literal tree */                                                                         // 8519
//    const ct_data *dtree; /* distance tree */                                                                        // 8520
{                                                                                                                      // 8521
  var dist;           /* distance of matched string */                                                                 // 8522
  var lc;             /* match length or unmatched char (if dist == 0) */                                              // 8523
  var lx = 0;         /* running index in l_buf */                                                                     // 8524
  var code;           /* the code to send */                                                                           // 8525
  var extra;          /* number of extra bits to send */                                                               // 8526
                                                                                                                       // 8527
  if (s.last_lit !== 0) {                                                                                              // 8528
    do {                                                                                                               // 8529
      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);                               // 8530
      lc = s.pending_buf[s.l_buf + lx];                                                                                // 8531
      lx++;                                                                                                            // 8532
                                                                                                                       // 8533
      if (dist === 0) {                                                                                                // 8534
        send_code(s, lc, ltree); /* send a literal byte */                                                             // 8535
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));                                                                 // 8536
      } else {                                                                                                         // 8537
        /* Here, lc is the match length - MIN_MATCH */                                                                 // 8538
        code = _length_code[lc];                                                                                       // 8539
        send_code(s, code+LITERALS+1, ltree); /* send the length code */                                               // 8540
        extra = extra_lbits[code];                                                                                     // 8541
        if (extra !== 0) {                                                                                             // 8542
          lc -= base_length[code];                                                                                     // 8543
          send_bits(s, lc, extra);       /* send the extra length bits */                                              // 8544
        }                                                                                                              // 8545
        dist--; /* dist is now the match distance - 1 */                                                               // 8546
        code = d_code(dist);                                                                                           // 8547
        //Assert (code < D_CODES, "bad d_code");                                                                       // 8548
                                                                                                                       // 8549
        send_code(s, code, dtree);       /* send the distance code */                                                  // 8550
        extra = extra_dbits[code];                                                                                     // 8551
        if (extra !== 0) {                                                                                             // 8552
          dist -= base_dist[code];                                                                                     // 8553
          send_bits(s, dist, extra);   /* send the extra distance bits */                                              // 8554
        }                                                                                                              // 8555
      } /* literal or match pair ? */                                                                                  // 8556
                                                                                                                       // 8557
      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */                                          // 8558
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,                                                             // 8559
      //       "pendingBuf overflow");                                                                                 // 8560
                                                                                                                       // 8561
    } while (lx < s.last_lit);                                                                                         // 8562
  }                                                                                                                    // 8563
                                                                                                                       // 8564
  send_code(s, END_BLOCK, ltree);                                                                                      // 8565
}                                                                                                                      // 8566
                                                                                                                       // 8567
                                                                                                                       // 8568
/* ===========================================================================                                         // 8569
 * Construct one Huffman tree and assigns the code bit strings and lengths.                                            // 8570
 * Update the total bit length for the current block.                                                                  // 8571
 * IN assertion: the field freq is set for all tree elements.                                                          // 8572
 * OUT assertions: the fields len and code are set to the optimal bit length                                           // 8573
 *     and corresponding code. The length opt_len is updated; static_len is                                            // 8574
 *     also updated if stree is not null. The field max_code is set.                                                   // 8575
 */                                                                                                                    // 8576
function build_tree(s, desc)                                                                                           // 8577
//    deflate_state *s;                                                                                                // 8578
//    tree_desc *desc; /* the tree descriptor */                                                                       // 8579
{                                                                                                                      // 8580
  var tree     = desc.dyn_tree;                                                                                        // 8581
  var stree    = desc.stat_desc.static_tree;                                                                           // 8582
  var has_stree = desc.stat_desc.has_stree;                                                                            // 8583
  var elems    = desc.stat_desc.elems;                                                                                 // 8584
  var n, m;          /* iterate over heap elements */                                                                  // 8585
  var max_code = -1; /* largest code with non zero frequency */                                                        // 8586
  var node;          /* new node being created */                                                                      // 8587
                                                                                                                       // 8588
  /* Construct the initial heap, with least frequent element in                                                        // 8589
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].                                                // 8590
   * heap[0] is not used.                                                                                              // 8591
   */                                                                                                                  // 8592
  s.heap_len = 0;                                                                                                      // 8593
  s.heap_max = HEAP_SIZE;                                                                                              // 8594
                                                                                                                       // 8595
  for (n = 0; n < elems; n++) {                                                                                        // 8596
    if (tree[n * 2]/*.Freq*/ !== 0) {                                                                                  // 8597
      s.heap[++s.heap_len] = max_code = n;                                                                             // 8598
      s.depth[n] = 0;                                                                                                  // 8599
                                                                                                                       // 8600
    } else {                                                                                                           // 8601
      tree[n*2 + 1]/*.Len*/ = 0;                                                                                       // 8602
    }                                                                                                                  // 8603
  }                                                                                                                    // 8604
                                                                                                                       // 8605
  /* The pkzip format requires that at least one distance code exists,                                                 // 8606
   * and that at least one bit should be sent even if there is only one                                                // 8607
   * possible code. So to avoid special checks later on we force at least                                              // 8608
   * two codes of non zero frequency.                                                                                  // 8609
   */                                                                                                                  // 8610
  while (s.heap_len < 2) {                                                                                             // 8611
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);                                                     // 8612
    tree[node * 2]/*.Freq*/ = 1;                                                                                       // 8613
    s.depth[node] = 0;                                                                                                 // 8614
    s.opt_len--;                                                                                                       // 8615
                                                                                                                       // 8616
    if (has_stree) {                                                                                                   // 8617
      s.static_len -= stree[node*2 + 1]/*.Len*/;                                                                       // 8618
    }                                                                                                                  // 8619
    /* node is 0 or 1 so it does not have extra bits */                                                                // 8620
  }                                                                                                                    // 8621
  desc.max_code = max_code;                                                                                            // 8622
                                                                                                                       // 8623
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,                                               // 8624
   * establish sub-heaps of increasing lengths:                                                                        // 8625
   */                                                                                                                  // 8626
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }                                       // 8627
                                                                                                                       // 8628
  /* Construct the Huffman tree by repeatedly combining the least two                                                  // 8629
   * frequent nodes.                                                                                                   // 8630
   */                                                                                                                  // 8631
  node = elems;              /* next internal node of the tree */                                                      // 8632
  do {                                                                                                                 // 8633
    //pqremove(s, tree, n);  /* n = node of least frequency */                                                         // 8634
    /*** pqremove ***/                                                                                                 // 8635
    n = s.heap[1/*SMALLEST*/];                                                                                         // 8636
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];                                                                      // 8637
    pqdownheap(s, tree, 1/*SMALLEST*/);                                                                                // 8638
    /***/                                                                                                              // 8639
                                                                                                                       // 8640
    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */                                                  // 8641
                                                                                                                       // 8642
    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */                                                 // 8643
    s.heap[--s.heap_max] = m;                                                                                          // 8644
                                                                                                                       // 8645
    /* Create a new node father of n and m */                                                                          // 8646
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;                                             // 8647
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;                                          // 8648
    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;                                                              // 8649
                                                                                                                       // 8650
    /* and insert the new node in the heap */                                                                          // 8651
    s.heap[1/*SMALLEST*/] = node++;                                                                                    // 8652
    pqdownheap(s, tree, 1/*SMALLEST*/);                                                                                // 8653
                                                                                                                       // 8654
  } while (s.heap_len >= 2);                                                                                           // 8655
                                                                                                                       // 8656
  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];                                                                        // 8657
                                                                                                                       // 8658
  /* At this point, the fields freq and dad are set. We can now                                                        // 8659
   * generate the bit lengths.                                                                                         // 8660
   */                                                                                                                  // 8661
  gen_bitlen(s, desc);                                                                                                 // 8662
                                                                                                                       // 8663
  /* The field len is now set, we can generate the bit codes */                                                        // 8664
  gen_codes(tree, max_code, s.bl_count);                                                                               // 8665
}                                                                                                                      // 8666
                                                                                                                       // 8667
                                                                                                                       // 8668
/* ===========================================================================                                         // 8669
 * Scan a literal or distance tree to determine the frequencies of the codes                                           // 8670
 * in the bit length tree.                                                                                             // 8671
 */                                                                                                                    // 8672
function scan_tree(s, tree, max_code)                                                                                  // 8673
//    deflate_state *s;                                                                                                // 8674
//    ct_data *tree;   /* the tree to be scanned */                                                                    // 8675
//    int max_code;    /* and its largest code of non zero frequency */                                                // 8676
{                                                                                                                      // 8677
  var n;                     /* iterates over all tree elements */                                                     // 8678
  var prevlen = -1;          /* last emitted length */                                                                 // 8679
  var curlen;                /* length of current code */                                                              // 8680
                                                                                                                       // 8681
  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */                                                       // 8682
                                                                                                                       // 8683
  var count = 0;             /* repeat count of the current code */                                                    // 8684
  var max_count = 7;         /* max repeat count */                                                                    // 8685
  var min_count = 4;         /* min repeat count */                                                                    // 8686
                                                                                                                       // 8687
  if (nextlen === 0) {                                                                                                 // 8688
    max_count = 138;                                                                                                   // 8689
    min_count = 3;                                                                                                     // 8690
  }                                                                                                                    // 8691
  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */                                                               // 8692
                                                                                                                       // 8693
  for (n = 0; n <= max_code; n++) {                                                                                    // 8694
    curlen = nextlen;                                                                                                  // 8695
    nextlen = tree[(n+1)*2 + 1]/*.Len*/;                                                                               // 8696
                                                                                                                       // 8697
    if (++count < max_count && curlen === nextlen) {                                                                   // 8698
      continue;                                                                                                        // 8699
                                                                                                                       // 8700
    } else if (count < min_count) {                                                                                    // 8701
      s.bl_tree[curlen * 2]/*.Freq*/ += count;                                                                         // 8702
                                                                                                                       // 8703
    } else if (curlen !== 0) {                                                                                         // 8704
                                                                                                                       // 8705
      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }                                                    // 8706
      s.bl_tree[REP_3_6*2]/*.Freq*/++;                                                                                 // 8707
                                                                                                                       // 8708
    } else if (count <= 10) {                                                                                          // 8709
      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;                                                                               // 8710
                                                                                                                       // 8711
    } else {                                                                                                           // 8712
      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;                                                                             // 8713
    }                                                                                                                  // 8714
                                                                                                                       // 8715
    count = 0;                                                                                                         // 8716
    prevlen = curlen;                                                                                                  // 8717
                                                                                                                       // 8718
    if (nextlen === 0) {                                                                                               // 8719
      max_count = 138;                                                                                                 // 8720
      min_count = 3;                                                                                                   // 8721
                                                                                                                       // 8722
    } else if (curlen === nextlen) {                                                                                   // 8723
      max_count = 6;                                                                                                   // 8724
      min_count = 3;                                                                                                   // 8725
                                                                                                                       // 8726
    } else {                                                                                                           // 8727
      max_count = 7;                                                                                                   // 8728
      min_count = 4;                                                                                                   // 8729
    }                                                                                                                  // 8730
  }                                                                                                                    // 8731
}                                                                                                                      // 8732
                                                                                                                       // 8733
                                                                                                                       // 8734
/* ===========================================================================                                         // 8735
 * Send a literal or distance tree in compressed form, using the codes in                                              // 8736
 * bl_tree.                                                                                                            // 8737
 */                                                                                                                    // 8738
function send_tree(s, tree, max_code)                                                                                  // 8739
//    deflate_state *s;                                                                                                // 8740
//    ct_data *tree; /* the tree to be scanned */                                                                      // 8741
//    int max_code;       /* and its largest code of non zero frequency */                                             // 8742
{                                                                                                                      // 8743
  var n;                     /* iterates over all tree elements */                                                     // 8744
  var prevlen = -1;          /* last emitted length */                                                                 // 8745
  var curlen;                /* length of current code */                                                              // 8746
                                                                                                                       // 8747
  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */                                                       // 8748
                                                                                                                       // 8749
  var count = 0;             /* repeat count of the current code */                                                    // 8750
  var max_count = 7;         /* max repeat count */                                                                    // 8751
  var min_count = 4;         /* min repeat count */                                                                    // 8752
                                                                                                                       // 8753
  /* tree[max_code+1].Len = -1; */  /* guard already set */                                                            // 8754
  if (nextlen === 0) {                                                                                                 // 8755
    max_count = 138;                                                                                                   // 8756
    min_count = 3;                                                                                                     // 8757
  }                                                                                                                    // 8758
                                                                                                                       // 8759
  for (n = 0; n <= max_code; n++) {                                                                                    // 8760
    curlen = nextlen;                                                                                                  // 8761
    nextlen = tree[(n+1)*2 + 1]/*.Len*/;                                                                               // 8762
                                                                                                                       // 8763
    if (++count < max_count && curlen === nextlen) {                                                                   // 8764
      continue;                                                                                                        // 8765
                                                                                                                       // 8766
    } else if (count < min_count) {                                                                                    // 8767
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);                                                   // 8768
                                                                                                                       // 8769
    } else if (curlen !== 0) {                                                                                         // 8770
      if (curlen !== prevlen) {                                                                                        // 8771
        send_code(s, curlen, s.bl_tree);                                                                               // 8772
        count--;                                                                                                       // 8773
      }                                                                                                                // 8774
      //Assert(count >= 3 && count <= 6, " 3_6?");                                                                     // 8775
      send_code(s, REP_3_6, s.bl_tree);                                                                                // 8776
      send_bits(s, count-3, 2);                                                                                        // 8777
                                                                                                                       // 8778
    } else if (count <= 10) {                                                                                          // 8779
      send_code(s, REPZ_3_10, s.bl_tree);                                                                              // 8780
      send_bits(s, count-3, 3);                                                                                        // 8781
                                                                                                                       // 8782
    } else {                                                                                                           // 8783
      send_code(s, REPZ_11_138, s.bl_tree);                                                                            // 8784
      send_bits(s, count-11, 7);                                                                                       // 8785
    }                                                                                                                  // 8786
                                                                                                                       // 8787
    count = 0;                                                                                                         // 8788
    prevlen = curlen;                                                                                                  // 8789
    if (nextlen === 0) {                                                                                               // 8790
      max_count = 138;                                                                                                 // 8791
      min_count = 3;                                                                                                   // 8792
                                                                                                                       // 8793
    } else if (curlen === nextlen) {                                                                                   // 8794
      max_count = 6;                                                                                                   // 8795
      min_count = 3;                                                                                                   // 8796
                                                                                                                       // 8797
    } else {                                                                                                           // 8798
      max_count = 7;                                                                                                   // 8799
      min_count = 4;                                                                                                   // 8800
    }                                                                                                                  // 8801
  }                                                                                                                    // 8802
}                                                                                                                      // 8803
                                                                                                                       // 8804
                                                                                                                       // 8805
/* ===========================================================================                                         // 8806
 * Construct the Huffman tree for the bit lengths and return the index in                                              // 8807
 * bl_order of the last bit length code to send.                                                                       // 8808
 */                                                                                                                    // 8809
function build_bl_tree(s) {                                                                                            // 8810
  var max_blindex;  /* index of last bit length code of non zero freq */                                               // 8811
                                                                                                                       // 8812
  /* Determine the bit length frequencies for literal and distance trees */                                            // 8813
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);                                                                        // 8814
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);                                                                        // 8815
                                                                                                                       // 8816
  /* Build the bit length tree: */                                                                                     // 8817
  build_tree(s, s.bl_desc);                                                                                            // 8818
  /* opt_len now includes the length of the tree representations, except                                               // 8819
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.                                           // 8820
   */                                                                                                                  // 8821
                                                                                                                       // 8822
  /* Determine the number of bit length codes to send. The pkzip format                                                // 8823
   * requires that at least 4 bit length codes be sent. (appnote.txt says                                              // 8824
   * 3 but the actual value used is 4.)                                                                                // 8825
   */                                                                                                                  // 8826
  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {                                                    // 8827
    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {                                                        // 8828
      break;                                                                                                           // 8829
    }                                                                                                                  // 8830
  }                                                                                                                    // 8831
  /* Update opt_len to include the bit length tree and counts */                                                       // 8832
  s.opt_len += 3*(max_blindex+1) + 5+5+4;                                                                              // 8833
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",                                                                  // 8834
  //        s->opt_len, s->static_len));                                                                               // 8835
                                                                                                                       // 8836
  return max_blindex;                                                                                                  // 8837
}                                                                                                                      // 8838
                                                                                                                       // 8839
                                                                                                                       // 8840
/* ===========================================================================                                         // 8841
 * Send the header for a block using dynamic Huffman trees: the counts, the                                            // 8842
 * lengths of the bit length codes, the literal tree and the distance tree.                                            // 8843
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.                                                             // 8844
 */                                                                                                                    // 8845
function send_all_trees(s, lcodes, dcodes, blcodes)                                                                    // 8846
//    deflate_state *s;                                                                                                // 8847
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */                                                 // 8848
{                                                                                                                      // 8849
  var rank;                    /* index in bl_order */                                                                 // 8850
                                                                                                                       // 8851
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");                                         // 8852
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,                                             // 8853
  //        "too many codes");                                                                                         // 8854
  //Tracev((stderr, "\nbl counts: "));                                                                                 // 8855
  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */                                                 // 8856
  send_bits(s, dcodes-1,   5);                                                                                         // 8857
  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */                                                   // 8858
  for (rank = 0; rank < blcodes; rank++) {                                                                             // 8859
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));                                                              // 8860
    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);                                                          // 8861
  }                                                                                                                    // 8862
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));                                                             // 8863
                                                                                                                       // 8864
  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */                                                              // 8865
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));                                                            // 8866
                                                                                                                       // 8867
  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */                                                             // 8868
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));                                                           // 8869
}                                                                                                                      // 8870
                                                                                                                       // 8871
                                                                                                                       // 8872
/* ===========================================================================                                         // 8873
 * Check if the data type is TEXT or BINARY, using the following algorithm:                                            // 8874
 * - TEXT if the two conditions below are satisfied:                                                                   // 8875
 *    a) There are no non-portable control characters belonging to the                                                 // 8876
 *       "black list" (0..6, 14..25, 28..31).                                                                          // 8877
 *    b) There is at least one printable character belonging to the                                                    // 8878
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).                                                            // 8879
 * - BINARY otherwise.                                                                                                 // 8880
 * - The following partially-portable control characters form a                                                        // 8881
 *   "gray list" that is ignored in this detection algorithm:                                                          // 8882
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).                                                          // 8883
 * IN assertion: the fields Freq of dyn_ltree are set.                                                                 // 8884
 */                                                                                                                    // 8885
function detect_data_type(s) {                                                                                         // 8886
  /* black_mask is the bit mask of black-listed bytes                                                                  // 8887
   * set bits 0..6, 14..25, and 28..31                                                                                 // 8888
   * 0xf3ffc07f = binary 11110011111111111100000001111111                                                              // 8889
   */                                                                                                                  // 8890
  var black_mask = 0xf3ffc07f;                                                                                         // 8891
  var n;                                                                                                               // 8892
                                                                                                                       // 8893
  /* Check for non-textual ("black-listed") bytes. */                                                                  // 8894
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {                                                                       // 8895
    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {                                                       // 8896
      return Z_BINARY;                                                                                                 // 8897
    }                                                                                                                  // 8898
  }                                                                                                                    // 8899
                                                                                                                       // 8900
  /* Check for textual ("white-listed") bytes. */                                                                      // 8901
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||                                       // 8902
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {                                                                            // 8903
    return Z_TEXT;                                                                                                     // 8904
  }                                                                                                                    // 8905
  for (n = 32; n < LITERALS; n++) {                                                                                    // 8906
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {                                                                           // 8907
      return Z_TEXT;                                                                                                   // 8908
    }                                                                                                                  // 8909
  }                                                                                                                    // 8910
                                                                                                                       // 8911
  /* There are no "black-listed" or "white-listed" bytes:                                                              // 8912
   * this stream either is empty or has tolerated ("gray-listed") bytes only.                                          // 8913
   */                                                                                                                  // 8914
  return Z_BINARY;                                                                                                     // 8915
}                                                                                                                      // 8916
                                                                                                                       // 8917
                                                                                                                       // 8918
var static_init_done = false;                                                                                          // 8919
                                                                                                                       // 8920
/* ===========================================================================                                         // 8921
 * Initialize the tree data structures for a new zlib stream.                                                          // 8922
 */                                                                                                                    // 8923
function _tr_init(s)                                                                                                   // 8924
{                                                                                                                      // 8925
                                                                                                                       // 8926
  if (!static_init_done) {                                                                                             // 8927
    tr_static_init();                                                                                                  // 8928
    static_init_done = true;                                                                                           // 8929
  }                                                                                                                    // 8930
                                                                                                                       // 8931
  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);                                                                // 8932
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);                                                                // 8933
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);                                                                 // 8934
                                                                                                                       // 8935
  s.bi_buf = 0;                                                                                                        // 8936
  s.bi_valid = 0;                                                                                                      // 8937
                                                                                                                       // 8938
  /* Initialize the first block of the first file: */                                                                  // 8939
  init_block(s);                                                                                                       // 8940
}                                                                                                                      // 8941
                                                                                                                       // 8942
                                                                                                                       // 8943
/* ===========================================================================                                         // 8944
 * Send a stored block                                                                                                 // 8945
 */                                                                                                                    // 8946
function _tr_stored_block(s, buf, stored_len, last)                                                                    // 8947
//DeflateState *s;                                                                                                     // 8948
//charf *buf;       /* input block */                                                                                  // 8949
//ulg stored_len;   /* length of input block */                                                                        // 8950
//int last;         /* one if this is the last block for a file */                                                     // 8951
{                                                                                                                      // 8952
  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */                                          // 8953
  copy_block(s, buf, stored_len, true); /* with header */                                                              // 8954
}                                                                                                                      // 8955
                                                                                                                       // 8956
                                                                                                                       // 8957
/* ===========================================================================                                         // 8958
 * Send one empty static block to give enough lookahead for inflate.                                                   // 8959
 * This takes 10 bits, of which 7 may remain in the bit buffer.                                                        // 8960
 */                                                                                                                    // 8961
function _tr_align(s) {                                                                                                // 8962
  send_bits(s, STATIC_TREES<<1, 3);                                                                                    // 8963
  send_code(s, END_BLOCK, static_ltree);                                                                               // 8964
  bi_flush(s);                                                                                                         // 8965
}                                                                                                                      // 8966
                                                                                                                       // 8967
                                                                                                                       // 8968
/* ===========================================================================                                         // 8969
 * Determine the best encoding for the current block: dynamic trees, static                                            // 8970
 * trees or store, and output the encoded block to the zip file.                                                       // 8971
 */                                                                                                                    // 8972
function _tr_flush_block(s, buf, stored_len, last)                                                                     // 8973
//DeflateState *s;                                                                                                     // 8974
//charf *buf;       /* input block, or NULL if too old */                                                              // 8975
//ulg stored_len;   /* length of input block */                                                                        // 8976
//int last;         /* one if this is the last block for a file */                                                     // 8977
{                                                                                                                      // 8978
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */                                                    // 8979
  var max_blindex = 0;        /* index of last bit length code of non zero freq */                                     // 8980
                                                                                                                       // 8981
  /* Build the Huffman trees unless a stored block is forced */                                                        // 8982
  if (s.level > 0) {                                                                                                   // 8983
                                                                                                                       // 8984
    /* Check if the file is binary or text */                                                                          // 8985
    if (s.strm.data_type === Z_UNKNOWN) {                                                                              // 8986
      s.strm.data_type = detect_data_type(s);                                                                          // 8987
    }                                                                                                                  // 8988
                                                                                                                       // 8989
    /* Construct the literal and distance trees */                                                                     // 8990
    build_tree(s, s.l_desc);                                                                                           // 8991
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,                                                    // 8992
    //        s->static_len));                                                                                         // 8993
                                                                                                                       // 8994
    build_tree(s, s.d_desc);                                                                                           // 8995
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,                                                   // 8996
    //        s->static_len));                                                                                         // 8997
    /* At this point, opt_len and static_len are the total bit lengths of                                              // 8998
     * the compressed block data, excluding the tree representations.                                                  // 8999
     */                                                                                                                // 9000
                                                                                                                       // 9001
    /* Build the bit length tree for the above two trees, and get the index                                            // 9002
     * in bl_order of the last bit length code to send.                                                                // 9003
     */                                                                                                                // 9004
    max_blindex = build_bl_tree(s);                                                                                    // 9005
                                                                                                                       // 9006
    /* Determine the best encoding. Compute the block lengths in bytes. */                                             // 9007
    opt_lenb = (s.opt_len+3+7) >>> 3;                                                                                  // 9008
    static_lenb = (s.static_len+3+7) >>> 3;                                                                            // 9009
                                                                                                                       // 9010
    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",                                              // 9011
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,                                            // 9012
    //        s->last_lit));                                                                                           // 9013
                                                                                                                       // 9014
    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }                                                           // 9015
                                                                                                                       // 9016
  } else {                                                                                                             // 9017
    // Assert(buf != (char*)0, "lost buf");                                                                            // 9018
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */                                                // 9019
  }                                                                                                                    // 9020
                                                                                                                       // 9021
  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {                                                                    // 9022
    /* 4: two words for the lengths */                                                                                 // 9023
                                                                                                                       // 9024
    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.                                                  // 9025
     * Otherwise we can't have processed more than WSIZE input bytes since                                             // 9026
     * the last block flush, because compression would have been                                                       // 9027
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to                                                    // 9028
     * transform a block into a stored block.                                                                          // 9029
     */                                                                                                                // 9030
    _tr_stored_block(s, buf, stored_len, last);                                                                        // 9031
                                                                                                                       // 9032
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {                                                     // 9033
                                                                                                                       // 9034
    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);                                                               // 9035
    compress_block(s, static_ltree, static_dtree);                                                                     // 9036
                                                                                                                       // 9037
  } else {                                                                                                             // 9038
    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);                                                                  // 9039
    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);                                        // 9040
    compress_block(s, s.dyn_ltree, s.dyn_dtree);                                                                       // 9041
  }                                                                                                                    // 9042
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");                                                // 9043
  /* The above check is made mod 2^32, for files larger than 512 MB                                                    // 9044
   * and uLong implemented on 32 bits.                                                                                 // 9045
   */                                                                                                                  // 9046
  init_block(s);                                                                                                       // 9047
                                                                                                                       // 9048
  if (last) {                                                                                                          // 9049
    bi_windup(s);                                                                                                      // 9050
  }                                                                                                                    // 9051
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,                                                      // 9052
  //       s->compressed_len-7*last));                                                                                 // 9053
}                                                                                                                      // 9054
                                                                                                                       // 9055
/* ===========================================================================                                         // 9056
 * Save the match info and tally the frequency counts. Return true if                                                  // 9057
 * the current block must be flushed.                                                                                  // 9058
 */                                                                                                                    // 9059
function _tr_tally(s, dist, lc)                                                                                        // 9060
//    deflate_state *s;                                                                                                // 9061
//    unsigned dist;  /* distance of matched string */                                                                 // 9062
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */                                      // 9063
{                                                                                                                      // 9064
  //var out_length, in_length, dcode;                                                                                  // 9065
                                                                                                                       // 9066
  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;                                                   // 9067
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;                                                           // 9068
                                                                                                                       // 9069
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;                                                                     // 9070
  s.last_lit++;                                                                                                        // 9071
                                                                                                                       // 9072
  if (dist === 0) {                                                                                                    // 9073
    /* lc is the unmatched char */                                                                                     // 9074
    s.dyn_ltree[lc*2]/*.Freq*/++;                                                                                      // 9075
  } else {                                                                                                             // 9076
    s.matches++;                                                                                                       // 9077
    /* Here, lc is the match length - MIN_MATCH */                                                                     // 9078
    dist--;             /* dist = match distance - 1 */                                                                // 9079
    //Assert((ush)dist < (ush)MAX_DIST(s) &&                                                                           // 9080
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&                                                                  // 9081
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");                                               // 9082
                                                                                                                       // 9083
    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;                                                         // 9084
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;                                                                          // 9085
  }                                                                                                                    // 9086
                                                                                                                       // 9087
// (!) This block is disabled in zlib defailts,                                                                        // 9088
// don't enable it for binary compatibility                                                                            // 9089
                                                                                                                       // 9090
//#ifdef TRUNCATE_BLOCK                                                                                                // 9091
//  /* Try to guess if it is profitable to stop the current block here */                                              // 9092
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {                                                                  // 9093
//    /* Compute an upper bound for the compressed length */                                                           // 9094
//    out_length = s.last_lit*8;                                                                                       // 9095
//    in_length = s.strstart - s.block_start;                                                                          // 9096
//                                                                                                                     // 9097
//    for (dcode = 0; dcode < D_CODES; dcode++) {                                                                      // 9098
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);                                        // 9099
//    }                                                                                                                // 9100
//    out_length >>>= 3;                                                                                               // 9101
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",                                                      // 9102
//    //       s->last_lit, in_length, out_length,                                                                     // 9103
//    //       100L - out_length*100L/in_length));                                                                     // 9104
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {                            // 9105
//      return true;                                                                                                   // 9106
//    }                                                                                                                // 9107
//  }                                                                                                                  // 9108
//#endif                                                                                                               // 9109
                                                                                                                       // 9110
  return (s.last_lit === s.lit_bufsize-1);                                                                             // 9111
  /* We avoid equality with lit_bufsize because of wraparound at 64K                                                   // 9112
   * on 16 bit machines and because stored blocks are restricted to                                                    // 9113
   * 64K-1 bytes.                                                                                                      // 9114
   */                                                                                                                  // 9115
}                                                                                                                      // 9116
                                                                                                                       // 9117
exports._tr_init  = _tr_init;                                                                                          // 9118
exports._tr_stored_block = _tr_stored_block;                                                                           // 9119
exports._tr_flush_block  = _tr_flush_block;                                                                            // 9120
exports._tr_tally = _tr_tally;                                                                                         // 9121
exports._tr_align = _tr_align;                                                                                         // 9122
},{"../utils/common":27}],39:[function(_dereq_,module,exports){                                                        // 9123
'use strict';                                                                                                          // 9124
                                                                                                                       // 9125
                                                                                                                       // 9126
function ZStream() {                                                                                                   // 9127
  /* next input byte */                                                                                                // 9128
  this.input = null; // JS specific, because we have no pointers                                                       // 9129
  this.next_in = 0;                                                                                                    // 9130
  /* number of bytes available at input */                                                                             // 9131
  this.avail_in = 0;                                                                                                   // 9132
  /* total number of input bytes read so far */                                                                        // 9133
  this.total_in = 0;                                                                                                   // 9134
  /* next output byte should be put there */                                                                           // 9135
  this.output = null; // JS specific, because we have no pointers                                                      // 9136
  this.next_out = 0;                                                                                                   // 9137
  /* remaining free space at output */                                                                                 // 9138
  this.avail_out = 0;                                                                                                  // 9139
  /* total number of bytes output so far */                                                                            // 9140
  this.total_out = 0;                                                                                                  // 9141
  /* last error message, NULL if no error */                                                                           // 9142
  this.msg = ''/*Z_NULL*/;                                                                                             // 9143
  /* not visible by applications */                                                                                    // 9144
  this.state = null;                                                                                                   // 9145
  /* best guess about the data type: binary or text */                                                                 // 9146
  this.data_type = 2/*Z_UNKNOWN*/;                                                                                     // 9147
  /* adler32 value of the uncompressed data */                                                                         // 9148
  this.adler = 0;                                                                                                      // 9149
}                                                                                                                      // 9150
                                                                                                                       // 9151
module.exports = ZStream;                                                                                              // 9152
},{}]},{},[9])                                                                                                         // 9153
(9)                                                                                                                    // 9154
});                                                                                                                    // 9155
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/silentcicero:jszip/lib/saveas.js                                                                           //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/* FileSaver.js                                                                                                        // 1
 * A saveAs() FileSaver implementation.                                                                                // 2
 * 2015-05-07.2                                                                                                        // 3
 *                                                                                                                     // 4
 * By Eli Grey, http://eligrey.com                                                                                     // 5
 * License: X11/MIT                                                                                                    // 6
 *   See https://github.com/eligrey/FileSaver.js/blob/master/LICENSE.md                                                // 7
 */                                                                                                                    // 8
                                                                                                                       // 9
/*global self */                                                                                                       // 10
/*jslint bitwise: true, indent: 4, laxbreak: true, laxcomma: true, smarttabs: true, plusplus: true */                  // 11
                                                                                                                       // 12
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */                                    // 13
                                                                                                                       // 14
var saveAs = saveAs = window.saveAs || (function(view) {                                                               // 15
	"use strict";                                                                                                         // 16
	// IE <10 is explicitly unsupported                                                                                   // 17
	if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {                                   // 18
		return;                                                                                                              // 19
	}                                                                                                                     // 20
	var                                                                                                                   // 21
		  doc = view.document                                                                                                // 22
		  // only get URL when necessary in case Blob.js hasn't overridden it yet                                            // 23
		, get_URL = function() {                                                                                             // 24
			return view.URL || view.webkitURL || view;                                                                          // 25
		}                                                                                                                    // 26
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")                                               // 27
		, can_use_save_link = "download" in save_link                                                                        // 28
		, click = function(node) {                                                                                           // 29
			var event = doc.createEvent("MouseEvents");                                                                         // 30
			event.initMouseEvent(                                                                                               // 31
				"click", true, false, view, 0, 0, 0, 0, 0                                                                          // 32
				, false, false, false, false, 0, null                                                                              // 33
			);                                                                                                                  // 34
			node.dispatchEvent(event);                                                                                          // 35
		}                                                                                                                    // 36
		, webkit_req_fs = view.webkitRequestFileSystem                                                                       // 37
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem                                      // 38
		, throw_outside = function(ex) {                                                                                     // 39
			(view.setImmediate || view.setTimeout)(function() {                                                                 // 40
				throw ex;                                                                                                          // 41
			}, 0);                                                                                                              // 42
		}                                                                                                                    // 43
		, force_saveable_type = "application/octet-stream"                                                                   // 44
		, fs_min_size = 0                                                                                                    // 45
		// See https://code.google.com/p/chromium/issues/detail?id=375297#c7 and                                             // 46
		// https://github.com/eligrey/FileSaver.js/commit/485930a#commitcomment-8768047                                      // 47
		// for the reasoning behind the timeout and revocation flow                                                          // 48
		, arbitrary_revoke_timeout = 500 // in ms                                                                            // 49
		, revoke = function(file) {                                                                                          // 50
			var revoker = function() {                                                                                          // 51
				if (typeof file === "string") { // file is an object URL                                                           // 52
					get_URL().revokeObjectURL(file);                                                                                  // 53
				} else { // file is a File                                                                                         // 54
					file.remove();                                                                                                    // 55
				}                                                                                                                  // 56
			};                                                                                                                  // 57
			if (view.chrome) {                                                                                                  // 58
				revoker();                                                                                                         // 59
			} else {                                                                                                            // 60
				setTimeout(revoker, arbitrary_revoke_timeout);                                                                     // 61
			}                                                                                                                   // 62
		}                                                                                                                    // 63
		, dispatch = function(filesaver, event_types, event) {                                                               // 64
			event_types = [].concat(event_types);                                                                               // 65
			var i = event_types.length;                                                                                         // 66
			while (i--) {                                                                                                       // 67
				var listener = filesaver["on" + event_types[i]];                                                                   // 68
				if (typeof listener === "function") {                                                                              // 69
					try {                                                                                                             // 70
						listener.call(filesaver, event || filesaver);                                                                    // 71
					} catch (ex) {                                                                                                    // 72
						throw_outside(ex);                                                                                               // 73
					}                                                                                                                 // 74
				}                                                                                                                  // 75
			}                                                                                                                   // 76
		}                                                                                                                    // 77
		, auto_bom = function(blob) {                                                                                        // 78
			// prepend BOM for UTF-8 XML and text/* types (including HTML)                                                      // 79
			if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {                 // 80
				return new Blob(["\ufeff", blob], {type: blob.type});                                                              // 81
			}                                                                                                                   // 82
			return blob;                                                                                                        // 83
		}                                                                                                                    // 84
		, FileSaver = function(blob, name) {                                                                                 // 85
			blob = auto_bom(blob);                                                                                              // 86
			// First try a.download, then web filesystem, then object URLs                                                      // 87
			var                                                                                                                 // 88
				  filesaver = this                                                                                                 // 89
				, type = blob.type                                                                                                 // 90
				, blob_changed = false                                                                                             // 91
				, object_url                                                                                                       // 92
				, target_view                                                                                                      // 93
				, dispatch_all = function() {                                                                                      // 94
					dispatch(filesaver, "writestart progress write writeend".split(" "));                                             // 95
				}                                                                                                                  // 96
				// on any filesys errors revert to saving with object URLs                                                         // 97
				, fs_error = function() {                                                                                          // 98
					// don't create more object URLs than needed                                                                      // 99
					if (blob_changed || !object_url) {                                                                                // 100
						object_url = get_URL().createObjectURL(blob);                                                                    // 101
					}                                                                                                                 // 102
					if (target_view) {                                                                                                // 103
						target_view.location.href = object_url;                                                                          // 104
					} else {                                                                                                          // 105
						var new_tab = view.open(object_url, "_blank");                                                                   // 106
						if (new_tab == undefined && typeof safari !== "undefined") {                                                     // 107
							//Apple do not allow window.open, see http://bit.ly/1kZffRI                                                     // 108
							view.location.href = object_url                                                                                 // 109
						}                                                                                                                // 110
					}                                                                                                                 // 111
					filesaver.readyState = filesaver.DONE;                                                                            // 112
					dispatch_all();                                                                                                   // 113
					revoke(object_url);                                                                                               // 114
				}                                                                                                                  // 115
				, abortable = function(func) {                                                                                     // 116
					return function() {                                                                                               // 117
						if (filesaver.readyState !== filesaver.DONE) {                                                                   // 118
							return func.apply(this, arguments);                                                                             // 119
						}                                                                                                                // 120
					};                                                                                                                // 121
				}                                                                                                                  // 122
				, create_if_not_found = {create: true, exclusive: false}                                                           // 123
				, slice                                                                                                            // 124
			;                                                                                                                   // 125
			filesaver.readyState = filesaver.INIT;                                                                              // 126
			if (!name) {                                                                                                        // 127
				name = "download";                                                                                                 // 128
			}                                                                                                                   // 129
			if (can_use_save_link) {                                                                                            // 130
				object_url = get_URL().createObjectURL(blob);                                                                      // 131
				save_link.href = object_url;                                                                                       // 132
				save_link.download = name;                                                                                         // 133
				click(save_link);                                                                                                  // 134
				filesaver.readyState = filesaver.DONE;                                                                             // 135
				dispatch_all();                                                                                                    // 136
				revoke(object_url);                                                                                                // 137
				return;                                                                                                            // 138
			}                                                                                                                   // 139
			// Object and web filesystem URLs have a problem saving in Google Chrome when                                       // 140
			// viewed in a tab, so I force save with application/octet-stream                                                   // 141
			// http://code.google.com/p/chromium/issues/detail?id=91158                                                         // 142
			// Update: Google errantly closed 91158, I submitted it again:                                                      // 143
			// https://code.google.com/p/chromium/issues/detail?id=389642                                                       // 144
			if (view.chrome && type && type !== force_saveable_type) {                                                          // 145
				slice = blob.slice || blob.webkitSlice;                                                                            // 146
				blob = slice.call(blob, 0, blob.size, force_saveable_type);                                                        // 147
				blob_changed = true;                                                                                               // 148
			}                                                                                                                   // 149
			// Since I can't be sure that the guessed media type will trigger a download                                        // 150
			// in WebKit, I append .download to the filename.                                                                   // 151
			// https://bugs.webkit.org/show_bug.cgi?id=65440                                                                    // 152
			if (webkit_req_fs && name !== "download") {                                                                         // 153
				name += ".download";                                                                                               // 154
			}                                                                                                                   // 155
			if (type === force_saveable_type || webkit_req_fs) {                                                                // 156
				target_view = view;                                                                                                // 157
			}                                                                                                                   // 158
			if (!req_fs) {                                                                                                      // 159
				fs_error();                                                                                                        // 160
				return;                                                                                                            // 161
			}                                                                                                                   // 162
			fs_min_size += blob.size;                                                                                           // 163
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {                                                        // 164
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {                                       // 165
					var save = function() {                                                                                           // 166
						dir.getFile(name, create_if_not_found, abortable(function(file) {                                                // 167
							file.createWriter(abortable(function(writer) {                                                                  // 168
								writer.onwriteend = function(event) {                                                                          // 169
									target_view.location.href = file.toURL();                                                                     // 170
									filesaver.readyState = filesaver.DONE;                                                                        // 171
									dispatch(filesaver, "writeend", event);                                                                       // 172
									revoke(file);                                                                                                 // 173
								};                                                                                                             // 174
								writer.onerror = function() {                                                                                  // 175
									var error = writer.error;                                                                                     // 176
									if (error.code !== error.ABORT_ERR) {                                                                         // 177
										fs_error();                                                                                                  // 178
									}                                                                                                             // 179
								};                                                                                                             // 180
								"writestart progress write abort".split(" ").forEach(function(event) {                                         // 181
									writer["on" + event] = filesaver["on" + event];                                                               // 182
								});                                                                                                            // 183
								writer.write(blob);                                                                                            // 184
								filesaver.abort = function() {                                                                                 // 185
									writer.abort();                                                                                               // 186
									filesaver.readyState = filesaver.DONE;                                                                        // 187
								};                                                                                                             // 188
								filesaver.readyState = filesaver.WRITING;                                                                      // 189
							}), fs_error);                                                                                                  // 190
						}), fs_error);                                                                                                   // 191
					};                                                                                                                // 192
					dir.getFile(name, {create: false}, abortable(function(file) {                                                     // 193
						// delete file if it already exists                                                                              // 194
						file.remove();                                                                                                   // 195
						save();                                                                                                          // 196
					}), abortable(function(ex) {                                                                                      // 197
						if (ex.code === ex.NOT_FOUND_ERR) {                                                                              // 198
							save();                                                                                                         // 199
						} else {                                                                                                         // 200
							fs_error();                                                                                                     // 201
						}                                                                                                                // 202
					}));                                                                                                              // 203
				}), fs_error);                                                                                                     // 204
			}), fs_error);                                                                                                      // 205
		}                                                                                                                    // 206
		, FS_proto = FileSaver.prototype                                                                                     // 207
		, saveAs = function(blob, name) {                                                                                    // 208
			return new FileSaver(blob, name);                                                                                   // 209
		}                                                                                                                    // 210
	;                                                                                                                     // 211
	// IE 10+ (native saveAs)                                                                                             // 212
	if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {                                                 // 213
		return function(blob, name) {                                                                                        // 214
			return navigator.msSaveOrOpenBlob(auto_bom(blob), name);                                                            // 215
		};                                                                                                                   // 216
	}                                                                                                                     // 217
                                                                                                                       // 218
	FS_proto.abort = function() {                                                                                         // 219
		var filesaver = this;                                                                                                // 220
		filesaver.readyState = filesaver.DONE;                                                                               // 221
		dispatch(filesaver, "abort");                                                                                        // 222
	};                                                                                                                    // 223
	FS_proto.readyState = FS_proto.INIT = 0;                                                                              // 224
	FS_proto.WRITING = 1;                                                                                                 // 225
	FS_proto.DONE = 2;                                                                                                    // 226
                                                                                                                       // 227
	FS_proto.error =                                                                                                      // 228
	FS_proto.onwritestart =                                                                                               // 229
	FS_proto.onprogress =                                                                                                 // 230
	FS_proto.onwrite =                                                                                                    // 231
	FS_proto.onabort =                                                                                                    // 232
	FS_proto.onerror =                                                                                                    // 233
	FS_proto.onwriteend =                                                                                                 // 234
		null;                                                                                                                // 235
                                                                                                                       // 236
	return saveAs;                                                                                                        // 237
}(                                                                                                                     // 238
	   typeof self !== "undefined" && self                                                                                // 239
	|| typeof window !== "undefined" && window                                                                            // 240
	|| this.content                                                                                                       // 241
));                                                                                                                    // 242
// `self` is undefined in Firefox for Android content script context                                                   // 243
// while `this` is nsIContentFrameMessageManager                                                                       // 244
// with an attribute `content` that corresponds to the window                                                          // 245
                                                                                                                       // 246
if (typeof module !== "undefined" && module.exports) {                                                                 // 247
  module.exports.saveAs = saveAs = window.saveAs;                                                                      // 248
} else if ((typeof define !== "undefined" && define !== null) && (define.amd != null)) {                               // 249
  define([], function() {                                                                                              // 250
    return saveAs;                                                                                                     // 251
  });                                                                                                                  // 252
}                                                                                                                      // 253
                                                                                                                       // 254
window.saveAs = saveAs;                                                                                                // 255
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function () {

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/silentcicero:jszip/package-init.js                                                                         //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Browser environment                                                                                                 // 1
if(typeof window !== 'undefined') {                                                                                    // 2
    JSZip = (typeof window.JSZip !== 'undefined') ? window.JSZip : require('JSZip');                                   // 3
}                                                                                                                      // 4
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);

//////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
Package._define("silentcicero:jszip", {
  JSZip: JSZip
});

})();
